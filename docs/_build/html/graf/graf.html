

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>graf package &mdash; LAF Fabric 1.0.1 documentation</title>
  

  
  

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  
  

    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:'../',
        VERSION:'1.0.1',
        COLLAPSE_INDEX:false,
        FILE_SUFFIX:'.html',
        HAS_SOURCE:  true
      };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
    <link rel="top" title="LAF Fabric 1.0.1 documentation" href="../index.html"/>
        <link rel="up" title="graf" href="modules.html"/>
        <link rel="prev" title="graf" href="modules.html"/> 

  <script src="//cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        <a href="../index.html" class="icon icon-home"> LAF Fabric</a>
        <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
  <input type="text" name="q" placeholder="Search docs" />
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix">
        
        
            <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../overview.html">LAF Fabric</a></li>
<li class="toctree-l1"><a class="reference internal" href="../overview.html#laf-graf-and-data-analysis">LAF/GrAF and data analysis</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../overview.html#what-is-laf-graf">What is LAF/GrAF</a></li>
<li class="toctree-l2"><a class="reference internal" href="../overview.html#data">Data</a></li>
<li class="toctree-l2"><a class="reference internal" href="../overview.html#existing-tools-for-laf-graf-resources">Existing tools for LAF/GrAF resources</a></li>
<li class="toctree-l2"><a class="reference internal" href="../overview.html#this-workbench">This workbench</a></li>
<li class="toctree-l2"><a class="reference internal" href="../overview.html#rationale">Rationale</a></li>
<li class="toctree-l2"><a class="reference internal" href="../overview.html#author">Author</a></li>
<li class="toctree-l2"><a class="reference internal" href="../overview.html#links">Links</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../workbench.html">LAF workbench</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../workbench.html#license">License</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workbench.html#how-to-use-the-workbench">How to use the workbench?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workbench.html#designed-for-performance">Designed for Performance</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workbench.html#graf-feature-coverage">GrAF feature coverage</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workbench.html#development">Development</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../taskwriting.html">Writing Tasks</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../taskwriting.html#what-is-a-task">What is a task?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../taskwriting.html#a-leading-example">A leading example</a></li>
<li class="toctree-l2"><a class="reference internal" href="../taskwriting.html#more-on-features">More on features</a></li>
<li class="toctree-l2"><a class="reference internal" href="../taskwriting.html#information-flow-from-task-to-workbench">Information flow from task to workbench</a></li>
<li class="toctree-l2"><a class="reference internal" href="../taskwriting.html#information-flow-from-workbench-to-task">Information flow from workbench to task</a></li>
<li class="toctree-l2"><a class="reference internal" href="../taskwriting.html#output">Output</a></li>
<li class="toctree-l2"><a class="reference internal" href="../taskwriting.html#node-order">Node order</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../tasks/modules.html">tasks</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../tasks/esther.html">esther module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tasks/gender.html">gender module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tasks/involved.html">involved module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tasks/isaiah.html">isaiah module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tasks/lingo.html">lingo module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tasks/objects.html">objects module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tasks/plain.html">plain module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tasks/proper.html">proper module</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="modules.html">graf</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="">graf package</a></li>
</ul>
</li>
</ul>

        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top">
        <i data-toggle="wy-nav-top" class="icon icon-reorder"></i>
        <a href="/">LAF Fabric</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <ul class="wy-breadcrumbs">
  <li><a href="../index.html">Docs</a> &raquo;</li>
  <li><a href="">graf package</a></li>
    <li class="wy-breadcrumbs-aside">
      
        <a href="../_sources/graf/graf.txt" rel="nofollow"> View page source</a>
      
    </li>
</ul>
<hr/>

          
  <div class="section" id="graf-package">
<h1>graf package<a class="headerlink" href="#graf-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-graf.compiler">
<span id="graf-compiler-module"></span><h2>graf.compiler module<a class="headerlink" href="#module-graf.compiler" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="graf.compiler.GrafCompiler">
<em class="property">class </em><tt class="descname">GrafCompiler</tt><big>(</big><em>env</em><big>)</big><a class="reference internal" href="../_modules/graf/compiler.html#GrafCompiler"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.compiler.GrafCompiler" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#graf.graf.Graf" title="graf.graf.Graf"><tt class="xref py py-class docutils literal"><span class="pre">graf.graf.Graf</span></tt></a></p>
<p>Takes care of the compilation of LAF xml data into binary data.</p>
<p>There are two stages in compilation:</p>
<ul class="simple">
<li>parsing the XML data by means of a SAX parser (a lengthy process)</li>
<li>remodeling the parse results in really tight data structures</li>
</ul>
<p>Upon creation, the relevant directories are communicated.</p>
<p>The initialization of the base class is performed, and we change working directory to the location of the LAF source.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>env (str):</dt>
<dd>path information</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="graf.compiler.GrafCompiler.compiler">
<tt class="descname">compiler</tt><big>(</big><em>force=False</em><big>)</big><a class="reference internal" href="../_modules/graf/compiler.html#GrafCompiler.compiler"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.compiler.GrafCompiler.compiler" title="Permalink to this definition">¶</a></dt>
<dd><p>Manages the complete compilation process.</p>
<p>Detects the need for compiling, responds to the <em>force</em> argument. Then parses, remodels and writes.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>force (bool):</dt>
<dd>whether to compile even if the binary data looks up to date.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="graf.compiler.GrafCompiler.env">
<tt class="descname">env</tt><em class="property"> = None</em><a class="headerlink" href="#graf.compiler.GrafCompiler.env" title="Permalink to this definition">¶</a></dt>
<dd><p>Instance member to hold config settings etc</p>
</dd></dl>

<dl class="method">
<dt id="graf.compiler.GrafCompiler.finish">
<tt class="descname">finish</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/graf/compiler.html#GrafCompiler.finish"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.compiler.GrafCompiler.finish" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="graf.compiler.GrafCompiler.has_compiled">
<tt class="descname">has_compiled</tt><em class="property"> = None</em><a class="headerlink" href="#graf.compiler.GrafCompiler.has_compiled" title="Permalink to this definition">¶</a></dt>
<dd><p>Instance member to tell whether compilation has actually taken place</p>
</dd></dl>

<dl class="method">
<dt id="graf.compiler.GrafCompiler.model">
<tt class="descname">model</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/graf/compiler.html#GrafCompiler.model"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.compiler.GrafCompiler.model" title="Permalink to this definition">¶</a></dt>
<dd><p>Call the remodeler and store the remodeled data in the object.</p>
</dd></dl>

<dl class="method">
<dt id="graf.compiler.GrafCompiler.needs_compiling">
<tt class="descname">needs_compiling</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/graf/compiler.html#GrafCompiler.needs_compiling"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.compiler.GrafCompiler.needs_compiling" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks whether the compiled binary data is still up to date.</p>
<p>The criterion is whether the generated statistics file at the binary side is newer than the chosen GrAF header file.</p>
<dl class="docutils">
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>bool:</dt>
<dd>whether the criterion for compiling holds.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="graf.compiler.GrafCompiler.parse">
<tt class="descname">parse</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/graf/compiler.html#GrafCompiler.parse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.compiler.GrafCompiler.parse" title="Permalink to this definition">¶</a></dt>
<dd><p>Call the XML parser and collect the parse results.</p>
<p>Some parse results must be remodelled afterwards.
After remodelling some parse data can be thrown away.
Only store data that is needed for task execution in the object.</p>
<p>The actual parsing is done in the module <a class="reference internal" href="#module-graf.parse" title="graf.parse"><tt class="xref py py-mod docutils literal"><span class="pre">parse</span></tt></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="graf.compiler.GrafCompiler.temp_data_items">
<tt class="descname">temp_data_items</tt><em class="property"> = {}</em><a class="headerlink" href="#graf.compiler.GrafCompiler.temp_data_items" title="Permalink to this definition">¶</a></dt>
<dd><p>Holds some data delivered by the parsed that can be thrown away later.
The data that we must keep is stored in the object, of course.</p>
</dd></dl>

<dl class="method">
<dt id="graf.compiler.GrafCompiler.write_data">
<tt class="descname">write_data</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/graf/compiler.html#GrafCompiler.write_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.compiler.GrafCompiler.write_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes compiled data to disk.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-graf.graf">
<span id="graf-graf-module"></span><h2>graf.graf module<a class="headerlink" href="#module-graf.graf" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="graf.graf.Graf">
<em class="property">class </em><tt class="descname">Graf</tt><a class="reference internal" href="../_modules/graf/graf.html#Graf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.graf.Graf" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">builtins.object</span></tt></p>
<p>Base class for compiling LAF resources and running analytic tasks on them.</p>
<p>The data of this class represents the compiled data on the basis of which tasks can run.
This data is created by a <a class="reference internal" href="#graf.compiler.GrafCompiler" title="graf.compiler.GrafCompiler"><tt class="xref py py-class docutils literal"><span class="pre">GrafCompiler</span></tt></a> that derives from this class.</p>
<p>The <a class="reference internal" href="#graf.graf.Graf" title="graf.graf.Graf"><tt class="xref py py-class docutils literal"><span class="pre">Graf</span></tt></a> knows the structure of the data, and how to load it into memory.
It can also see what it loaded and what not, and it can compute conditions that require compiling and (re)loading.</p>
<p>Upon creation, empty datastructures are initialized to hold the binary,
compiled LAF data and create a directory for their serializations on disk.</p>
<p>The Graf object holds information that Graf tasks need to perform their operations.
The most important piece of information is the data itself.
This data consists of arrays and dictionaries that together hold the information that is compiled from a LAF resource.</p>
<p>Other things that happen:</p>
<ol class="arabic simple">
<li>a fresh Timestamp object is created, which records the current time and can issue progress messages containing the amount
of time that has elapsed since this object has been created.</li>
<li>if the directory that should hold the compiled data does not exist,
a new directory is created Of course this means that before executing any tasks,
the LAF resource has to be (re)compiled.</li>
</ol>
<dl class="docutils">
<dt>Returns:</dt>
<dd>object with data structures initialized, ready to load the compiled data from disk.</dd>
</dl>
<dl class="attribute">
<dt id="graf.graf.Graf.BIN_EXT">
<tt class="descname">BIN_EXT</tt><em class="property"> = 'bin'</em><a class="headerlink" href="#graf.graf.Graf.BIN_EXT" title="Permalink to this definition">¶</a></dt>
<dd><p>extension for binary files</p>
</dd></dl>

<dl class="attribute">
<dt id="graf.graf.Graf.COMPILE_TASK">
<tt class="descname">COMPILE_TASK</tt><em class="property"> = 'compile'</em><a class="headerlink" href="#graf.graf.Graf.COMPILE_TASK" title="Permalink to this definition">¶</a></dt>
<dd><p>name of the compile task</p>
</dd></dl>

<dl class="attribute">
<dt id="graf.graf.Graf.LOG_NAME">
<tt class="descname">LOG_NAME</tt><em class="property"> = '__log__'</em><a class="headerlink" href="#graf.graf.Graf.LOG_NAME" title="Permalink to this definition">¶</a></dt>
<dd><p>log file base name for a task</p>
</dd></dl>

<dl class="attribute">
<dt id="graf.graf.Graf.STAT_NAME">
<tt class="descname">STAT_NAME</tt><em class="property"> = '__stat__'</em><a class="headerlink" href="#graf.graf.Graf.STAT_NAME" title="Permalink to this definition">¶</a></dt>
<dd><p>statistics file base name for a task</p>
</dd></dl>

<dl class="attribute">
<dt id="graf.graf.Graf.TEXT_EXT">
<tt class="descname">TEXT_EXT</tt><em class="property"> = 'txt'</em><a class="headerlink" href="#graf.graf.Graf.TEXT_EXT" title="Permalink to this definition">¶</a></dt>
<dd><p>extension for text files</p>
</dd></dl>

<dl class="method">
<dt id="graf.graf.Graf.add_logfile">
<tt class="descname">add_logfile</tt><big>(</big><em>location=None</em>, <em>name=None</em><big>)</big><a class="reference internal" href="../_modules/graf/graf.html#Graf.add_logfile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.graf.Graf.add_logfile" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and open a log file for a given task.</p>
<p>When tasks run, they generate progress messages with timing information in them.
They may issue errors and warnings. All this information also goes into a log file.
The log file is placed in the result directory of the task at hand.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>location (str):</dt>
<dd>override default directory for log file</dd>
<dt>name (str):</dt>
<dd>override default name for log file</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="graf.graf.Graf.adjust_all">
<tt class="descname">adjust_all</tt><big>(</big><em>directives</em><big>)</big><a class="reference internal" href="../_modules/graf/graf.html#Graf.adjust_all"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.graf.Graf.adjust_all" title="Permalink to this definition">¶</a></dt>
<dd><p>Top level data management function: adjust the data to the task at hand.
Load what is needed, discard what is no longer need, leave alone what does not to be changed.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>directives (dict):</dt>
<dd>specification of the needs of the task at hand, in terms of
which features it uses and whether there is need for the orginal XML ids.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="graf.graf.Graf.adjust_data">
<tt class="descname">adjust_data</tt><big>(</big><em>label</em>, <em>directives</em><big>)</big><a class="reference internal" href="../_modules/graf/graf.html#Graf.adjust_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.graf.Graf.adjust_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Top level data management function for adjusting data.
Now per key in the <tt class="docutils literal"><span class="pre">data_items_def</span></tt> dictionary.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>label (str):</dt>
<dd>key in <tt class="docutils literal"><span class="pre">data_items_def</span></tt>, indicating the portion of data that has to be adjusted.</dd>
<dt>directives (dict):</dt>
<dd>passed directly from <a class="reference internal" href="#graf.graf.Graf.adjust_all" title="graf.graf.Graf.adjust_all"><tt class="xref py py-meth docutils literal"><span class="pre">adjust_all()</span></tt></a>.</dd>
</dl>
</dd>
</dl>
<p>It calls <a class="reference internal" href="#graf.graf.Graf.check_data" title="graf.graf.Graf.check_data"><tt class="xref py py-meth docutils literal"><span class="pre">check_data()</span></tt></a> to see whether there is a change affecting the data under this <tt class="docutils literal"><span class="pre">label</span></tt>.
The answer might be: no (0), or yes absolutely (1) or partly (2), depending on the <em>directives</em>.</p>
<p>Clearance of data is deferred to <a class="reference internal" href="#graf.graf.Graf.clear_data" title="graf.graf.Graf.clear_data"><tt class="xref py py-meth docutils literal"><span class="pre">clear_data()</span></tt></a>, loading to <a class="reference internal" href="#graf.graf.Graf.load_data" title="graf.graf.Graf.load_data"><tt class="xref py py-meth docutils literal"><span class="pre">load_data()</span></tt></a>.</p>
<p>The interesting part is what happens if the answer was <em>partly (2)</em>. 
It then happens on the <em>directives</em> argument. The difference between what is needed and what is already
loaded, is computed, and selective clearing and loading takes place, avoiding clearing
and loading of the same items.</p>
</dd></dl>

<dl class="method">
<dt id="graf.graf.Graf.check_data">
<tt class="descname">check_data</tt><big>(</big><em>label</em><big>)</big><a class="reference internal" href="../_modules/graf/graf.html#Graf.check_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.graf.Graf.check_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Medium level datamanagement function to check how conditions have changed since
last task execution and what it implies for the data at hand.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>label (str):</dt>
<dd>key in <tt class="docutils literal"><span class="pre">data_items_def</span></tt>, indicating the portion of data that has to be adjusted.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="graf.graf.Graf.clear_all">
<tt class="descname">clear_all</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/graf/graf.html#Graf.clear_all"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.graf.Graf.clear_all" title="Permalink to this definition">¶</a></dt>
<dd><p>Low level data management function to clear all data.</p>
</dd></dl>

<dl class="method">
<dt id="graf.graf.Graf.clear_data">
<tt class="descname">clear_data</tt><big>(</big><em>label</em>, <em>features=None</em>, <em>kinds=None</em><big>)</big><a class="reference internal" href="../_modules/graf/graf.html#Graf.clear_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.graf.Graf.clear_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Low level data management function to clear all data.
Now per key in the <tt class="docutils literal"><span class="pre">data_items_def</span></tt> dictionary.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>features (iterable):</dt>
<dd>A list of (aspace, alabel, fname, kind) tuples that each specify a feature.
Optional. If given, only the data for the features specified, will be reset.</dd>
<dt>kinds (iterable):</dt>
<dd>A list of kinds (<tt class="docutils literal"><span class="pre">node</span></tt> or <tt class="docutils literal"><span class="pre">edge</span></tt>).
Optional. If given, only the xmlids data for the
nodes or edges as specified, will be reset.</dd>
</dl>
</dd>
</dl>
<p>If none of the optional features is present, all data for the specified label will be reset.</p>
</dd></dl>

<dl class="attribute">
<dt id="graf.graf.Graf.data_items">
<tt class="descname">data_items</tt><em class="property"> = None</em><a class="headerlink" href="#graf.graf.Graf.data_items" title="Permalink to this definition">¶</a></dt>
<dd><p>Instance member holding the compiled data in the form of a dictionary of arrays and lists.</p>
<p>This dictionary is keyed by the same keys as <tt class="docutils literal"><span class="pre">data_items_def</span></tt> plus a few additional ones,
dependent on tnd predictable from he data type and data group.</p>
<p>See the <a class="reference internal" href="#module-graf.compiler" title="graf.compiler"><tt class="xref py py-mod docutils literal"><span class="pre">compiler</span></tt></a> and <a class="reference internal" href="#module-graf.model" title="graf.model"><tt class="xref py py-mod docutils literal"><span class="pre">model</span></tt></a> modules for the way the compiled data is created.</p>
</dd></dl>

<dl class="attribute">
<dt id="graf.graf.Graf.data_items_def">
<tt class="descname">data_items_def</tt><em class="property"> = None</em><a class="headerlink" href="#graf.graf.Graf.data_items_def" title="Permalink to this definition">¶</a></dt>
<dd><p>There are various kinds of data, by their shape and by their function.
The instance member <em>data_items_def</em> contains their declarations in the
form of an ordered dictionary, keyed by labels and with a tuple of data type and data group
as values.</p>
<p>The instance member <em>data_items</em> contains the data itself.</p>
<p>The types of data are</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">x_mapping</span></tt>, group <tt class="docutils literal"><span class="pre">xmlids</span></tt>:</dt>
<dd>mappings between xml identifiers as they occur in the original LAF source
and the node/edge numbers in the compiled data.
There are two dictionaries: <tt class="docutils literal"><span class="pre">xid_int</span></tt> (going from xml to integer) and
<tt class="docutils literal"><span class="pre">xid_rep</span></tt> (going from integer to xml).
Both contain two dictionaries, one for nodes and one for edges separately.</dd>
<dt><tt class="docutils literal"><span class="pre">array</span></tt>, group <tt class="docutils literal"><span class="pre">common</span></tt>:</dt>
<dd><p class="first">Simply tables of integer values.
Most of the data common to all tasks is in <tt class="docutils literal"><span class="pre">array</span></tt> s and <tt class="docutils literal"><span class="pre">double_array</span></tt> s (see below).</p>
<dl class="last docutils">
<dt><tt class="docutils literal"><span class="pre">region_begin</span></tt> and <tt class="docutils literal"><span class="pre">region_end</span></tt>:</dt>
<dd>At position <tt class="docutils literal"><span class="pre">i</span></tt>: the start and end anchors for region <tt class="docutils literal"><span class="pre">i</span></tt>.</dd>
<dt><tt class="docutils literal"><span class="pre">node_sort</span></tt>:</dt>
<dd>All nodes ordered as induced by the region anchors.
Nodes that start before others, come before them,
nodes that have equal start points are ordered such that the one with the later end point
comes first. If both have equal end points, the order is arbitrary.
If the nodes correspond to objects in a hierarchy without gaps, then embedding objects come before
embedded objects.</dd>
<dt><tt class="docutils literal"><span class="pre">edges_from</span></tt> and <tt class="docutils literal"><span class="pre">edges_to</span></tt>:</dt>
<dd>At position <tt class="docutils literal"><span class="pre">i</span></tt>: the source and the target of edge <tt class="docutils literal"><span class="pre">i</span></tt>.</dd>
</dl>
</dd>
<dt><tt class="docutils literal"><span class="pre">double_array</span></tt>, group <tt class="docutils literal"><span class="pre">common</span></tt>:</dt>
<dd><p class="first">Twin arrays representing a list of records where records may have variable length.
The primary array is has the name given, and contains at position <tt class="docutils literal"><span class="pre">i</span></tt> the starting
point for record <tt class="docutils literal"><span class="pre">i</span></tt> in the secondary array.
The record in the second array starts with a cell containing the length of the record,
and then so many cells of information.
This array has as its name the name of the primary array plus <tt class="docutils literal"><span class="pre">_items</span></tt>.</p>
<dl class="last docutils">
<dt><tt class="docutils literal"><span class="pre">node_region</span></tt> and <tt class="docutils literal"><span class="pre">node_region_items</span></tt>:</dt>
<dd>For node <tt class="docutils literal"><span class="pre">i</span></tt> the record <tt class="docutils literal"><span class="pre">i</span></tt> consists of all regions that this node is linked to.</dd>
<dt><tt class="docutils literal"><span class="pre">node_out</span></tt> and <tt class="docutils literal"><span class="pre">node_out_items</span></tt>:</dt>
<dd>For node <tt class="docutils literal"><span class="pre">i</span></tt> the record <tt class="docutils literal"><span class="pre">i</span></tt> consists of all outgoing edges from this node.</dd>
<dt><tt class="docutils literal"><span class="pre">node_in</span></tt> and <tt class="docutils literal"><span class="pre">node_in_items</span></tt>:</dt>
<dd>For node <tt class="docutils literal"><span class="pre">i</span></tt> the record <tt class="docutils literal"><span class="pre">i</span></tt> consists of all incoming edges into this node.</dd>
</dl>
</dd>
<dt><tt class="docutils literal"><span class="pre">feature_mapping</span></tt>, group <tt class="docutils literal"><span class="pre">feature</span></tt>:</dt>
<dd><p class="first">Contains all the feature data. There are in fact three related dictionaries that do the job.</p>
<dl class="docutils">
<dt><tt class="docutils literal"><span class="pre">feature</span></tt>:</dt>
<dd>Keyed by <em>annotation space</em>, then by <em>annotation label</em> (both referring to the annotation that
contains the feature at hand), then by <em>feature name</em>, then by <em>kind</em> (<tt class="docutils literal"><span class="pre">True</span></tt> for nodes,
<tt class="docutils literal"><span class="pre">False</span></tt> for edges). At this level we have a dictionary, keyed by either the nodes or the edges
(both as integers), and the value for each key is the value of the feature, again coded as
integer.</dd>
<dt><tt class="docutils literal"><span class="pre">feature_val_int</span></tt> and <tt class="docutils literal"><span class="pre">feature_val_rep</span></tt>:</dt>
<dd>Raw values are not entered in the <tt class="docutils literal"><span class="pre">feature</span></tt> dictionary. Instead, every distinct value is uniquely
identified by an integer. It is this integer that is stored in the <tt class="docutils literal"><span class="pre">feature</span></tt> dictionary.
<tt class="docutils literal"><span class="pre">feature_val_int</span></tt> maps from raw values to integers, and <tt class="docutils literal"><span class="pre">feature_val_raw</span></tt> maps from integers to
raw values.
The mapping of values is per individual feature.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">If a feature occurs on both nodes and edges, the feature is split into two features with the same name,
the one acting on nodes and the other acting on edges. In the compiled version, every feature has a kind,
and in order to obtain a feature value, you have to specify the feature name and the feature kind (and of course
the annotation space and annotation label).</p>
</div>
<p>So the complete road to a value is:</p>
<div class="highlight-python"><pre>val = self.data_items[&#x27;feature``][annotation_space][annotation_label][feature_name][kind][node_or_edge_id]</pre>
</div>
<p>and if you want to get the raw value back you can do so by:</p>
<div class="highlight-python"><pre>raw_val = self.data_items[&#x27;feature_val_rep``][annotation_space][annotation_label][feature_name][kind][val]</pre>
</div>
<p>Of course, when you do this for various features inside a loop that runs over hundred thousands of nodes,
you want to give these dictionaries local names outside the loop, so that most dictionary lookup calculations
only need to be done a few times.</p>
<p class="last">The API will help you to lookup feature values and raw values efficiently, and with clean looking code.
See <a class="reference internal" href="#module-graf.task" title="graf.task"><tt class="xref py py-mod docutils literal"><span class="pre">task</span></tt></a> for a description of the API, especially
<a class="reference internal" href="#graf.task.GrafTask.get_mappings" title="graf.task.GrafTask.get_mappings"><tt class="xref py py-meth docutils literal"><span class="pre">get_mappings</span></tt></a></p>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="graf.graf.Graf.env">
<tt class="descname">env</tt><em class="property"> = None</em><a class="headerlink" href="#graf.graf.Graf.env" title="Permalink to this definition">¶</a></dt>
<dd><p>Holds the context information for the current task, such as chosen source and task.</p>
</dd></dl>

<dl class="method">
<dt id="graf.graf.Graf.finish_logfile">
<tt class="descname">finish_logfile</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/graf/graf.html#Graf.finish_logfile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.graf.Graf.finish_logfile" title="Permalink to this definition">¶</a></dt>
<dd><p>Explicitly close log file.</p>
<p>Do not rely on the <tt class="docutils literal"><span class="pre">__del__</span></tt> method and hence on garbage collection.
The program might terminate without writing the last bits to file.</p>
</dd></dl>

<dl class="method">
<dt id="graf.graf.Graf.flush_logfile">
<tt class="descname">flush_logfile</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/graf/graf.html#Graf.flush_logfile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.graf.Graf.flush_logfile" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="graf.graf.Graf.given_features">
<tt class="descname">given_features</tt><em class="property"> = None</em><a class="headerlink" href="#graf.graf.Graf.given_features" title="Permalink to this definition">¶</a></dt>
<dd><p>Instance member holding the information about needed features, provided by the task at hand.</p>
</dd></dl>

<dl class="method">
<dt id="graf.graf.Graf.is_loaded">
<tt class="descname">is_loaded</tt><big>(</big><em>label</em>, <em>kind=None</em>, <em>feature=None</em><big>)</big><a class="reference internal" href="../_modules/graf/graf.html#Graf.is_loaded"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.graf.Graf.is_loaded" title="Permalink to this definition">¶</a></dt>
<dd><p>Medium level datamanagement function to check what data is actually loaded.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>label (str):</dt>
<dd>key in <tt class="docutils literal"><span class="pre">data_items_def</span></tt>, indicating the portion of data that has to be adjusted.</dd>
<dt>feature (tuple):</dt>
<dd>Specification of the feature of interest.
Only the load status of this feature will be returned.</dd>
<dt>kind (str):</dt>
<dd>The kind (<tt class="docutils literal"><span class="pre">node</span></tt> or <tt class="docutils literal"><span class="pre">edge</span></tt>).
Only the xmlids data status for the given kind will be returned.
nodes or edges as specified, will be reset.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="graf.graf.Graf.load_data">
<tt class="descname">load_data</tt><big>(</big><em>label</em>, <em>features=None</em>, <em>kinds=None</em><big>)</big><a class="reference internal" href="../_modules/graf/graf.html#Graf.load_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.graf.Graf.load_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Low level data management function to load data from disk into memory.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>features (iterable):</dt>
<dd>A list of (aspace, alabel, fname, kind) tuples that each specify a feature.
Optional. If given, only the data for the features specified, will be loaded.</dd>
<dt>kinds (iterable):</dt>
<dd>A list of kinds (<tt class="docutils literal"><span class="pre">node</span></tt> or <tt class="docutils literal"><span class="pre">edge</span></tt>).
Optional. If given, only the xmlids data for the
nodes or edges as specified, will be loaded.</dd>
</dl>
</dd>
</dl>
<p>If none of the optional features is present, all data for the specified label will be loaded.</p>
</dd></dl>

<dl class="attribute">
<dt id="graf.graf.Graf.log">
<tt class="descname">log</tt><em class="property"> = None</em><a class="headerlink" href="#graf.graf.Graf.log" title="Permalink to this definition">¶</a></dt>
<dd><p>handle of a log file, usually open for writing. Used for the log of the compilation process
and of the task executions.</p>
</dd></dl>

<dl class="method">
<dt id="graf.graf.Graf.make_inverse">
<tt class="descname">make_inverse</tt><big>(</big><em>mapping</em><big>)</big><a class="reference internal" href="../_modules/graf/graf.html#Graf.make_inverse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.graf.Graf.make_inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates the inverse lookup table for a data table</p>
<p>This is a low level function for creating inverse mappings.
When mappings (such as from xml-ids to integers vv.) are stored to disk, the inverse mapping is not stored.
Upon loading, the inverse mapping is generated by means of this function.</p>
</dd></dl>

<dl class="method">
<dt id="graf.graf.Graf.progress">
<tt class="descname">progress</tt><big>(</big><em>msg</em>, <em>newline=True</em>, <em>withtime=True</em><big>)</big><a class="reference internal" href="../_modules/graf/graf.html#Graf.progress"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.graf.Graf.progress" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience method to call the progress of the associated stamp directly from the Graf object</p>
</dd></dl>

<dl class="method">
<dt id="graf.graf.Graf.read_stats">
<tt class="descname">read_stats</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/graf/graf.html#Graf.read_stats"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.graf.Graf.read_stats" title="Permalink to this definition">¶</a></dt>
<dd><p>Read compilation statistics from file</p>
<p>The compile process generates some statistics that must be read by the task that loads the compiled data.
In order to read an <a class="reference external" href="http://docs.python.org/3.3/library/array.html#module-array" title="(in Python v3.3)"><tt class="xref py py-mod docutils literal"><span class="pre">array</span></tt></a> by means of its <a class="reference external" href="http://docs.python.org/3.3/library/array.html#array.array.fromfile" title="(in Python v3.3)"><tt class="xref py py-meth docutils literal"><span class="pre">array.array.fromfile()</span></tt></a> method,
we need to know the length of it on beforehand.</p>
<p>And later, when we want to load new feature data on top of the existing data, we need to know
how many distinct values features have.</p>
</dd></dl>

<dl class="method">
<dt id="graf.graf.Graf.set_environment">
<tt class="descname">set_environment</tt><big>(</big><em>source</em>, <em>annox</em>, <em>task</em><big>)</big><a class="reference internal" href="../_modules/graf/graf.html#Graf.set_environment"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.graf.Graf.set_environment" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the source and result locations for a task execution.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>source (str):</dt>
<dd>key for the source</dd>
<dt>annox (str):</dt>
<dd>name of the extra annotation package</dd>
<dt>task:</dt>
<dd>the chosen task</dd>
</dl>
</dd>
</dl>
<p>Sets <em>self.env</em>, a dictionary containg:</p>
<ul class="simple">
<li>source: <em>source</em></li>
<li>annox: <em>annox</em></li>
<li>task: <em>task</em></li>
<li>compile (bool): whether to force (re)compilation</li>
<li>settings (<a class="reference external" href="http://docs.python.org/3.3/library/configparser.html#configparser.ConfigParser" title="(in Python v3.3)"><tt class="xref py py-class docutils literal"><span class="pre">configparser.ConfigParser</span></tt></a>): entries corresponding to the main configuration file</li>
<li>additional computed settings adapt to the current source and task</li>
</ul>
</dd></dl>

<dl class="attribute">
<dt id="graf.graf.Graf.stamp">
<tt class="descname">stamp</tt><em class="property"> = None</em><a class="headerlink" href="#graf.graf.Graf.stamp" title="Permalink to this definition">¶</a></dt>
<dd><p>Instance member holding the <a class="reference internal" href="#graf.timestamp.Timestamp" title="graf.timestamp.Timestamp"><tt class="xref py py-class docutils literal"><span class="pre">Timestamp</span></tt></a> object.
Useful to deliver progress messages with timing information.</p>
</dd></dl>

<dl class="method">
<dt id="graf.graf.Graf.store_all">
<tt class="descname">store_all</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/graf/graf.html#Graf.store_all"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.graf.Graf.store_all" title="Permalink to this definition">¶</a></dt>
<dd><p>Top level data management function: write data from memory to disk.</p>
<p>This function is typically invoked at the end of compilation. 
When in the business of running user tasks, there is no need for this function, 
since tasks do not modify the data.</p>
</dd></dl>

<dl class="method">
<dt id="graf.graf.Graf.store_data">
<tt class="descname">store_data</tt><big>(</big><em>label</em><big>)</big><a class="reference internal" href="../_modules/graf/graf.html#Graf.store_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.graf.Graf.store_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Top level data management function for writing data to disk.
Now per key in the <tt class="docutils literal"><span class="pre">data_items_def</span></tt> dictionary.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>label (str):</dt>
<dd>key in <tt class="docutils literal"><span class="pre">data_items_def</span></tt>, indicating the portion of data that has to be adjusted.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="graf.graf.Graf.write_stats">
<tt class="descname">write_stats</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/graf/graf.html#Graf.write_stats"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.graf.Graf.write_stats" title="Permalink to this definition">¶</a></dt>
<dd><p>Write compilation statistics to file</p>
<p>The compile process generates some statistics that must be read by the task that loads the compiled data.</p>
</dd></dl>

</dd></dl>

<dl class="exception">
<dt id="graf.graf.GrafException">
<em class="property">exception </em><tt class="descname">GrafException</tt><big>(</big><em>message</em>, <em>stamp</em>, <em>Errors</em><big>)</big><a class="reference internal" href="../_modules/graf/graf.html#GrafException"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.graf.GrafException" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">builtins.Exception</span></tt></p>
</dd></dl>

</div>
<div class="section" id="module-graf.model">
<span id="graf-model-module"></span><h2>graf.model module<a class="headerlink" href="#module-graf.model" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="graf.model.arrayify">
<tt class="descname">arrayify</tt><big>(</big><em>source_list</em><big>)</big><a class="reference internal" href="../_modules/graf/model.html#arrayify"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.model.arrayify" title="Permalink to this definition">¶</a></dt>
<dd><p>Efficient storage of a list of lists of integers in two Python <a class="reference external" href="http://docs.python.org/3.3/library/array.html#module-array" title="(in Python v3.3)"><tt class="xref py py-mod docutils literal"><span class="pre">array</span></tt></a>.</p>
<p><em>This is one of the most important tricks of the whole workbench, and yet it is only 10 lines of code!</em></p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>source_list (iterable):</dt>
<dd>a list of lists of integers</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first docutils">
<dt>(index_array, items_array):</dt>
<dd>two <a class="reference external" href="http://docs.python.org/3.3/library/array.html#module-array" title="(in Python v3.3)"><tt class="xref py py-mod docutils literal"><span class="pre">array</span></tt></a> s.</dd>
</dl>
<p class="last"><em>index_array</em> contains an index for each item in <em>source_list</em>.
<em>items_array</em> contains all the items in the following way: if an item with <em>n</em> members has to be added,
then first the number <em>n</em> is added, and then all the members.
This is how you get the original information back: if you want the 
members of item <em>i</em> in <em>source_list</em>, read number <em>i</em> in <em>index_array</em>, say <em>k</em>, go to position <em>k</em> in
<em>items_array</em>, read the number at that position, say <em>n</em>,
and then find the members at the next <em>n</em> positions in <em>items_array</em>.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="graf.model.model">
<tt class="descname">model</tt><big>(</big><em>data_items</em>, <em>temp_data_items</em>, <em>stamp</em><big>)</big><a class="reference internal" href="../_modules/graf/model.html#model"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.model.model" title="Permalink to this definition">¶</a></dt>
<dd><p>Remodels various data structures</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>data_items:</dt>
<dd>data structures coming from <a class="reference internal" href="#module-graf.parse" title="graf.parse"><tt class="xref py py-mod docutils literal"><span class="pre">parse</span></tt></a>, that are here to stay</dd>
<dt>temp_data_items:</dt>
<dd>data structures coming from <a class="reference internal" href="#module-graf.parse" title="graf.parse"><tt class="xref py py-mod docutils literal"><span class="pre">parse</span></tt></a> that may be thrown away</dd>
<dt>stamp (<a class="reference internal" href="#graf.timestamp.Timestamp" title="graf.timestamp.Timestamp"><tt class="xref py py-class docutils literal"><span class="pre">Timestamp</span></tt></a>):</dt>
<dd>object for issuing progress messages</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>The resulting permanent remodelled data structures.</dd>
</dl>
<p>The transformations are:</p>
<dl class="docutils">
<dt>Nodes and regions:</dt>
<dd>The list linking regions to nodes is transformed into a double array.</dd>
<dt>Nodes and anchors:</dt>
<dd>As a preparation to sorting, the minimal and maximal anchors of each node
are determined. Nodes may be linked to many regions.</dd>
<dt>Node sorting:</dt>
<dd><p class="first">Create a list of nodes in a sort order derived from their linking to regions,
and the ordered nature of the primary data.</p>
<p class="last"><em>node1</em> comes before <em>node2</em> if <em>node1</em> starts before <em>node2</em>.
If <em>node1</em> and <em>node2</em> start at the same point, the object that ends last comes first.
Otherwise objects count as equal in position.
If the objects are sorted in this way, embedding objects come before all objects that are embedded in it.</p>
</dd>
<dt>Nodes and edges:</dt>
<dd>Collect the outgoing and incoming edges for each node in a pair of double arrays.</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-graf.parse">
<span id="graf-parse-module"></span><h2>graf.parse module<a class="headerlink" href="#module-graf.parse" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="graf.parse.AnnotationHandler">
<em class="property">class </em><tt class="descname">AnnotationHandler</tt><big>(</big><em>annotation_file</em>, <em>stamp</em><big>)</big><a class="reference internal" href="../_modules/graf/parse.html#AnnotationHandler"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.parse.AnnotationHandler" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="http://docs.python.org/3.3/library/xml.sax.handler.html#xml.sax.handler.ContentHandler" title="(in Python v3.3)"><tt class="xref py py-class docutils literal"><span class="pre">xml.sax.handler.ContentHandler</span></tt></a></p>
<p>Handlers used by SAX parsing the annotation files themselves</p>
<p>We have to collect all elements <em>region</em>, <em>node</em> and subelement <em>link</em>, <em>edge</em>, <em>annotationSpace</em>, <em>a</em> (annotation) and <em>f</em> (feature).
From these elements we retrieve identifiers and other attributes.
We map all identifiers to integers.
When we have to associate one piece of data to other pieces, we create arrays of those integers.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The parse process is presupposes that regions are encountered before nodes that link to them,
nodes before edges that connect them, nodes and edges before annotations that target them.
The creator of the LAF resource can organize the files that way. The parser reads the annotation file in the
order specified in the Graf header file.</p>
</div>
<p>Here is a description of the arrays we create:</p>
<dl class="docutils">
<dt><em>region_begin</em>, <em>region_end</em></dt>
<dd>Every region has an <em>anchors</em> attribute specifying a point or interval in the primary data. We consider a point <em>i</em> as the interval <em>i .. i</em>.
<em>region_begin</em> contains the start anchor of region <em>i</em> for each <em>i</em>, and <em>region_end</em> the end anchor.</dd>
<dt><em>edges_from</em>, <em>edges_to</em></dt>
<dd>Every edge goes from one node to an other. <em>edges_from</em> contains the from node of edge <em>i</em> for each <em>i</em>, and <em>edges_end</em> the to node.</dd>
</dl>
<p>There is also a list of arrays:</p>
<dl class="docutils">
<dt><em>node_region_list</em></dt>
<dd>Element <em>i</em> of this list contains an array with the regions attached to node <em>i</em>.</dd>
</dl>
<p>And finally, two dictionaries:</p>
<dl class="docutils">
<dt><em>feature</em></dt>
<dd>All feature values, keyed by annotation space, annotation label, feature name, kind (node or edge),
and finally reference (id of target node or edge).
The values are stored as integer. The mapping to the real value is stored separately.</dd>
<dt><em>feature_val_int</em></dt>
<dd>Mapping from real feature values to integer codes. Same values go to same codes, hence space is conserved.
These mappings are set up per individual feature.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">We work with annotation spaces and annotation labels and we distinguish between features in
annotations that are targeted at nodes or at edges.
Features for nodes and features for edges occupy separate name spaces.</p>
</div>
<dl class="method">
<dt id="graf.parse.AnnotationHandler.add_feature_instance">
<tt class="descname">add_feature_instance</tt><big>(</big><em>fname</em>, <em>value</em><big>)</big><a class="reference internal" href="../_modules/graf/parse.html#AnnotationHandler.add_feature_instance"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.parse.AnnotationHandler.add_feature_instance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="graf.parse.AnnotationHandler.aid">
<tt class="descname">aid</tt><em class="property"> = None</em><a class="headerlink" href="#graf.parse.AnnotationHandler.aid" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="graf.parse.AnnotationHandler.characters">
<tt class="descname">characters</tt><big>(</big><em>ch</em><big>)</big><a class="reference internal" href="../_modules/graf/parse.html#AnnotationHandler.characters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.parse.AnnotationHandler.characters" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="graf.parse.AnnotationHandler.endElement">
<tt class="descname">endElement</tt><big>(</big><em>name</em><big>)</big><a class="reference internal" href="../_modules/graf/parse.html#AnnotationHandler.endElement"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.parse.AnnotationHandler.endElement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="graf.parse.AnnotationHandler.file_name">
<tt class="descname">file_name</tt><em class="property"> = None</em><a class="headerlink" href="#graf.parse.AnnotationHandler.file_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="graf.parse.AnnotationHandler.nid">
<tt class="descname">nid</tt><em class="property"> = None</em><a class="headerlink" href="#graf.parse.AnnotationHandler.nid" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="graf.parse.AnnotationHandler.stamp">
<tt class="descname">stamp</tt><em class="property"> = None</em><a class="headerlink" href="#graf.parse.AnnotationHandler.stamp" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="graf.parse.AnnotationHandler.startElement">
<tt class="descname">startElement</tt><big>(</big><em>name</em>, <em>attrs</em><big>)</big><a class="reference internal" href="../_modules/graf/parse.html#AnnotationHandler.startElement"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.parse.AnnotationHandler.startElement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="graf.parse.AnnotationHandler.truth">
<tt class="descname">truth</tt><em class="property"> = {'yes': True, 'true': True, 'on': True, '1': True}</em><a class="headerlink" href="#graf.parse.AnnotationHandler.truth" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="graf.parse.HeaderHandler">
<em class="property">class </em><tt class="descname">HeaderHandler</tt><big>(</big><em>stamp</em><big>)</big><a class="reference internal" href="../_modules/graf/parse.html#HeaderHandler"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.parse.HeaderHandler" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="http://docs.python.org/3.3/library/xml.sax.handler.html#xml.sax.handler.ContentHandler" title="(in Python v3.3)"><tt class="xref py py-class docutils literal"><span class="pre">xml.sax.handler.ContentHandler</span></tt></a></p>
<p>Handlers used by SAX parsing the GrAF header file.</p>
<p>We just collect the contents of the <em>loc</em> attributes of the <em>annotation</em> elements.
These are the annotation files that we have to fetch and compile.</p>
<dl class="method">
<dt id="graf.parse.HeaderHandler.characters">
<tt class="descname">characters</tt><big>(</big><em>ch</em><big>)</big><a class="reference internal" href="../_modules/graf/parse.html#HeaderHandler.characters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.parse.HeaderHandler.characters" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="graf.parse.HeaderHandler.endElement">
<tt class="descname">endElement</tt><big>(</big><em>name</em><big>)</big><a class="reference internal" href="../_modules/graf/parse.html#HeaderHandler.endElement"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.parse.HeaderHandler.endElement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="graf.parse.HeaderHandler.stamp">
<tt class="descname">stamp</tt><em class="property"> = None</em><a class="headerlink" href="#graf.parse.HeaderHandler.stamp" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="graf.parse.HeaderHandler.startElement">
<tt class="descname">startElement</tt><big>(</big><em>name</em>, <em>attrs</em><big>)</big><a class="reference internal" href="../_modules/graf/parse.html#HeaderHandler.startElement"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.parse.HeaderHandler.startElement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="graf.parse.parse">
<tt class="descname">parse</tt><big>(</big><em>graf_header_file</em>, <em>stamp</em><big>)</big><a class="reference internal" href="../_modules/graf/parse.html#parse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.parse.parse" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse a GrAF resource.</p>
<p>Parses a GrAF resource, starting by SAX parsing its header file and subsequently parsing all
files mentioned in that header file.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>graf_header_file (str):</dt>
<dd>path to the GrAF header file</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>a tuple of items which comprise the parse results.</dd>
</dl>
<p>Every member of the returned tuple is itself a tuple of 3 pieces of information:</p>
<ol class="arabic simple">
<li>A <em>key</em> which acts as a name for this part of the result data</li>
<li>The data itself, as described in <a class="reference internal" href="#graf.parse.AnnotationHandler" title="graf.parse.AnnotationHandler"><tt class="xref py py-class docutils literal"><span class="pre">AnnotationHandler</span></tt></a></li>
<li>A boolean indicating whether this data is a temporary result or a permanent result</li>
</ol>
<p>Temporary results will be discarded after the remodeling step, permanent results will be incorporated in 
the task-executing object.</p>
</dd></dl>

</div>
<div class="section" id="module-graf.shell">
<span id="graf-shell-module"></span><h2>graf.shell module<a class="headerlink" href="#module-graf.shell" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="graf.shell.Shell">
<em class="property">class </em><tt class="descname">Shell</tt><a class="reference internal" href="../_modules/graf/shell.html#Shell"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.shell.Shell" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">builtins.object</span></tt></p>
<p>Execute tasks, either in a single run, or with an interactive prompt.</p>
<p>This class knows about the environment, such as command line arguments
and configuration files. 
It collects those information pieces and passes them in suitable form
to the factual task processor.</p>
<p>Upon creation, create a <a class="reference internal" href="#graf.task.GrafTask" title="graf.task.GrafTask"><tt class="xref py py-class docutils literal"><span class="pre">GrafTask</span></tt></a> object based on settings.</p>
<dl class="method">
<dt id="graf.shell.Shell.command_loop">
<tt class="descname">command_loop</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/graf/shell.html#Shell.command_loop"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.shell.Shell.command_loop" title="Permalink to this definition">¶</a></dt>
<dd><p>Command prompt for repeated running of tasks.</p>
</dd></dl>

<dl class="attribute">
<dt id="graf.shell.Shell.cur">
<tt class="descname">cur</tt><em class="property"> = None</em><a class="headerlink" href="#graf.shell.Shell.cur" title="Permalink to this definition">¶</a></dt>
<dd><p>Holds the current selection: the <em>source</em>, the <em>annox</em>, the <em>task</em> and the <em>force_compile</em> option, in that order.</p>
</dd></dl>

<dl class="attribute">
<dt id="graf.shell.Shell.default">
<tt class="descname">default</tt><em class="property"> = None</em><a class="headerlink" href="#graf.shell.Shell.default" title="Permalink to this definition">¶</a></dt>
<dd><p>Defaults for the selectable items: <em>source</em>, <em>annox</em> and <em>task</em>.
If the user does not pass values for them both on the command lines, these ones are used.
If the user does pass some of these values and the command prompt is started, the
command line values are parsed here, and the command prompt will use them as initial values.</p>
</dd></dl>

<dl class="method">
<dt id="graf.shell.Shell.do_command">
<tt class="descname">do_command</tt><big>(</big><em>prompt</em>, <em>choices</em>, <em>helpstr</em><big>)</big><a class="reference internal" href="../_modules/graf/shell.html#Shell.do_command"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.shell.Shell.do_command" title="Permalink to this definition">¶</a></dt>
<dd><p>Prompts the user to enter a command and dispatches it, if correct.</p>
<p>This method asks the user for a command consisting of a single letter.
It checks whether the letter is a legal option.
It add options for quitting (Esc) and displaying help (?).
If he user enters <tt class="docutils literal"><span class="pre">?</span></tt>, the helpstring is displayed.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>prompt (str):</dt>
<dd>the prompt string to be displayed. This string will be extended with a description of the allowed keys to press.</dd>
<dt>choices (str):</dt>
<dd>a string consisting of legal  one letter commands, not separated.</dd>
<dt>helpstr (str):</dt>
<dd>help string to be displayed if the user presses <tt class="docutils literal"><span class="pre">?</span></tt></dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>command (str):</dt>
<dd>the command entered by the user, or <tt class="docutils literal"><span class="pre">None</span></tt> if escape has been pressed.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="graf.shell.Shell.get_ch">
<tt class="descname">get_ch</tt><big>(</big><em>prompt=''</em><big>)</big><a class="reference internal" href="../_modules/graf/shell.html#Shell.get_ch"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.shell.Shell.get_ch" title="Permalink to this definition">¶</a></dt>
<dd><p>Asks for unbuffered single character input, with an optional prompt.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>prompt (str):</dt>
<dd>Optional text to be displayed as prompt.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>ch (char):</dt>
<dd>character pressed by the user. If something gets wrong, returns the <em>Esc</em> character.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="graf.shell.Shell.get_num">
<tt class="descname">get_num</tt><big>(</big><em>prompt</em>, <em>start</em>, <em>end</em><big>)</big><a class="reference internal" href="../_modules/graf/shell.html#Shell.get_num"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.shell.Shell.get_num" title="Permalink to this definition">¶</a></dt>
<dd><p>Asks for a numeric value, and checks whether teh value is in a legal range.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>prompt (str):</dt>
<dd>prompt to be displayed</dd>
<dt>start (str):</dt>
<dd>minimum legal value</dd>
<dt>end (str):</dt>
<dd>maximum legal value</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>number (int):</dt>
<dd>the number if the user entered something legal, and <tt class="docutils literal"><span class="pre">None</span></tt> otherwise.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="graf.shell.Shell.main_command">
<tt class="descname">main_command</tt><big>(</big><em>command</em><big>)</big><a class="reference internal" href="../_modules/graf/shell.html#Shell.main_command"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.shell.Shell.main_command" title="Permalink to this definition">¶</a></dt>
<dd><p>Interprets a top level command.</p>
<p>Depending on the command passed, this methods prompts for additional information.
This happens for the commands that modify the source and task selection.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>command(char):</dt>
<dd>the command character.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>message (str):</dt>
<dd>response text after the command execution.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="graf.shell.Shell.message">
<tt class="descname">message</tt><em class="property"> = None</em><a class="headerlink" href="#graf.shell.Shell.message" title="Permalink to this definition">¶</a></dt>
<dd><p>Response messages to be displayed after the prompt</p>
</dd></dl>

<dl class="method">
<dt id="graf.shell.Shell.processor">
<tt class="descname">processor</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/graf/shell.html#Shell.processor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.shell.Shell.processor" title="Permalink to this definition">¶</a></dt>
<dd><p>Does work. Decides to run one task or start the command prompt.</p>
<p>The decision is based on the presence of command line arguments.
If all arguments are present to specify a task, the <em>run once</em> option will be chosen,
unless the user has explicitly stated <tt class="docutils literal"><span class="pre">--menu</span></tt>.
Otherwise the command prompt is started. If that is the case, the
command line args that did come through, are used as initial values.</p>
</dd></dl>

<dl class="method">
<dt id="graf.shell.Shell.prompt">
<tt class="descname">prompt</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/graf/shell.html#Shell.prompt"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.shell.Shell.prompt" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes an self-explanatory prompt text to the terminal.</p>
</dd></dl>

<dl class="method">
<dt id="graf.shell.Shell.weave">
<tt class="descname">weave</tt><big>(</big><em>data</em><big>)</big><a class="reference internal" href="../_modules/graf/shell.html#Shell.weave"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.shell.Shell.weave" title="Permalink to this definition">¶</a></dt>
<dd><p>Utility value that prepares data for presenting several columns of options
on a terminal screen.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>data(lists of lists):</dt>
<dd>corresponds to a number of lists of options.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>woven(list of lists):</dt>
<dd>correponds to a table where columns are the lists of options
and the options occupy rows. The outermost list are the rows.</dd>
<dt>index(dict of dict):</dt>
<dd>given column number and then row number as keys yields the name of the item at that slot</dd>
<dt>iindex(dict of dict):</dt>
<dd>given column number and then the name of an item as keys yields the 
row number of that item</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-graf.task">
<span id="graf-task-module"></span><h2>graf.task module<a class="headerlink" href="#module-graf.task" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="graf.task.Feature">
<em class="property">class </em><tt class="descname">Feature</tt><big>(</big><em>graftask</em>, <em>aspace</em>, <em>alabel</em>, <em>fname</em>, <em>kind</em><big>)</big><a class="reference internal" href="../_modules/graf/task.html#Feature"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.task.Feature" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">builtins.object</span></tt></p>
<p>This class is responsible for making the information in a single feature accessible to 
tasks.</p>
<p>It has a reference to the underlying information of the feature, it stores its <em>kind</em>
(node or edge) in two ways, as strings (<tt class="docutils literal"><span class="pre">node</span></tt> or <tt class="docutils literal"><span class="pre">edge</span></tt>) or as booleans (<tt class="docutils literal"><span class="pre">True</span></tt>, <tt class="docutils literal"><span class="pre">False</span></tt>).</p>
<p>It also gives a feature a fully qualified name that can act as an identifier.
In fact, these names will be used as member names of the <a class="reference internal" href="#graf.task.Features" title="graf.task.Features"><tt class="xref py py-class docutils literal"><span class="pre">Features</span></tt></a> class, when its objects
store sets of features.</p>
<p>Feature lookups deliver integer codes for values. There are methods to get the real values back.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">There is no global mapping of all feature values to integers and back.
Mappings are strictly per individual feature.
In this way we miss some data compression, but we keep the feature information better separable,
which is relevant because we only want to load features when a task asks for it.</p>
</div>
<p>Upon creation, makes references to the feature data corresponding to the feature specified.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>graftask(<a class="reference internal" href="#graf.task.GrafTask" title="graf.task.GrafTask"><tt class="xref py py-class docutils literal"><span class="pre">GrafTask</span></tt></a>):</dt>
<dd>The task executing object that has all the data.</dd>
<dt>aspace, alabel, fname, kind:</dt>
<dd>The annotation space, annotation label, feature name, feature kind (node or edge)
that together identify a single feature.</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="graf.task.Feature.i">
<tt class="descname">i</tt><big>(</big><em>value_rep</em><big>)</big><a class="reference internal" href="../_modules/graf/task.html#Feature.i"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.task.Feature.i" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the integer code corresponding to an real feature value.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>value_rep (str):</dt>
<dd>an value string for this feature</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>the integer code that assigned to it according to the
table of values of this individual feature.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="graf.task.Feature.r">
<tt class="descname">r</tt><big>(</big><em>value_int</em><big>)</big><a class="reference internal" href="../_modules/graf/task.html#Feature.r"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.task.Feature.r" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the real value corresponding to an integer.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>value_int (int):</dt>
<dd>an integer code for a value of this feature</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>the real value that the integer stands for according to the
table of values of this individual feature.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="graf.task.Feature.v">
<tt class="descname">v</tt><big>(</big><em>ne</em><big>)</big><a class="reference internal" href="../_modules/graf/task.html#Feature.v"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.task.Feature.v" title="Permalink to this definition">¶</a></dt>
<dd><p>Look the feature value up for a node or edge.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>ne (int):</dt>
<dd>node or edge, identified by an integer.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>the value of this feature for that node or edge, represented as integer.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="graf.task.Feature.vr">
<tt class="descname">vr</tt><big>(</big><em>ne</em><big>)</big><a class="reference internal" href="../_modules/graf/task.html#Feature.vr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.task.Feature.vr" title="Permalink to this definition">¶</a></dt>
<dd><p>Look the feature <em>real</em> value up for a node or edge.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>ne (int):</dt>
<dd>node or edge, identified by an integer.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>the value of this feature for that node or edge, represented as its real value in the LAF source.</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="graf.task.Features">
<em class="property">class </em><tt class="descname">Features</tt><big>(</big><em>feature_objects</em><big>)</big><a class="reference internal" href="../_modules/graf/task.html#Features"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.task.Features" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">builtins.object</span></tt></p>
<p>This class is responsible for holding a bunch of features and makes them 
accessible by member names.</p>
<p>Upon creation, a set of features is taken in,
their <em>local_name</em> members are used to create
member names in this class.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>feature_objects (iterable of <a class="reference internal" href="#graf.task.Feature" title="graf.task.Feature"><tt class="xref py py-class docutils literal"><span class="pre">Feature</span></tt></a>)</dd>
</dl>
</dd></dl>

<dl class="class">
<dt id="graf.task.GrafTask">
<em class="property">class </em><tt class="descname">GrafTask</tt><big>(</big><em>settings</em><big>)</big><a class="reference internal" href="../_modules/graf/task.html#GrafTask"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.task.GrafTask" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#graf.graf.Graf" title="graf.graf.Graf"><tt class="xref py py-class docutils literal"><span class="pre">graf.graf.Graf</span></tt></a></p>
<p>Task processor.</p>
<p>This class is responsible for running user tasks.
It will import a user task, read directives for data pre-loading, and it will generate an
API for the task, in the form of data structures for nodes and edges and 
objects that can do feature lookups.</p>
<p>A task processor must know where the source data is and where the result is going to.
And it must be able to <em>import</em>: and <a class="reference external" href="http://docs.python.org/3.3/library/imp.html#imp.reload" title="(in Python v3.3)"><tt class="xref py py-func docutils literal"><span class="pre">imp.reload()</span></tt></a>: the tasks.
To that end the search path for modules will be adapted according to the <em>task_dir</em> setting
in the main configuration file.</p>
<p>Upon creation, the configuration settings are stored in the object as is.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>settings (<a class="reference external" href="http://docs.python.org/3.3/library/configparser.html#configparser.ConfigParser" title="(in Python v3.3)"><tt class="xref py py-class docutils literal"><span class="pre">configparser.ConfigParser</span></tt></a>):</dt>
<dd>entries corresponding to the main configuration file</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="graf.task.GrafTask.add_result">
<tt class="descname">add_result</tt><big>(</big><em>file_name</em><big>)</big><a class="reference internal" href="../_modules/graf/task.html#GrafTask.add_result"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.task.GrafTask.add_result" title="Permalink to this definition">¶</a></dt>
<dd><p>Opens a file for writing and stores the handle.</p>
<p>Every task is advised to use this method for opening files for its output.
The file will be closed by the workbench when the task terminates.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>file_name (str):</dt>
<dd>name of the output file.
Its location is the result directory for this task and this source.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>A handle to the opened file.</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="graf.task.GrafTask.annox_changed">
<tt class="descname">annox_changed</tt><em class="property"> = None</em><a class="headerlink" href="#graf.task.GrafTask.annox_changed" title="Permalink to this definition">¶</a></dt>
<dd><p>Instance member to tell whether the annox name has changed</p>
</dd></dl>

<dl class="method">
<dt id="graf.task.GrafTask.compile">
<tt class="descname">compile</tt><big>(</big><em>force_compile</em><big>)</big><a class="reference internal" href="../_modules/graf/task.html#GrafTask.compile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.task.GrafTask.compile" title="Permalink to this definition">¶</a></dt>
<dd><p>Compile the LAF resource if needed or if forced.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>force_compile (bool):</dt>
<dd>whether to force compiling even if the need for it has not been detected.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="graf.task.GrafTask.finish_task">
<tt class="descname">finish_task</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/graf/task.html#GrafTask.finish_task"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.task.GrafTask.finish_task" title="Permalink to this definition">¶</a></dt>
<dd><p>Finalizes the current task.</p>
<p>Open result files will be closed.</p>
<p>There will be a progress message, and a directory listing of the result directory,
for the convenience of the user.</p>
</dd></dl>

<dl class="method">
<dt id="graf.task.GrafTask.get_mappings">
<tt class="descname">get_mappings</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/graf/task.html#GrafTask.get_mappings"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.task.GrafTask.get_mappings" title="Permalink to this definition">¶</a></dt>
<dd><p>Return references to API data structures and methods of this class.</p>
<p>This is what is returned (the names given are not necessarily the names by which they are used
in end user tasks. You can give convenient, local names to these methods, e.g:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="p">(</span><span class="n">msg</span><span class="p">,</span> <span class="n">NN</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span> <span class="o">=</span> <span class="n">graftask</span><span class="o">.</span><span class="n">get_mappings</span><span class="p">()</span>
</pre></div>
</div>
<p>Using these names, here is the API specification:</p>
<dl class="docutils">
<dt>msg(text, newline=True, withtime=True):</dt>
<dd>For delivering console output, such as progress messages.
See <a class="reference internal" href="#graf.timestamp.Timestamp.progress" title="graf.timestamp.Timestamp.progress"><tt class="xref py py-meth docutils literal"><span class="pre">progress</span></tt></a>.</dd>
<dt>NN(test=function, value=something):</dt>
<dd><p class="first">An iterator that delivers nodes in the canonical order described in <a class="reference internal" href="#graf.model.model" title="graf.model.model"><tt class="xref py py-func docutils literal"><span class="pre">model</span></tt></a>.</p>
<p class="last"><em>test</em> must be a callable with one argument of type integer. Only nodes for which <em>test</em> delivers <em>something</em>
are passed through, all others are skipped.</p>
</dd>
<dt>F(<a class="reference internal" href="#graf.task.Features" title="graf.task.Features"><tt class="xref py py-class docutils literal"><span class="pre">Features</span></tt></a>):</dt>
<dd>Object containing all features declared in the task as a member. For example, the feature <tt class="docutils literal"><span class="pre">shebanq:ft.suffix</span></tt> is
accessible as <tt class="docutils literal"><span class="pre">F.shebanq_ft_suffix</span></tt> if it isa node feature, or <tt class="docutils literal"><span class="pre">F.shebanq_ft_suffix_e</span></tt> if it is an edge feature.
These feature objects in turn have methods to look features up and to translate between internal codes for the values
and the real values as encountered in the source. See <a class="reference internal" href="#graf.task.Feature" title="graf.task.Feature"><tt class="xref py py-class docutils literal"><span class="pre">Feature</span></tt></a>.</dd>
<dt>X(<a class="reference internal" href="#graf.task.XMLids" title="graf.task.XMLids"><tt class="xref py py-class docutils literal"><span class="pre">XMLids</span></tt></a>):</dt>
<dd>Object containg members for XML identifier mappings for nodes and or edges, depending on what the task
has specified. <tt class="docutils literal"><span class="pre">X.node</span></tt> contains mappings for nodes, <tt class="docutils literal"><span class="pre">X.edge</span></tt> for edges. These objects in turn have methods to 
perform the mappings in individual cases. See <a class="reference internal" href="#graf.task.XMLid" title="graf.task.XMLid"><tt class="xref py py-class docutils literal"><span class="pre">XMLid</span></tt></a>.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="graf.task.GrafTask.get_task_mtime">
<tt class="descname">get_task_mtime</tt><big>(</big><em>task</em><big>)</big><a class="reference internal" href="../_modules/graf/task.html#GrafTask.get_task_mtime"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.task.GrafTask.get_task_mtime" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the last modification date of the file that contains the task code</p>
</dd></dl>

<dl class="method">
<dt id="graf.task.GrafTask.getitems">
<tt class="descname">getitems</tt><big>(</big><em>data</em>, <em>data_items</em>, <em>elem</em><big>)</big><a class="reference internal" href="../_modules/graf/task.html#GrafTask.getitems"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.task.GrafTask.getitems" title="Permalink to this definition">¶</a></dt>
<dd><p>Get related items from an arrayified data structure.</p>
<p>If a relation between integers and sets of integers has been stored as a double array
by the <a class="reference internal" href="#graf.model.arrayify" title="graf.model.arrayify"><tt class="xref py py-func docutils literal"><span class="pre">arrayify()</span></tt></a> function,
this is the way to look up the set of related integers for each integer.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>data (array):</dt>
<dd>see next</dd>
<dt>data_items (array):</dt>
<dd>together with <em>data</em> the arrayified data</dd>
<dt>elem (int):</dt>
<dd>the integer for which we want its related set of integers.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>a list of the related integers.</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="graf.task.GrafTask.has_compiled">
<tt class="descname">has_compiled</tt><em class="property"> = None</em><a class="headerlink" href="#graf.task.GrafTask.has_compiled" title="Permalink to this definition">¶</a></dt>
<dd><p>Instance member to tell whether compilation has actually taken place</p>
</dd></dl>

<dl class="method">
<dt id="graf.task.GrafTask.hasitem">
<tt class="descname">hasitem</tt><big>(</big><em>data</em>, <em>data_items</em>, <em>elem</em>, <em>item</em><big>)</big><a class="reference internal" href="../_modules/graf/task.html#GrafTask.hasitem"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.task.GrafTask.hasitem" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether an integer is in the set of related items
with respect to an arrayified data structure (see also <a class="reference internal" href="#graf.task.GrafTask.getitems" title="graf.task.GrafTask.getitems"><tt class="xref py py-meth docutils literal"><span class="pre">getitems()</span></tt></a>).</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>data (array):</dt>
<dd>see next</dd>
<dt>data_items (array):</dt>
<dd>together with <em>data</em> the arrayified data</dd>
<dt>elem (int):</dt>
<dd>the integer for which we want its related set of integers.</dd>
<dt>item (int):</dt>
<dd>the integer whose presence in the related items set is to be tested.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>bool: whether the integer is in the related set or not.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="graf.task.GrafTask.hasitems">
<tt class="descname">hasitems</tt><big>(</big><em>data</em>, <em>data_items</em>, <em>elem</em>, <em>items</em><big>)</big><a class="reference internal" href="../_modules/graf/task.html#GrafTask.hasitems"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.task.GrafTask.hasitems" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether a set of integers intersects with the set of related items
with respect to an arrayified data structure (see also <a class="reference internal" href="#graf.task.GrafTask.getitems" title="graf.task.GrafTask.getitems"><tt class="xref py py-meth docutils literal"><span class="pre">getitems()</span></tt></a>).</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>data (array):</dt>
<dd>see next</dd>
<dt>data_items (array):</dt>
<dd>together with <em>data</em> the arrayified data</dd>
<dt>elem (int):</dt>
<dd>the integer for which we want its related set of integers.</dd>
<dt>items (array or list of integers):</dt>
<dd>the set of integers
whose presence in the related items set is to be tested.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>bool:</dt>
<dd>whether one of the integers is in the related set or not.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="graf.task.GrafTask.init_task">
<tt class="descname">init_task</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/graf/task.html#GrafTask.init_task"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.task.GrafTask.init_task" title="Permalink to this definition">¶</a></dt>
<dd><p>Initializes the current task.</p>
<p>Provide a log file, reset the timer, and issue a progress message.</p>
</dd></dl>

<dl class="attribute">
<dt id="graf.task.GrafTask.loaded">
<tt class="descname">loaded</tt><em class="property"> = None</em><a class="headerlink" href="#graf.task.GrafTask.loaded" title="Permalink to this definition">¶</a></dt>
<dd><p>Set of feature data sets that have been loaded, node features and edge features under different keys</p>
</dd></dl>

<dl class="attribute">
<dt id="graf.task.GrafTask.prev_tasks">
<tt class="descname">prev_tasks</tt><em class="property"> = None</em><a class="headerlink" href="#graf.task.GrafTask.prev_tasks" title="Permalink to this definition">¶</a></dt>
<dd><p>List of tasks executed in this run of the workbench, with the modification time of the task program file
at the time it was last run</p>
</dd></dl>

<dl class="attribute">
<dt id="graf.task.GrafTask.result_files">
<tt class="descname">result_files</tt><em class="property"> = None</em><a class="headerlink" href="#graf.task.GrafTask.result_files" title="Permalink to this definition">¶</a></dt>
<dd><p>List of handles to result files created by the task through the method <a class="reference internal" href="#graf.task.GrafTask.add_result" title="graf.task.GrafTask.add_result"><tt class="xref py py-meth docutils literal"><span class="pre">add_result()</span></tt></a></p>
</dd></dl>

<dl class="method">
<dt id="graf.task.GrafTask.run">
<tt class="descname">run</tt><big>(</big><em>source</em>, <em>annox</em>, <em>task</em>, <em>force_compile=False</em><big>)</big><a class="reference internal" href="../_modules/graf/task.html#GrafTask.run"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.task.GrafTask.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Run a task.</p>
<p>That is:
* Load the data
* (Re)load the task code
* Initialize the task
* Run the task code
* Finalize the task</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>source (str):</dt>
<dd>key for the source</dd>
<dt>annox (str):</dt>
<dd>name of the extra annotation package</dd>
<dt>task:</dt>
<dd>the chosen task</dd>
<dt>force_compile (bool):</dt>
<dd>whether to force (re)compilation of the LAF source</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="graf.task.GrafTask.settings">
<tt class="descname">settings</tt><em class="property"> = None</em><a class="headerlink" href="#graf.task.GrafTask.settings" title="Permalink to this definition">¶</a></dt>
<dd><p>Instance member to hold configuration settings</p>
</dd></dl>

<dl class="attribute">
<dt id="graf.task.GrafTask.source_changed">
<tt class="descname">source_changed</tt><em class="property"> = None</em><a class="headerlink" href="#graf.task.GrafTask.source_changed" title="Permalink to this definition">¶</a></dt>
<dd><p>Instance member to tell whether the source name has changed</p>
</dd></dl>

<dl class="attribute">
<dt id="graf.task.GrafTask.task_changed">
<tt class="descname">task_changed</tt><em class="property"> = None</em><a class="headerlink" href="#graf.task.GrafTask.task_changed" title="Permalink to this definition">¶</a></dt>
<dd><p>Instance member to tell whether the task name has changed</p>
</dd></dl>

<dl class="attribute">
<dt id="graf.task.GrafTask.xloaded">
<tt class="descname">xloaded</tt><em class="property"> = None</em><a class="headerlink" href="#graf.task.GrafTask.xloaded" title="Permalink to this definition">¶</a></dt>
<dd><p>Set of xmlid data sets that have been loaded, keys for <tt class="docutils literal"><span class="pre">node</span></tt> and <tt class="docutils literal"><span class="pre">edge</span></tt>.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="graf.task.XMLid">
<em class="property">class </em><tt class="descname">XMLid</tt><big>(</big><em>graftask</em>, <em>kind</em><big>)</big><a class="reference internal" href="../_modules/graf/task.html#XMLid"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.task.XMLid" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">builtins.object</span></tt></p>
<p>This class is responsible for making the original XML identifiers available
to tasks.</p>
<p>It has a reference to the relevant tables organized by <em>kind</em>
(node or edge). There are methods to map and inverse map.</p>
<p>Upon creation, makes a reference to the XMLid data corresponding to the kind specified.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>graftask(<a class="reference internal" href="#graf.task.GrafTask" title="graf.task.GrafTask"><tt class="xref py py-class docutils literal"><span class="pre">GrafTask</span></tt></a>):</dt>
<dd>The task executing object that has all the data.</dd>
<dt>kind:</dt>
<dd>The kind (node or edge)
for which to make available the identifiers.</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="graf.task.XMLid.i">
<tt class="descname">i</tt><big>(</big><em>xml_id</em><big>)</big><a class="reference internal" href="../_modules/graf/task.html#XMLid.i"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.task.XMLid.i" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the integer code of an XML identifier.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>xml_id (int):</dt>
<dd>an XML identifier in the LAF source</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>the integer code of the XML identifier</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="graf.task.XMLid.r">
<tt class="descname">r</tt><big>(</big><em>int_code</em><big>)</big><a class="reference internal" href="../_modules/graf/task.html#XMLid.r"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.task.XMLid.r" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the XML identifier corresponding to an integer.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>int_code (int):</dt>
<dd>an integer code for an XML identifier in the LAF source</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>the XML identifier that the integer stands for</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="graf.task.XMLids">
<em class="property">class </em><tt class="descname">XMLids</tt><big>(</big><em>xmlid_objects</em><big>)</big><a class="reference internal" href="../_modules/graf/task.html#XMLids"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.task.XMLids" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">builtins.object</span></tt></p>
<p>This class is responsible for holding a bunch of XML mappings (node and or edge) and makes them 
accessible by member names.</p>
<p>Upon creation, a set of xmlid objects (node and or edge) is taken in,</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>xmlid_objects (iterable of <a class="reference internal" href="#graf.task.XMLid" title="graf.task.XMLid"><tt class="xref py py-class docutils literal"><span class="pre">XMLid</span></tt></a>)</dd>
</dl>
</dd></dl>

</div>
<div class="section" id="module-graf.timestamp">
<span id="graf-timestamp-module"></span><h2>graf.timestamp module<a class="headerlink" href="#module-graf.timestamp" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="graf.timestamp.Timestamp">
<em class="property">class </em><tt class="descname">Timestamp</tt><big>(</big><em>log_file=None</em><big>)</big><a class="reference internal" href="../_modules/graf/timestamp.html#Timestamp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.timestamp.Timestamp" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">builtins.object</span></tt></p>
<p>Time management.</p>
<p>Objects remember their creation time. So they can issue statements about how much time has been elapsed.
All timed log messages of the program should be issued through the <a class="reference internal" href="#graf.timestamp.Timestamp.progress" title="graf.timestamp.Timestamp.progress"><tt class="xref py py-meth docutils literal"><span class="pre">progress()</span></tt></a> method of this class.</p>
<p>It is also possible to connect a logfile to these objects.
When progress messages are issued, they are also written to the connected log file.</p>
<p>Upon creation, retrieves the time.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>log_file (file):</dt>
<dd>open file handle for writing. Optional. If not <tt class="docutils literal"><span class="pre">None</span></tt> stores the handle in the object&#8217;s data.</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="graf.timestamp.Timestamp.connect_log">
<tt class="descname">connect_log</tt><big>(</big><em>log_file</em><big>)</big><a class="reference internal" href="../_modules/graf/timestamp.html#Timestamp.connect_log"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.timestamp.Timestamp.connect_log" title="Permalink to this definition">¶</a></dt>
<dd><p>Connects a log file to the object.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>log_file (file):</dt>
<dd>open handle for writing.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="graf.timestamp.Timestamp.disconnect_log">
<tt class="descname">disconnect_log</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/graf/timestamp.html#Timestamp.disconnect_log"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.timestamp.Timestamp.disconnect_log" title="Permalink to this definition">¶</a></dt>
<dd><p>Connects a log file to the object.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>log_file (file):</dt>
<dd>open handle for writing.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="graf.timestamp.Timestamp.elapsed">
<tt class="descname">elapsed</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/graf/timestamp.html#Timestamp.elapsed"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.timestamp.Timestamp.elapsed" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the time elapsed since creation of the <a class="reference internal" href="#graf.timestamp.Timestamp" title="graf.timestamp.Timestamp"><tt class="xref py py-class docutils literal"><span class="pre">Timestamp</span></tt></a> object.</p>
<dl class="docutils">
<dt>Returns:</dt>
<dd>A pretty formatted string, ready to include in a message.</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="graf.timestamp.Timestamp.log">
<tt class="descname">log</tt><em class="property"> = None</em><a class="headerlink" href="#graf.timestamp.Timestamp.log" title="Permalink to this definition">¶</a></dt>
<dd><p>Instance member holding a handle to a logfile, open for writing, if a log file has been attached to the object.</p>
</dd></dl>

<dl class="method">
<dt id="graf.timestamp.Timestamp.progress">
<tt class="descname">progress</tt><big>(</big><em>msg</em>, <em>newline=True</em>, <em>withtime=True</em><big>)</big><a class="reference internal" href="../_modules/graf/timestamp.html#Timestamp.progress"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.timestamp.Timestamp.progress" title="Permalink to this definition">¶</a></dt>
<dd><p>API: issues a timed progress message.</p>
<p>The message is issued to the standard output, and, if a log file has been connected, also to the log file.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>msg (str):</dt>
<dd>text of the message</dd>
<dt>newline (bool):</dt>
<dd>whether or not to add a newline. Optional. Make it <tt class="docutils literal"><span class="pre">False</span></tt> to not add a newline.</dd>
<dt>withtime (bool):</dt>
<dd>whether to precede the text with timing information (time elapsed since the last reset of the
underlying <tt class="xref py py-class docutils literal"><span class="pre">graf.timestamp.Stamp</span></tt> object.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="graf.timestamp.Timestamp.reset">
<tt class="descname">reset</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/graf/timestamp.html#Timestamp.reset"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.timestamp.Timestamp.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the time to the current time</p>
</dd></dl>

<dl class="attribute">
<dt id="graf.timestamp.Timestamp.timestamp">
<tt class="descname">timestamp</tt><em class="property"> = None</em><a class="headerlink" href="#graf.timestamp.Timestamp.timestamp" title="Permalink to this definition">¶</a></dt>
<dd><p>Instance member holding the time the object was created</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-graf">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-graf" title="Permalink to this headline">¶</a></h2>
</div>
</div>


          <footer>
  
    <div class="rst-footer-buttons">
      
      
        <a href="modules.html" class="btn btn-neutral" title="graf"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <p>
      &copy; Copyright 2013, Dirk Roorda.
  </p>

  <a href="https://www.github.com/snide/sphinx_rtd_theme">Sphinx theme</a> provided by <a href="http://readthedocs.org">Read the Docs</a>
</footer>
        </div>
      </div>

    </section>

  </div>
  

</body>
</html>