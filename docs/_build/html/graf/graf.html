

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>graf package &mdash; LAF Fabric 1.0.1 documentation</title>
  

  
  

  
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  
  

    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:'../',
        VERSION:'1.0.1',
        COLLAPSE_INDEX:false,
        FILE_SUFFIX:'.html',
        HAS_SOURCE:  true
      };
    </script>
      <script type="text/javascript" src="../_static/jquery.js"></script>
      <script type="text/javascript" src="../_static/underscore.js"></script>
      <script type="text/javascript" src="../_static/doctools.js"></script>
      <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

    

  

  
  
    <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
    <link rel="top" title="LAF Fabric 1.0.1 documentation" href="../index.html"/>
        <link rel="up" title="graf" href="modules.html"/>
        <link rel="prev" title="graf" href="modules.html"/> 

  <script src="//cdnjs.cloudflare.com/ajax/libs/modernizr/2.6.2/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        <a href="../index.html" class="icon icon-home"> LAF Fabric</a>
        <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
  <input type="text" name="q" placeholder="Search docs" />
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix">
        
        
            <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../overview.html">LAF/GrAF and data analysis</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../overview.html#what-is-laf-graf">What is LAF/GrAF</a></li>
<li class="toctree-l2"><a class="reference internal" href="../overview.html#data">Data</a></li>
<li class="toctree-l2"><a class="reference internal" href="../overview.html#existing-tools-for-laf-graf-resources">Existing tools for LAF/GrAF resources</a></li>
<li class="toctree-l2"><a class="reference internal" href="../overview.html#this-workbench">This workbench</a></li>
<li class="toctree-l2"><a class="reference internal" href="../overview.html#rationale">Rationale</a></li>
<li class="toctree-l2"><a class="reference internal" href="../overview.html#author">Author</a></li>
<li class="toctree-l2"><a class="reference internal" href="../overview.html#links">Links</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../workbench.html">LAF workbench</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../workbench.html#what-is-this-workbench">What is this workbench?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workbench.html#license">License</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workbench.html#how-to-use-the-workbench">How to use the workbench?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workbench.html#designed-for-performance">Designed for Performance</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workbench.html#graf-feature-coverage">GrAF feature coverage</a></li>
<li class="toctree-l2"><a class="reference internal" href="../workbench.html#development">Development</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../taskwriting.html">Writing Tasks</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../taskwriting.html#what-is-a-task">What is a task?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../taskwriting.html#a-leading-example">A leading example</a></li>
<li class="toctree-l2"><a class="reference internal" href="../taskwriting.html#more-on-features">More on features</a></li>
<li class="toctree-l2"><a class="reference internal" href="../taskwriting.html#information-flow-from-task-to-workbench">Information flow from task to workbench</a></li>
<li class="toctree-l2"><a class="reference internal" href="../taskwriting.html#information-flow-from-workbench-to-task">Information flow from workbench to task</a></li>
<li class="toctree-l2"><a class="reference internal" href="../taskwriting.html#output">Output</a></li>
<li class="toctree-l2"><a class="reference internal" href="../taskwriting.html#node-order">Node order</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../tasks/modules.html">tasks</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../tasks/esther.html">esther module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tasks/gender.html">gender module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tasks/involved.html">involved module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tasks/isaiah.html">isaiah module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tasks/lingo.html">lingo module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tasks/objects.html">objects module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tasks/plain.html">plain module</a></li>
<li class="toctree-l2"><a class="reference internal" href="../tasks/proper.html">proper module</a></li>
</ul>
</li>
<li class="toctree-l1 current"><a class="reference internal" href="modules.html">graf</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="">graf package</a></li>
</ul>
</li>
</ul>

        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top">
        <i data-toggle="wy-nav-top" class="icon icon-reorder"></i>
        <a href="/">LAF Fabric</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <ul class="wy-breadcrumbs">
  <li><a href="../index.html">Docs</a> &raquo;</li>
  <li><a href="">graf package</a></li>
    <li class="wy-breadcrumbs-aside">
      
        <a href="../_sources/graf/graf.txt" rel="nofollow"> View page source</a>
      
    </li>
</ul>
<hr/>

          
  <div class="section" id="graf-package">
<h1>graf package<a class="headerlink" href="#graf-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-graf.compiler">
<span id="graf-compiler-module"></span><h2>graf.compiler module<a class="headerlink" href="#module-graf.compiler" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="graf.compiler.GrafCompiler">
<em class="property">class </em><tt class="descname">GrafCompiler</tt><big>(</big><em>env</em><big>)</big><a class="reference internal" href="../_modules/graf/compiler.html#GrafCompiler"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.compiler.GrafCompiler" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#graf.graf.Graf" title="graf.graf.Graf"><tt class="xref py py-class docutils literal"><span class="pre">graf.graf.Graf</span></tt></a></p>
<p>Takes care of the compilation of LAF xml data into binary data.</p>
<p>There are two stages in compilation:</p>
<ul class="simple">
<li>parsing the XML data by means of a SAX parser (a lengthy process)</li>
<li>remodeling the parse results in really tight data structures</li>
</ul>
<p>Upon creation, the relevant directories are communicated.</p>
<p>The initialization of the base class is performed, and we change working directory to the location of the LAF source.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd>env (str): path information</dd>
</dl>
<dl class="method">
<dt id="graf.compiler.GrafCompiler.compiler">
<tt class="descname">compiler</tt><big>(</big><em>force=False</em><big>)</big><a class="reference internal" href="../_modules/graf/compiler.html#GrafCompiler.compiler"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.compiler.GrafCompiler.compiler" title="Permalink to this definition">¶</a></dt>
<dd><p>Manages the complete compilation process.</p>
<p>Detects the need for compiling, responds to the <em>force</em> argument. Then parses, remodels and writes.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>force (bool):</dt>
<dd>whether to compile even if the binary data looks up to date.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="graf.compiler.GrafCompiler.env">
<tt class="descname">env</tt><em class="property"> = None</em><a class="headerlink" href="#graf.compiler.GrafCompiler.env" title="Permalink to this definition">¶</a></dt>
<dd><p>Instance member to hold config settings etc</p>
</dd></dl>

<dl class="attribute">
<dt id="graf.compiler.GrafCompiler.has_compiled">
<tt class="descname">has_compiled</tt><em class="property"> = None</em><a class="headerlink" href="#graf.compiler.GrafCompiler.has_compiled" title="Permalink to this definition">¶</a></dt>
<dd><p>Instance member to tell whether compilation has actually taken place</p>
</dd></dl>

<dl class="method">
<dt id="graf.compiler.GrafCompiler.model">
<tt class="descname">model</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/graf/compiler.html#GrafCompiler.model"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.compiler.GrafCompiler.model" title="Permalink to this definition">¶</a></dt>
<dd><p>Call the remodeler and store the remodeled data in the object.</p>
</dd></dl>

<dl class="method">
<dt id="graf.compiler.GrafCompiler.needs_compiling">
<tt class="descname">needs_compiling</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/graf/compiler.html#GrafCompiler.needs_compiling"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.compiler.GrafCompiler.needs_compiling" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks whether the compiled binary data is still up to date.</p>
<p>The criterion is whether the generated statistics file at the binary side is newer than the chosen GrAF header file.</p>
<dl class="docutils">
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>bool:</dt>
<dd>whether the criterion for compiling holds.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="graf.compiler.GrafCompiler.parse">
<tt class="descname">parse</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/graf/compiler.html#GrafCompiler.parse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.compiler.GrafCompiler.parse" title="Permalink to this definition">¶</a></dt>
<dd><p>Call the XML parser and collect the parse results.</p>
<p>Some parse results must be remodelled afterwards.
After remodelling some parse data can be thrown away.
Only store data that is needed for task execution in the object.</p>
<p>The actual parsing is done in the module <a class="reference internal" href="#module-graf.parse" title="graf.parse"><tt class="xref py py-mod docutils literal"><span class="pre">parse</span></tt></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="graf.compiler.GrafCompiler.temp_data_items">
<tt class="descname">temp_data_items</tt><em class="property"> = {}</em><a class="headerlink" href="#graf.compiler.GrafCompiler.temp_data_items" title="Permalink to this definition">¶</a></dt>
<dd><p>Holds some data delivered by the parsed that can be thrown away later. The data that we must keep is stored in the object, of course.</p>
</dd></dl>

<dl class="method">
<dt id="graf.compiler.GrafCompiler.write_data">
<tt class="descname">write_data</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/graf/compiler.html#GrafCompiler.write_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.compiler.GrafCompiler.write_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes compiled data to disk.</p>
<p>Compiled data has three possible types:</p>
<dl class="docutils">
<dt><em>0: plain array</em></dt>
<dd>can be written fast with the <tt class="xref py py-meth docutils literal"><span class="pre">array.tofile()</span></tt> method</dd>
<dt><em>1: array valued dict</em></dt>
<dd>a dictionary, keyed by a feature name and with arrays as values</dd>
<dt><em>2: list of trings</em></dt>
<dd>can be dumped with the <tt class="xref py py-meth docutils literal"><span class="pre">pickle.dump()</span></tt> method.</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-graf.graf">
<span id="graf-graf-module"></span><h2>graf.graf module<a class="headerlink" href="#module-graf.graf" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="graf.graf.Graf">
<em class="property">class </em><tt class="descname">Graf</tt><a class="reference internal" href="../_modules/graf/graf.html#Graf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.graf.Graf" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">builtins.object</span></tt></p>
<p>Base class for compiling LAF resources and running analytic tasks on them.</p>
<p>This class has only a rudimentary method set. Compiling a LAF resource is done by the GrafCompiler derived class
and running analytic tasks is done by the GrafTask class.</p>
<p>The data of this class represents the compiled data on the basis of which tasks can run.
This data is created by a <a class="reference internal" href="#graf.compiler.GrafCompiler" title="graf.compiler.GrafCompiler"><tt class="xref py py-class docutils literal"><span class="pre">GrafCompiler</span></tt></a> that derives from this class.</p>
<p>Upon creation, empty datastructures are initialized to hold the binary,
compiled LAF data and create a directory for their serializations on disk.</p>
<p>The Graf object holds information that Graf tasks need to perform their operations.
The most important piece of information is the data itself.
This data consists of arrays and dictionaries that together hold the information that is compiled from a LAF resource.</p>
<p>Other things that happen:</p>
<ol class="arabic simple">
<li>a fresh Timestamp object is created, which records the current time and can issue progress messages containing the amount
of time that has elapsed since this object has been created.</li>
<li>if the directory that should hold the compiled data does not exist,
a new directory is created Of course this means that before executing any tasks,
the LAF resource has to be (re)compiled.</li>
</ol>
<dl class="docutils">
<dt>Returns:</dt>
<dd>object with data structures initialized, ready to load the compiled data from disk.</dd>
</dl>
<dl class="attribute">
<dt id="graf.graf.Graf.BIN_EXT">
<tt class="descname">BIN_EXT</tt><em class="property"> = 'bin'</em><a class="headerlink" href="#graf.graf.Graf.BIN_EXT" title="Permalink to this definition">¶</a></dt>
<dd><p>extension for binary files</p>
</dd></dl>

<dl class="attribute">
<dt id="graf.graf.Graf.COMPILE_TASK">
<tt class="descname">COMPILE_TASK</tt><em class="property"> = 'compile'</em><a class="headerlink" href="#graf.graf.Graf.COMPILE_TASK" title="Permalink to this definition">¶</a></dt>
<dd><p>name of the compile task</p>
</dd></dl>

<dl class="attribute">
<dt id="graf.graf.Graf.LOG_NAME">
<tt class="descname">LOG_NAME</tt><em class="property"> = '__log__'</em><a class="headerlink" href="#graf.graf.Graf.LOG_NAME" title="Permalink to this definition">¶</a></dt>
<dd><p>log file base name for a task</p>
</dd></dl>

<dl class="attribute">
<dt id="graf.graf.Graf.STAT_NAME">
<tt class="descname">STAT_NAME</tt><em class="property"> = '__stat__'</em><a class="headerlink" href="#graf.graf.Graf.STAT_NAME" title="Permalink to this definition">¶</a></dt>
<dd><p>statistics file base name for a task</p>
</dd></dl>

<dl class="attribute">
<dt id="graf.graf.Graf.TEXT_EXT">
<tt class="descname">TEXT_EXT</tt><em class="property"> = 'txt'</em><a class="headerlink" href="#graf.graf.Graf.TEXT_EXT" title="Permalink to this definition">¶</a></dt>
<dd><p>extension for text files</p>
</dd></dl>

<dl class="method">
<dt id="graf.graf.Graf.add_logfile">
<tt class="descname">add_logfile</tt><big>(</big><em>location=None</em>, <em>name=None</em><big>)</big><a class="reference internal" href="../_modules/graf/graf.html#Graf.add_logfile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.graf.Graf.add_logfile" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and open a log file for a given task.</p>
<p>When tasks run, they generate progress messages with timing information in them.
They may issue errors and warnings. All this information also goes into a log file.
The log file is placed in the result directory of the task at hand.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>location (str):</dt>
<dd>override default directory for log file</dd>
<dt>name (str):</dt>
<dd>override default name for log file</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="graf.graf.Graf.data_items">
<tt class="descname">data_items</tt><em class="property"> = None</em><a class="headerlink" href="#graf.graf.Graf.data_items" title="Permalink to this definition">¶</a></dt>
<dd><p>Instance member holding the compiled data in the form of a dictionary of arrays and lists.</p>
<p>See the <a class="reference internal" href="#module-graf.compiler" title="graf.compiler"><tt class="xref py py-mod docutils literal"><span class="pre">compiler</span></tt></a> and <a class="reference internal" href="#module-graf.model" title="graf.model"><tt class="xref py py-mod docutils literal"><span class="pre">model</span></tt></a> modules for the way the compiled data is organised.</p>
</dd></dl>

<dl class="attribute">
<dt id="graf.graf.Graf.edge_feat">
<tt class="descname">edge_feat</tt><em class="property"> = None</em><a class="headerlink" href="#graf.graf.Graf.edge_feat" title="Permalink to this definition">¶</a></dt>
<dd><p>Feature data (for features on edges) stored in dictionary for fast access</p>
</dd></dl>

<dl class="attribute">
<dt id="graf.graf.Graf.env">
<tt class="descname">env</tt><em class="property"> = None</em><a class="headerlink" href="#graf.graf.Graf.env" title="Permalink to this definition">¶</a></dt>
<dd><p>Holds the environment parameters for the current task</p>
</dd></dl>

<dl class="method">
<dt id="graf.graf.Graf.finish_logfile">
<tt class="descname">finish_logfile</tt><big>(</big><big>)</big><a class="headerlink" href="#graf.graf.Graf.finish_logfile" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="graf.graf.Graf.flush_logfile">
<tt class="descname">flush_logfile</tt><big>(</big><big>)</big><a class="headerlink" href="#graf.graf.Graf.flush_logfile" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="graf.graf.Graf.init_data">
<tt class="descname">init_data</tt><big>(</big><em>feature=None</em>, <em>xmlids=None</em><big>)</big><a class="reference internal" href="../_modules/graf/graf.html#Graf.init_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.graf.Graf.init_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Resets all loaded data to initial values, or just the data of a single feature, or just the xmlids.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>feature (str, int):</dt>
<dd>the kind (<tt class="docutils literal"><span class="pre">node</span></tt> or <tt class="docutils literal"><span class="pre">edge</span></tt>) and qualified name of a feature.
Optional. If given, only the data for the
feature specified, will be reset.</dd>
<dt>xmlids (str):</dt>
<dd>the kind (<tt class="docutils literal"><span class="pre">node</span></tt> or <tt class="docutils literal"><span class="pre">edge</span></tt>).
Optional. If given, only the xmlids data for the
nodes or edges as specified, will be reset.</dd>
</dl>
</dd>
</dl>
<p>If none of the optional features is present, all data will be reset.</p>
<p>This is needed when the task processor switches from one source to another,
or when a recompile has been performed.</p>
</dd></dl>

<dl class="method">
<dt id="graf.graf.Graf.inv_label">
<tt class="descname">inv_label</tt><big>(</big><em>label</em><big>)</big><a class="headerlink" href="#graf.graf.Graf.inv_label" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a label ending in <tt class="docutils literal"><span class="pre">_int</span></tt>, returns the label with that <tt class="docutils literal"><span class="pre">_int</span></tt> replaced by <tt class="docutils literal"><span class="pre">_rep</span></tt>.</p>
<p>This will be the label of the inverse of the dictionary labeled by <em>label</em>.</p>
</dd></dl>

<dl class="attribute">
<dt id="graf.graf.Graf.log">
<tt class="descname">log</tt><em class="property"> = None</em><a class="headerlink" href="#graf.graf.Graf.log" title="Permalink to this definition">¶</a></dt>
<dd><p>handle of a log file, open for writing</p>
</dd></dl>

<dl class="attribute">
<dt id="graf.graf.Graf.node_feat">
<tt class="descname">node_feat</tt><em class="property"> = None</em><a class="headerlink" href="#graf.graf.Graf.node_feat" title="Permalink to this definition">¶</a></dt>
<dd><p>Feature data (for features on nodes) stored in dictionary for fast access</p>
</dd></dl>

<dl class="method">
<dt id="graf.graf.Graf.progress">
<tt class="descname">progress</tt><big>(</big><em>msg</em><big>)</big><a class="reference internal" href="../_modules/graf/graf.html#Graf.progress"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.graf.Graf.progress" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience method to call the progress of the associated stamp directly from the Graf object</p>
</dd></dl>

<dl class="method">
<dt id="graf.graf.Graf.read_stats">
<tt class="descname">read_stats</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/graf/graf.html#Graf.read_stats"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.graf.Graf.read_stats" title="Permalink to this definition">¶</a></dt>
<dd><p>Read compilation statistics from file</p>
<p>The compile process generates some statistics that must be read by the task that loads the compiled data.</p>
</dd></dl>

<dl class="method">
<dt id="graf.graf.Graf.set_environment">
<tt class="descname">set_environment</tt><big>(</big><em>source</em>, <em>annox</em>, <em>task</em><big>)</big><a class="reference internal" href="../_modules/graf/graf.html#Graf.set_environment"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.graf.Graf.set_environment" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the source and result locations for a task execution.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>source (str):</dt>
<dd>key for the source</dd>
<dt>annox (str):</dt>
<dd>name of the extra annotation package</dd>
<dt>task:</dt>
<dd>the chosen task</dd>
</dl>
</dd>
</dl>
<p>Sets <em>self.env</em>, a dictionary containg:</p>
<ul class="simple">
<li>source: <em>source</em></li>
<li>annox: <em>annox</em></li>
<li>task: <em>task</em></li>
<li>compile (bool): whether to force (re)compilation</li>
<li>settings (<tt class="xref py py-class docutils literal"><span class="pre">configparser.ConfigParser</span></tt>): entries corresponding to the main configuration file</li>
<li>additional computed settings adapt to the current source and task</li>
</ul>
</dd></dl>

<dl class="attribute">
<dt id="graf.graf.Graf.stamp">
<tt class="descname">stamp</tt><em class="property"> = None</em><a class="headerlink" href="#graf.graf.Graf.stamp" title="Permalink to this definition">¶</a></dt>
<dd><p>Instance member holding the <a class="reference internal" href="#graf.timestamp.Timestamp" title="graf.timestamp.Timestamp"><tt class="xref py py-class docutils literal"><span class="pre">Timestamp</span></tt></a> object.</p>
</dd></dl>

<dl class="method">
<dt id="graf.graf.Graf.write_stats">
<tt class="descname">write_stats</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/graf/graf.html#Graf.write_stats"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.graf.Graf.write_stats" title="Permalink to this definition">¶</a></dt>
<dd><p>Write compilation statistics to file</p>
<p>The compile process generates some statistics that must be read by the task that loads the compiled data.</p>
</dd></dl>

</dd></dl>

<dl class="exception">
<dt id="graf.graf.GrafException">
<em class="property">exception </em><tt class="descname">GrafException</tt><big>(</big><em>message</em>, <em>stamp</em>, <em>Errors</em><big>)</big><a class="reference internal" href="../_modules/graf/graf.html#GrafException"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.graf.GrafException" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">builtins.Exception</span></tt></p>
</dd></dl>

</div>
<div class="section" id="module-graf.model">
<span id="graf-model-module"></span><h2>graf.model module<a class="headerlink" href="#module-graf.model" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="graf.model.arrayify">
<tt class="descname">arrayify</tt><big>(</big><em>source_list</em><big>)</big><a class="reference internal" href="../_modules/graf/model.html#arrayify"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.model.arrayify" title="Permalink to this definition">¶</a></dt>
<dd><p>Efficient storage of a list of lists of integers in two Python <tt class="xref py py-mod docutils literal"><span class="pre">array</span></tt>.</p>
<p><em>This is one of the most important tricks of the whole workbench, and yet it is only 10 lines of code!</em></p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>source_list (iterable):</dt>
<dd>a list of lists of integers</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first docutils">
<dt>(index_array, items_array):</dt>
<dd>two <tt class="xref py py-mod docutils literal"><span class="pre">array</span></tt> s.</dd>
</dl>
<p class="last"><em>index_array</em> contains an index for each item in <em>source_list</em>.
<em>items_array</em> contains all the items in the following way: if an item with <em>n</em> members has to be added,
then first the number <em>n</em> is added, and then all the members.
This is how you get the original information back: if you want the 
members of item <em>i</em> in <em>source_list</em>, read number <em>i</em> in <em>index_array</em>, say <em>k</em>, go to position <em>k</em> in
<em>items_array</em>, read the number at that position, say <em>n</em>,
and then find the members at the next <em>n</em> positions in <em>items_array</em>.</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="graf.model.model">
<tt class="descname">model</tt><big>(</big><em>data_items</em>, <em>temp_data_items</em>, <em>stamp</em><big>)</big><a class="reference internal" href="../_modules/graf/model.html#model"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.model.model" title="Permalink to this definition">¶</a></dt>
<dd><p>Remodels various data structures</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>data_items:</dt>
<dd>data structures coming from <a class="reference internal" href="#module-graf.parse" title="graf.parse"><tt class="xref py py-mod docutils literal"><span class="pre">parse</span></tt></a>, that are here to stay</dd>
<dt>temp_data_items:</dt>
<dd>data structures coming from <a class="reference internal" href="#module-graf.parse" title="graf.parse"><tt class="xref py py-mod docutils literal"><span class="pre">parse</span></tt></a> that may be thrown away
stamp (<tt class="xref py py-class docutils literal"><span class="pre">Timestamp</span></tt>): object for issuing progress messages</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>The resulting permanent remodelled data structures.</dd>
</dl>
<p>Function</p>
</dd></dl>

</div>
<div class="section" id="module-graf.parse">
<span id="graf-parse-module"></span><h2>graf.parse module<a class="headerlink" href="#module-graf.parse" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="graf.parse.AnnotationHandler">
<em class="property">class </em><tt class="descname">AnnotationHandler</tt><big>(</big><em>annotation_file</em>, <em>stamp</em><big>)</big><a class="reference internal" href="../_modules/graf/parse.html#AnnotationHandler"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.parse.AnnotationHandler" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">xml.sax.handler.ContentHandler</span></tt></p>
<p>Handlers used by SAX parsing the annotation files themselves</p>
<p>We have to collect all elements <em>region</em>, <em>node</em> and subelement <em>link</em>, <em>edge</em>, <em>a</em> (annotation) and <em>f</em> (feature).
From these elements we retrieve identifiers and other attributes. we map all identifiers to integers. When we have to associate one piece of data to other pieces, we create arrays of those integers.</p>
<p>The parse process is robust, we are not dependent on a particular ordering or distribution of the regions, nodes, edges, annotations and features in/over the annotation files.</p>
<p>Here is a description of the arrays we create:</p>
<dl class="docutils">
<dt><em>region_begin</em>, <em>region_end</em></dt>
<dd>Every region has an <em>anchors</em> attribute specifying a point or interval in the primary data. We consider a point <em>i</em> as the interval <em>i .. i</em>.
<em>region_begin</em> contains the start anchor of region <em>i</em> for each <em>i</em>, and <em>region_end</em> the end anchor.</dd>
<dt><em>edges_from</em>, <em>edges_to</em></dt>
<dd>Every edge goes from one node to an other. <em>edges_from</em> contains the from node of edge <em>i</em> for each <em>i</em>, and <em>edges_end</em> the to node.</dd>
</dl>
<p>Here is a description of the dictionaries we create:</p>
<dl class="docutils">
<dt><em>feat_value_list_int</em></dt>
<dd>Mapping from the string representations to the internal codes for feature values.</dd>
</dl>
<p>There is also a list of arrays:</p>
<dl class="docutils">
<dt><em>node_region_list</em></dt>
<dd>Element <em>i</em> of this list contains an array with the regions attached to node <em>i</em>.</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">We work with the <em>qualified</em> feature names, i.e. with the label of the annotation in which the feature occurs prepended to it (separated with a <tt class="docutils literal"><span class="pre">.</span></tt>).
Features for nodes and features for edges occupy separate name spaces.</p>
</div>
<dl class="attribute">
<dt id="graf.parse.AnnotationHandler.aid">
<tt class="descname">aid</tt><em class="property"> = None</em><a class="headerlink" href="#graf.parse.AnnotationHandler.aid" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="graf.parse.AnnotationHandler.alabel">
<tt class="descname">alabel</tt><em class="property"> = None</em><a class="headerlink" href="#graf.parse.AnnotationHandler.alabel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="graf.parse.AnnotationHandler.aref">
<tt class="descname">aref</tt><em class="property"> = None</em><a class="headerlink" href="#graf.parse.AnnotationHandler.aref" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="graf.parse.AnnotationHandler.atype">
<tt class="descname">atype</tt><em class="property"> = None</em><a class="headerlink" href="#graf.parse.AnnotationHandler.atype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="graf.parse.AnnotationHandler.characters">
<tt class="descname">characters</tt><big>(</big><em>ch</em><big>)</big><a class="reference internal" href="../_modules/graf/parse.html#AnnotationHandler.characters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.parse.AnnotationHandler.characters" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="graf.parse.AnnotationHandler.endElement">
<tt class="descname">endElement</tt><big>(</big><em>name</em><big>)</big><a class="reference internal" href="../_modules/graf/parse.html#AnnotationHandler.endElement"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.parse.AnnotationHandler.endElement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="graf.parse.AnnotationHandler.file_name">
<tt class="descname">file_name</tt><em class="property"> = None</em><a class="headerlink" href="#graf.parse.AnnotationHandler.file_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="graf.parse.AnnotationHandler.nid">
<tt class="descname">nid</tt><em class="property"> = None</em><a class="headerlink" href="#graf.parse.AnnotationHandler.nid" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="graf.parse.AnnotationHandler.node_link">
<tt class="descname">node_link</tt><em class="property"> = None</em><a class="headerlink" href="#graf.parse.AnnotationHandler.node_link" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="graf.parse.AnnotationHandler.stamp">
<tt class="descname">stamp</tt><em class="property"> = None</em><a class="headerlink" href="#graf.parse.AnnotationHandler.stamp" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="graf.parse.AnnotationHandler.startElement">
<tt class="descname">startElement</tt><big>(</big><em>name</em>, <em>attrs</em><big>)</big><a class="reference internal" href="../_modules/graf/parse.html#AnnotationHandler.startElement"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.parse.AnnotationHandler.startElement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="graf.parse.HeaderHandler">
<em class="property">class </em><tt class="descname">HeaderHandler</tt><big>(</big><em>stamp</em><big>)</big><a class="reference internal" href="../_modules/graf/parse.html#HeaderHandler"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.parse.HeaderHandler" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">xml.sax.handler.ContentHandler</span></tt></p>
<p>Handlers used by SAX parsing the GrAF header file.</p>
<p>We just collect the contents of the <em>loc</em> attributes of the <em>annotation</em> elements.
These are the annotation files that we have to fetch and compile.</p>
<dl class="method">
<dt id="graf.parse.HeaderHandler.characters">
<tt class="descname">characters</tt><big>(</big><em>ch</em><big>)</big><a class="reference internal" href="../_modules/graf/parse.html#HeaderHandler.characters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.parse.HeaderHandler.characters" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="graf.parse.HeaderHandler.endElement">
<tt class="descname">endElement</tt><big>(</big><em>name</em><big>)</big><a class="reference internal" href="../_modules/graf/parse.html#HeaderHandler.endElement"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.parse.HeaderHandler.endElement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="graf.parse.HeaderHandler.stamp">
<tt class="descname">stamp</tt><em class="property"> = None</em><a class="headerlink" href="#graf.parse.HeaderHandler.stamp" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="graf.parse.HeaderHandler.startElement">
<tt class="descname">startElement</tt><big>(</big><em>name</em>, <em>attrs</em><big>)</big><a class="reference internal" href="../_modules/graf/parse.html#HeaderHandler.startElement"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.parse.HeaderHandler.startElement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="graf.parse.add_feature_instance">
<tt class="descname">add_feature_instance</tt><big>(</big><em>atype</em>, <em>fname</em>, <em>aref</em>, <em>value</em><big>)</big><a class="reference internal" href="../_modules/graf/parse.html#add_feature_instance"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.parse.add_feature_instance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="graf.parse.parse">
<tt class="descname">parse</tt><big>(</big><em>graf_header_file</em>, <em>stamp</em><big>)</big><a class="reference internal" href="../_modules/graf/parse.html#parse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.parse.parse" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse a GrAF resource.</p>
<p>Parses a GrAF resource, starting by SAX parsing its header file and subsequently parsing all
files mentioned in that header file.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>graf_header_file (str):</dt>
<dd>path to the GrAF header file</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>a tuple of items which comprise the parse results.</dd>
</dl>
<p>Every member of the returned tuple is itself a tuple of 3 pieces of information:</p>
<ol class="arabic simple">
<li>A <em>key</em> which acts as a name for this part of the result data</li>
<li>The data itself, as described in <a class="reference internal" href="#graf.parse.AnnotationHandler" title="graf.parse.AnnotationHandler"><tt class="xref py py-class docutils literal"><span class="pre">AnnotationHandler</span></tt></a></li>
<li>A boolean indicating whether this data is a temporary result or a permanent result</li>
</ol>
<p>Temporary results will be discarded after the remodeling step, permanent results will be incorporated in 
the task-executing object.</p>
</dd></dl>

</div>
<div class="section" id="module-graf.shell">
<span id="graf-shell-module"></span><h2>graf.shell module<a class="headerlink" href="#module-graf.shell" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="graf.shell.Shell">
<em class="property">class </em><tt class="descname">Shell</tt><a class="reference internal" href="../_modules/graf/shell.html#Shell"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.shell.Shell" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">builtins.object</span></tt></p>
<p>Execute tasks, either in a single run, or with an interactive prompt.</p>
<p>This class knows about the environment, such as command line arguments
and configuration files. 
It collects those information pieces and passes them in suitable form
to the factual task processor.</p>
<p>Upon creation, create a <a class="reference internal" href="#graf.task.GrafTask" title="graf.task.GrafTask"><tt class="xref py py-class docutils literal"><span class="pre">GrafTask</span></tt></a> object based on settings.</p>
<dl class="method">
<dt id="graf.shell.Shell.command_loop">
<tt class="descname">command_loop</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/graf/shell.html#Shell.command_loop"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.shell.Shell.command_loop" title="Permalink to this definition">¶</a></dt>
<dd><p>Command prompt for repeated running of tasks.</p>
</dd></dl>

<dl class="attribute">
<dt id="graf.shell.Shell.cur">
<tt class="descname">cur</tt><em class="property"> = None</em><a class="headerlink" href="#graf.shell.Shell.cur" title="Permalink to this definition">¶</a></dt>
<dd><p>Holds the current selection: the <em>source</em>, the <em>annox</em>, the <em>task</em> and the <em>force_compile</em> option, in that order.</p>
</dd></dl>

<dl class="attribute">
<dt id="graf.shell.Shell.default">
<tt class="descname">default</tt><em class="property"> = None</em><a class="headerlink" href="#graf.shell.Shell.default" title="Permalink to this definition">¶</a></dt>
<dd><p>Defaults for the selectable items: <em>source</em>, <em>annox</em> and <em>task</em>.
If the user does not pass values for them both on the command lines, these ones are used.
If the user does pass some of these values and the command prompt is started, the
command line values are parsed here, and the command prompt will use them as initial values.</p>
</dd></dl>

<dl class="method">
<dt id="graf.shell.Shell.do_command">
<tt class="descname">do_command</tt><big>(</big><em>prompt</em>, <em>choices</em>, <em>helpstr</em><big>)</big><a class="reference internal" href="../_modules/graf/shell.html#Shell.do_command"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.shell.Shell.do_command" title="Permalink to this definition">¶</a></dt>
<dd><p>Prompts the user to enter a command and dispatches it, if correct.</p>
<p>This method asks the user for a command consisting of a single letter.
It checks whether the letter is a legal option.
It add options for quitting (Esc) and displaying help (?).
If he user enters <tt class="docutils literal"><span class="pre">?</span></tt>, the helpstring is displayed.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>prompt (str):</dt>
<dd>the prompt string to be displayed. This string will be extended with a description of the allowed keys to press.</dd>
<dt>choices (str):</dt>
<dd>a string consisting of legal  one letter commands, not separated.</dd>
<dt>helpstr (str):</dt>
<dd>help string to be displayed if the user presses <tt class="docutils literal"><span class="pre">?</span></tt></dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>command (str):</dt>
<dd>the command entered by the user, or <tt class="docutils literal"><span class="pre">None</span></tt> if escape has been pressed.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="graf.shell.Shell.get_ch">
<tt class="descname">get_ch</tt><big>(</big><em>prompt=''</em><big>)</big><a class="reference internal" href="../_modules/graf/shell.html#Shell.get_ch"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.shell.Shell.get_ch" title="Permalink to this definition">¶</a></dt>
<dd><p>Asks for unbuffered single character input, with an optional prompt.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>prompt (str):</dt>
<dd>Optional text to be displayed as prompt.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>ch (char):</dt>
<dd>character pressed by the user. If something gets wrong, returns the <em>Esc</em> character.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="graf.shell.Shell.get_num">
<tt class="descname">get_num</tt><big>(</big><em>prompt</em>, <em>start</em>, <em>end</em><big>)</big><a class="reference internal" href="../_modules/graf/shell.html#Shell.get_num"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.shell.Shell.get_num" title="Permalink to this definition">¶</a></dt>
<dd><p>Asks for a numeric value, and checks whether teh value is in a legal range.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>prompt (str):</dt>
<dd>prompt to be displayed</dd>
<dt>start (str):</dt>
<dd>minimum legal value</dd>
<dt>end (str):</dt>
<dd>maximum legal value</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>number (int):</dt>
<dd>the number if the user entered something legal, and <tt class="docutils literal"><span class="pre">None</span></tt> otherwise.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="graf.shell.Shell.main_command">
<tt class="descname">main_command</tt><big>(</big><em>command</em><big>)</big><a class="reference internal" href="../_modules/graf/shell.html#Shell.main_command"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.shell.Shell.main_command" title="Permalink to this definition">¶</a></dt>
<dd><p>Interprets a top level command.</p>
<p>Depending on the command passed, this methods prompts for additional information.
This happens for the commands that modify the source and task selection.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>command(char):</dt>
<dd>the command character.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>message (str):</dt>
<dd>response text after the command execution.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="graf.shell.Shell.message">
<tt class="descname">message</tt><em class="property"> = None</em><a class="headerlink" href="#graf.shell.Shell.message" title="Permalink to this definition">¶</a></dt>
<dd><p>Response messages to be displayed after the prompt</p>
</dd></dl>

<dl class="method">
<dt id="graf.shell.Shell.processor">
<tt class="descname">processor</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/graf/shell.html#Shell.processor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.shell.Shell.processor" title="Permalink to this definition">¶</a></dt>
<dd><p>Does work. Decides to run one task or start the command prompt.</p>
<p>The decision is based on the presence of command line arguments.
If all arguments are present to specify a task, the <em>run once</em> option will be chosen,
unless the user has explicitly stated <tt class="docutils literal"><span class="pre">--menu</span></tt>.
Otherwise the command prompt is started. If that is the case, the
command line args that did come through, are used as initial values.</p>
</dd></dl>

<dl class="method">
<dt id="graf.shell.Shell.prompt">
<tt class="descname">prompt</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/graf/shell.html#Shell.prompt"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.shell.Shell.prompt" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes an self-explanatory prompt text to the terminal.</p>
</dd></dl>

<dl class="method">
<dt id="graf.shell.Shell.weave">
<tt class="descname">weave</tt><big>(</big><em>data</em><big>)</big><a class="reference internal" href="../_modules/graf/shell.html#Shell.weave"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.shell.Shell.weave" title="Permalink to this definition">¶</a></dt>
<dd><p>Utility value that prepares data for presenting several columns of options
on a terminal screen.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>data(lists of lists):</dt>
<dd>corresponds to a number of lists of options.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>woven(list of lists):</dt>
<dd>correponds to a table where columns are the lists of options
and the options occupy rows. The outermost list are the rows.</dd>
<dt>index(dict of dict):</dt>
<dd>given column number and then row number as keys yields the name of the item at that slot</dd>
<dt>iindex(dict of dict):</dt>
<dd>given column number and then the name of an item as keys yields the 
row number of that item</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-graf.task">
<span id="graf-task-module"></span><h2>graf.task module<a class="headerlink" href="#module-graf.task" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="graf.task.GrafTask">
<em class="property">class </em><tt class="descname">GrafTask</tt><big>(</big><em>settings</em><big>)</big><a class="reference internal" href="../_modules/graf/task.html#GrafTask"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.task.GrafTask" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#graf.graf.Graf" title="graf.graf.Graf"><tt class="xref py py-class docutils literal"><span class="pre">graf.graf.Graf</span></tt></a></p>
<p>Task processor.</p>
<p>A task processor must know how to compile, where the source data is and where the result is going to.
And it must be able to <em>import</em>: and <tt class="xref py py-func docutils literal"><span class="pre">imp.reload()</span></tt>: the tasks.
To that end the search path for modules will be adapted according to the <em>task_dir</em> setting
in the main configuration file.</p>
<p>Upon creation, the configuration settings are store in the object as is</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>settings (<tt class="xref py py-class docutils literal"><span class="pre">configparser.ConfigParser</span></tt>):</dt>
<dd>entries corresponding to the main configuration file</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="graf.task.GrafTask.add_result">
<tt class="descname">add_result</tt><big>(</big><em>file_name</em><big>)</big><a class="reference internal" href="../_modules/graf/task.html#GrafTask.add_result"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.task.GrafTask.add_result" title="Permalink to this definition">¶</a></dt>
<dd><p>Opens a file for writing and stores the handle.</p>
<p>Every task is advised to use this method for opening files for its output.
The file will be closed by the workbench when the task terminates.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first docutils">
<dt>file_name (str):</dt>
<dd>name of the output file.</dd>
</dl>
<p class="last">Its location is the result directory for this task and this source.</p>
</dd>
<dt>Returns:</dt>
<dd>A handle to the opened file.</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="graf.task.GrafTask.annox_changed">
<tt class="descname">annox_changed</tt><em class="property"> = None</em><a class="headerlink" href="#graf.task.GrafTask.annox_changed" title="Permalink to this definition">¶</a></dt>
<dd><p>Instance member to tell whether the annox name has changed</p>
</dd></dl>

<dl class="method">
<dt id="graf.task.GrafTask.check_feat_loaded">
<tt class="descname">check_feat_loaded</tt><big>(</big><em>kind</em>, <em>fname</em><big>)</big><a class="reference internal" href="../_modules/graf/task.html#GrafTask.check_feat_loaded"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.task.GrafTask.check_feat_loaded" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks whether feature data for a specific feature is loaded in memory.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>kind (str):</dt>
<dd>kind (node or edge) of the feature</dd>
<dt>fname:</dt>
<dd>the qualified name of the feature.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>True if data is in memory, otherwise False.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="graf.task.GrafTask.check_xmlid_loaded">
<tt class="descname">check_xmlid_loaded</tt><big>(</big><em>kind</em><big>)</big><a class="headerlink" href="#graf.task.GrafTask.check_xmlid_loaded" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks whether xmlid data for nodes or edges are loaded into memory</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>kind (str):</dt>
<dd>kind (node or edge)</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>True if data is in memory, otherwise False.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="graf.task.GrafTask.common_loader">
<tt class="descname">common_loader</tt><big>(</big><em>directives</em><big>)</big><a class="reference internal" href="../_modules/graf/task.html#GrafTask.common_loader"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.task.GrafTask.common_loader" title="Permalink to this definition">¶</a></dt>
<dd><p>Manage the common data to be loaded.</p>
<p>Common data is data  common to all tasks but specific to a source.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>directives (dict):</dt>
<dd>Currently not used.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="graf.task.GrafTask.compile">
<tt class="descname">compile</tt><big>(</big><em>force_compile</em><big>)</big><a class="reference internal" href="../_modules/graf/task.html#GrafTask.compile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.task.GrafTask.compile" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="graf.task.GrafTask.feature_loader">
<tt class="descname">feature_loader</tt><big>(</big><em>directives</em><big>)</big><a class="reference internal" href="../_modules/graf/task.html#GrafTask.feature_loader"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.task.GrafTask.feature_loader" title="Permalink to this definition">¶</a></dt>
<dd><p>Manage the feature data to be loaded.</p>
<p>The specification of which features are selected is still a string.
Here we compile it into a dictionary <em>only</em>, keyed with the qualified feature name.</p>
<p>The loaded features together form a dictionary, keyed with the qualified feature name.
The values are dictionaries keyed by the element, with as values the feature values.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>directives (dict): dictionary items to load. </dt>
<dd><p class="first">Relevant is:</p>
<dl class="last docutils">
<dt>directives[&#8216;features&#8217;]:</dt>
<dd>strings specifying the features selected for feature loading. 
There are two keys: <em>node</em> and <em>edge</em>, because node features and edge features are handled separately.</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="graf.task.GrafTask.finish_task">
<tt class="descname">finish_task</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/graf/task.html#GrafTask.finish_task"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.task.GrafTask.finish_task" title="Permalink to this definition">¶</a></dt>
<dd><p>Finalizes the current task.</p>
<p>Open result files will be closed.</p>
<p>There will be a progress message, and a directory listing of the result directory,
for the convenience of the user.</p>
</dd></dl>

<dl class="method">
<dt id="graf.task.GrafTask.get_edge_feature_value">
<tt class="descname">get_edge_feature_value</tt><big>(</big><em>edge</em>, <em>fname</em><big>)</big><a class="headerlink" href="#graf.task.GrafTask.get_edge_feature_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Edge feature value lookup returning the internal integer representation.</p>
</dd></dl>

<dl class="method">
<dt id="graf.task.GrafTask.get_mappings">
<tt class="descname">get_mappings</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/graf/task.html#GrafTask.get_mappings"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.task.GrafTask.get_mappings" title="Permalink to this definition">¶</a></dt>
<dd><p>Return references to API methods of this class.</p>
<p>The caller can give convenient, local names to these methods.
It also saves method lookup,
at least, I think so.</p>
</dd></dl>

<dl class="method">
<dt id="graf.task.GrafTask.get_node_feature_value">
<tt class="descname">get_node_feature_value</tt><big>(</big><em>node</em>, <em>fname</em><big>)</big><a class="headerlink" href="#graf.task.GrafTask.get_node_feature_value" title="Permalink to this definition">¶</a></dt>
<dd><p>Node feature value lookup returning the internal integer representation.</p>
</dd></dl>

<dl class="method">
<dt id="graf.task.GrafTask.getitems">
<tt class="descname">getitems</tt><big>(</big><em>data</em>, <em>data_items</em>, <em>elem</em><big>)</big><a class="reference internal" href="../_modules/graf/task.html#GrafTask.getitems"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.task.GrafTask.getitems" title="Permalink to this definition">¶</a></dt>
<dd><p>Get related items from an arrayified data structure.</p>
<p>If a relation between integers and sets of integers has been stored as a double array
by the <a class="reference internal" href="#graf.model.arrayify" title="graf.model.arrayify"><tt class="xref py py-func docutils literal"><span class="pre">arrayify()</span></tt></a> function,
this is the way to look up the set of related integers for each integer.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>data (array):</dt>
<dd>see next</dd>
<dt>data_items (array):</dt>
<dd>together with <em>data</em> the arrayified data</dd>
<dt>elem (int):</dt>
<dd>the integer for which we want its related set of integers.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>a list of the related integers.</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="graf.task.GrafTask.has_compiled">
<tt class="descname">has_compiled</tt><em class="property"> = None</em><a class="headerlink" href="#graf.task.GrafTask.has_compiled" title="Permalink to this definition">¶</a></dt>
<dd><p>Instance member to tell whether compilation has actually taken place</p>
</dd></dl>

<dl class="method">
<dt id="graf.task.GrafTask.hasitem">
<tt class="descname">hasitem</tt><big>(</big><em>data</em>, <em>data_items</em>, <em>elem</em>, <em>item</em><big>)</big><a class="reference internal" href="../_modules/graf/task.html#GrafTask.hasitem"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.task.GrafTask.hasitem" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether an integer is in the set of related items
with respect to an arrayified data structure (see also <a class="reference internal" href="#graf.task.GrafTask.getitems" title="graf.task.GrafTask.getitems"><tt class="xref py py-meth docutils literal"><span class="pre">getitems()</span></tt></a>).</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>data (array):</dt>
<dd>see next</dd>
<dt>data_items (array):</dt>
<dd>together with <em>data</em> the arrayified data</dd>
<dt>elem (int):</dt>
<dd>the integer for which we want its related set of integers.</dd>
<dt>item (int):</dt>
<dd>the integer whose presence in the related items set is to be tested.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd>bool: whether the integer is in the related set or not.</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="graf.task.GrafTask.hasitems">
<tt class="descname">hasitems</tt><big>(</big><em>data</em>, <em>data_items</em>, <em>elem</em>, <em>items</em><big>)</big><a class="reference internal" href="../_modules/graf/task.html#GrafTask.hasitems"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.task.GrafTask.hasitems" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether a set of integers intersects with the set of related items
with respect to an arrayified data structure (see also <a class="reference internal" href="#graf.task.GrafTask.getitems" title="graf.task.GrafTask.getitems"><tt class="xref py py-meth docutils literal"><span class="pre">getitems()</span></tt></a>).</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>data (array):</dt>
<dd>see next</dd>
<dt>data_items (array):</dt>
<dd>together with <em>data</em> the arrayified data</dd>
<dt>elem (int):</dt>
<dd>the integer for which we want its related set of integers.</dd>
<dt>items (array or list of integers):</dt>
<dd>the set of integers
whose presence in the related items set is to be tested.</dd>
</dl>
</dd>
<dt>Returns:</dt>
<dd><dl class="first last docutils">
<dt>bool:</dt>
<dd>whether one of the integers is in the related set or not.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="graf.task.GrafTask.init_task">
<tt class="descname">init_task</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/graf/task.html#GrafTask.init_task"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.task.GrafTask.init_task" title="Permalink to this definition">¶</a></dt>
<dd><p>Initializes the current task.</p>
<p>Very trivial initialization: just issue a progress message.</p>
</dd></dl>

<dl class="method">
<dt id="graf.task.GrafTask.int_edge_xid">
<tt class="descname">int_edge_xid</tt><big>(</big><em>rep</em><big>)</big><a class="headerlink" href="#graf.task.GrafTask.int_edge_xid" title="Permalink to this definition">¶</a></dt>
<dd><p>API: <em>xml edge id</em> conversion from string representation as found in LAF resource
to corresponding integer as used in compiled resource.</p>
</dd></dl>

<dl class="method">
<dt id="graf.task.GrafTask.int_fval">
<tt class="descname">int_fval</tt><big>(</big><em>rep</em><big>)</big><a class="reference internal" href="../_modules/graf/task.html#GrafTask.int_fval"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.task.GrafTask.int_fval" title="Permalink to this definition">¶</a></dt>
<dd><p>API: <em>feature value</em> conversion from string representation as found in LAF resource
to corresponding integer as used in compiled resource.</p>
</dd></dl>

<dl class="method">
<dt id="graf.task.GrafTask.int_node_xid">
<tt class="descname">int_node_xid</tt><big>(</big><em>rep</em><big>)</big><a class="headerlink" href="#graf.task.GrafTask.int_node_xid" title="Permalink to this definition">¶</a></dt>
<dd><p>API: <em>xml node id</em> conversion from string representation as found in LAF resource
to corresponding integer as used in compiled resource.</p>
</dd></dl>

<dl class="method">
<dt id="graf.task.GrafTask.load_feat">
<tt class="descname">load_feat</tt><big>(</big><em>kind</em>, <em>fname</em><big>)</big><a class="reference internal" href="../_modules/graf/task.html#GrafTask.load_feat"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.task.GrafTask.load_feat" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads selected feature into memory.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>kind (str):</dt>
<dd>kind (node or edge) of the feature</dd>
<dt>fname:</dt>
<dd>the qualified name of the feature.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="graf.task.GrafTask.loaded">
<tt class="descname">loaded</tt><em class="property"> = None</em><a class="headerlink" href="#graf.task.GrafTask.loaded" title="Permalink to this definition">¶</a></dt>
<dd><p>Set of feature data sets that have been loaded, node features and edge features under different keys</p>
</dd></dl>

<dl class="method">
<dt id="graf.task.GrafTask.loader">
<tt class="descname">loader</tt><big>(</big><em>source</em>, <em>task</em>, <em>directives</em><big>)</big><a class="reference internal" href="../_modules/graf/task.html#GrafTask.loader"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.task.GrafTask.loader" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads compiled LAF data.</p>
<p>There are several kinds of data to be loaded:</p>
<dl class="docutils">
<dt><em>common data</em></dt>
<dd>Data that is common to all tasks, but dependent on the choice of source.
It is the data that holds the regions, nodes, edges, but not the features.</dd>
<dt><em>xml id data</em></dt>
<dd>The mappngs between original xmlids in the LAF source and the integers identifying nodes
and edges in the compilation result.
This data is also common to all tasks, but can be loaded and unloaded on demand.</dd>
<dt><em>feature data</em></dt>
<dd>Data that is requested by the task at hand.
It is the data that holds feature information,
for those features that are requested by a task&#8217;s <em>load[&#8216;feature&#8217;]</em> declaration.</dd>
<dt><em>annox data</em></dt>
<dd>Feature data coming from extra annotation files.</dd>
</dl>
<p>The <em>common data</em> can be loaded in bulk fast, but it still takes 5 to 10 seconds,
and should be avoided if possible.
This data only needs to be loaded if the source has changed or if compilation has taken place.
It is taken care of by <a class="reference internal" href="#graf.task.GrafTask.common_loader" title="graf.task.GrafTask.common_loader"><tt class="xref py py-meth docutils literal"><span class="pre">common_loader()</span></tt></a>.</p>
<p>The <em>feature data</em> is loaded and unloaded on demand
and the feature manager method <a class="reference internal" href="#graf.task.GrafTask.feature_loader" title="graf.task.GrafTask.feature_loader"><tt class="xref py py-meth docutils literal"><span class="pre">feature_loader()</span></tt></a> takes care of that.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>directives (dict):</dt>
<dd>a dictionary of information relevant to <a class="reference internal" href="#graf.task.GrafTask.common_loader" title="graf.task.GrafTask.common_loader"><tt class="xref py py-meth docutils literal"><span class="pre">common_loader()</span></tt></a> and <a class="reference internal" href="#graf.task.GrafTask.feature_loader" title="graf.task.GrafTask.feature_loader"><tt class="xref py py-meth docutils literal"><span class="pre">feature_loader()</span></tt></a>.</dd>
</dl>
</dd>
</dl>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">some directives are used by <a class="reference internal" href="#graf.task.GrafTask.common_loader" title="graf.task.GrafTask.common_loader"><tt class="xref py py-meth docutils literal"><span class="pre">common_loader()</span></tt></a> and some by <a class="reference internal" href="#graf.task.GrafTask.feature_loader" title="graf.task.GrafTask.feature_loader"><tt class="xref py py-meth docutils literal"><span class="pre">feature_loader()</span></tt></a>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="graf.task.GrafTask.make_inverse">
<tt class="descname">make_inverse</tt><big>(</big><em>label</em>, <em>inv_label</em><big>)</big><a class="headerlink" href="#graf.task.GrafTask.make_inverse" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates the inverse lookup table for a data table</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>label (str):</dt>
<dd>if label ends with <tt class="docutils literal"><span class="pre">_int</span></tt>, a new label will be created with <tt class="docutils literal"><span class="pre">_int</span></tt> replaced by <tt class="docutils literal"><span class="pre">_rep</span></tt>.</dd>
</dl>
</dd>
</dl>
<p>The data table with name <em>label</em> is a dictionary mapping string representations to integers (one-to-one).
We create a table with the new label holding the inverse mapping, i.e. from integers back to the representations.</p>
</dd></dl>

<dl class="method">
<dt id="graf.task.GrafTask.next_node">
<tt class="descname">next_node</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/graf/task.html#GrafTask.next_node"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.task.GrafTask.next_node" title="Permalink to this definition">¶</a></dt>
<dd><p>API: iterator of all nodes in primary data order.</p>
<p>Each call <em>yields</em> the next node. The iterator walks through all nodes.
The order is implied by the attachment of nodes to the primary data,
which is itself linearly ordered.
This order is explained in the <a class="reference internal" href="../taskwriting.html#node-order"><em>guidelines for task writing</em></a>.</p>
</dd></dl>

<dl class="method">
<dt id="graf.task.GrafTask.next_node_with_fval">
<tt class="descname">next_node_with_fval</tt><big>(</big><em>fname</em>, <em>value</em><big>)</big><a class="reference internal" href="../_modules/graf/task.html#GrafTask.next_node_with_fval"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.task.GrafTask.next_node_with_fval" title="Permalink to this definition">¶</a></dt>
<dd><p>API: iterator of all nodes in primary data order that have a
given value for a given feature.</p>
<p>See also <a class="reference internal" href="#graf.task.GrafTask.next_node" title="graf.task.GrafTask.next_node"><tt class="xref py py-meth docutils literal"><span class="pre">next_node()</span></tt></a>.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>name (int):</dt>
<dd>the code of a feature name</dd>
<dt>value (int):</dt>
<dd>the code of a feature value</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="graf.task.GrafTask.rep_edge_xid">
<tt class="descname">rep_edge_xid</tt><big>(</big><em>intl</em><big>)</big><a class="headerlink" href="#graf.task.GrafTask.rep_edge_xid" title="Permalink to this definition">¶</a></dt>
<dd><p>API: <em>xml edge id</em> conversion from integer code as used in compiled LAF resource
to corresponding string representation as found in original LAF resource.</p>
</dd></dl>

<dl class="method">
<dt id="graf.task.GrafTask.rep_fval">
<tt class="descname">rep_fval</tt><big>(</big><em>intl</em><big>)</big><a class="reference internal" href="../_modules/graf/task.html#GrafTask.rep_fval"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.task.GrafTask.rep_fval" title="Permalink to this definition">¶</a></dt>
<dd><p>API: <em>feature value</em> conversion from integer code as used in compiled LAF resource
to corresponding string representation as found in original LAF resource.</p>
</dd></dl>

<dl class="method">
<dt id="graf.task.GrafTask.rep_node_xid">
<tt class="descname">rep_node_xid</tt><big>(</big><em>intl</em><big>)</big><a class="headerlink" href="#graf.task.GrafTask.rep_node_xid" title="Permalink to this definition">¶</a></dt>
<dd><p>API: <em>xml node id</em> conversion from integer code as used in compiled LAF resource
to corresponding string representation as found in original LAF resource.</p>
</dd></dl>

<dl class="attribute">
<dt id="graf.task.GrafTask.result_files">
<tt class="descname">result_files</tt><em class="property"> = None</em><a class="headerlink" href="#graf.task.GrafTask.result_files" title="Permalink to this definition">¶</a></dt>
<dd><p>List of handles to result files created by the task through the method <a class="reference internal" href="#graf.task.GrafTask.add_result" title="graf.task.GrafTask.add_result"><tt class="xref py py-meth docutils literal"><span class="pre">add_result()</span></tt></a></p>
</dd></dl>

<dl class="method">
<dt id="graf.task.GrafTask.run">
<tt class="descname">run</tt><big>(</big><em>source</em>, <em>annox</em>, <em>task</em>, <em>force_compile=False</em><big>)</big><a class="reference internal" href="../_modules/graf/task.html#GrafTask.run"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.task.GrafTask.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Run a task.</p>
<p>That is:
* Load the data
* (Re)load the task code
* Initialize the task
* Run the task code
* Finalize the task</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>source (str):</dt>
<dd>key for the source</dd>
<dt>annox (str):</dt>
<dd>name of the extra annotation package</dd>
<dt>task:</dt>
<dd>the chosen task</dd>
<dt>force_compile (bool):</dt>
<dd>whether to force (re)compilation of the LAF source</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="graf.task.GrafTask.settings">
<tt class="descname">settings</tt><em class="property"> = None</em><a class="headerlink" href="#graf.task.GrafTask.settings" title="Permalink to this definition">¶</a></dt>
<dd><p>Instance member to hold configuration settings</p>
</dd></dl>

<dl class="attribute">
<dt id="graf.task.GrafTask.source_changed">
<tt class="descname">source_changed</tt><em class="property"> = None</em><a class="headerlink" href="#graf.task.GrafTask.source_changed" title="Permalink to this definition">¶</a></dt>
<dd><p>Instance member to tell whether the source name has changed</p>
</dd></dl>

<dl class="attribute">
<dt id="graf.task.GrafTask.task_changed">
<tt class="descname">task_changed</tt><em class="property"> = None</em><a class="headerlink" href="#graf.task.GrafTask.task_changed" title="Permalink to this definition">¶</a></dt>
<dd><p>Instance member to tell whether the task name has changed</p>
</dd></dl>

<dl class="method">
<dt id="graf.task.GrafTask.unload_feat">
<tt class="descname">unload_feat</tt><big>(</big><em>kind</em>, <em>fname</em><big>)</big><a class="reference internal" href="../_modules/graf/task.html#GrafTask.unload_feat"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.task.GrafTask.unload_feat" title="Permalink to this definition">¶</a></dt>
<dd><p>Unloads selected feature from memory.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>kind (str):</dt>
<dd>kind (node or edge) of the feature</dd>
<dt>fname:</dt>
<dd>the qualified name of the feature.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="graf.task.GrafTask.xloaded">
<tt class="descname">xloaded</tt><em class="property"> = None</em><a class="headerlink" href="#graf.task.GrafTask.xloaded" title="Permalink to this definition">¶</a></dt>
<dd><p>Set of xmlid data sets that have been loaded, keys for <tt class="docutils literal"><span class="pre">node</span></tt> and <tt class="docutils literal"><span class="pre">edge</span></tt>.</p>
</dd></dl>

<dl class="method">
<dt id="graf.task.GrafTask.xmlids_loader">
<tt class="descname">xmlids_loader</tt><big>(</big><em>directives</em><big>)</big><a class="headerlink" href="#graf.task.GrafTask.xmlids_loader" title="Permalink to this definition">¶</a></dt>
<dd><p>Manage the common data to be loaded.</p>
<p>Loading of xml-id information.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>directives (dict):</dt>
<dd><p class="first">dictionary specifying what to load. 
Relevant is:</p>
<dl class="last docutils">
<dt>directives[&#8216;xmlids&#8217;]:</dt>
<dd>booleans specifying whether xmlids should be loaded.
There are two keys: <em>node</em> and <em>edge</em>, because nodes and edges are handled separately.</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-graf.timestamp">
<span id="graf-timestamp-module"></span><h2>graf.timestamp module<a class="headerlink" href="#module-graf.timestamp" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="graf.timestamp.Timestamp">
<em class="property">class </em><tt class="descname">Timestamp</tt><big>(</big><em>log_file=None</em><big>)</big><a class="reference internal" href="../_modules/graf/timestamp.html#Timestamp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.timestamp.Timestamp" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">builtins.object</span></tt></p>
<p>Time management.</p>
<p>Objects remember their creation time. So they can issue statements about how much time has been elapsed.
All timed log messages of the program should be issued through the <a class="reference internal" href="#graf.timestamp.Timestamp.progress" title="graf.timestamp.Timestamp.progress"><tt class="xref py py-meth docutils literal"><span class="pre">progress()</span></tt></a> method of this class.</p>
<p>It is also possible to connect a logfile to these objects.
When progress messages are issued, they are also written to the connected log file.</p>
<p>Upon creation, retrieves the time.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>log_file (file):</dt>
<dd>open file handle for writing. Optional. If not <tt class="docutils literal"><span class="pre">None</span></tt> stores the handle in the object&#8217;s data.</dd>
</dl>
</dd>
</dl>
<dl class="method">
<dt id="graf.timestamp.Timestamp.connect_log">
<tt class="descname">connect_log</tt><big>(</big><em>log_file</em><big>)</big><a class="reference internal" href="../_modules/graf/timestamp.html#Timestamp.connect_log"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.timestamp.Timestamp.connect_log" title="Permalink to this definition">¶</a></dt>
<dd><p>Connects a log file to the object.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>log_file (file):</dt>
<dd>open handle for writing.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="graf.timestamp.Timestamp.disconnect_log">
<tt class="descname">disconnect_log</tt><big>(</big><big>)</big><a class="headerlink" href="#graf.timestamp.Timestamp.disconnect_log" title="Permalink to this definition">¶</a></dt>
<dd><p>Connects a log file to the object.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>log_file (file):</dt>
<dd>open handle for writing.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="graf.timestamp.Timestamp.elapsed">
<tt class="descname">elapsed</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/graf/timestamp.html#Timestamp.elapsed"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.timestamp.Timestamp.elapsed" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the time elapsed since creation of the <a class="reference internal" href="#graf.timestamp.Timestamp" title="graf.timestamp.Timestamp"><tt class="xref py py-class docutils literal"><span class="pre">Timestamp</span></tt></a> object.</p>
<dl class="docutils">
<dt>Returns:</dt>
<dd>A pretty formatted string, ready to include in a message.</dd>
</dl>
</dd></dl>

<dl class="attribute">
<dt id="graf.timestamp.Timestamp.log">
<tt class="descname">log</tt><em class="property"> = None</em><a class="headerlink" href="#graf.timestamp.Timestamp.log" title="Permalink to this definition">¶</a></dt>
<dd><p>Instance member holding a handle to a logfile, open for writing, if a log file has been attached to the object.</p>
</dd></dl>

<dl class="method">
<dt id="graf.timestamp.Timestamp.progress">
<tt class="descname">progress</tt><big>(</big><em>msg</em>, <em>newline=True</em><big>)</big><a class="reference internal" href="../_modules/graf/timestamp.html#Timestamp.progress"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.timestamp.Timestamp.progress" title="Permalink to this definition">¶</a></dt>
<dd><p>API: issues a timed progress message.</p>
<p>The message is issued to the standard output, and, if a log file has been connected, also to the log file.</p>
<dl class="docutils">
<dt>Args:</dt>
<dd><dl class="first last docutils">
<dt>msg (str):</dt>
<dd>text of the message</dd>
<dt>newline (bool):</dt>
<dd>whether or not to add a newline. Optional. Make it <tt class="docutils literal"><span class="pre">False</span></tt> to not add a newline.</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="graf.timestamp.Timestamp.reset">
<tt class="descname">reset</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/graf/timestamp.html#Timestamp.reset"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.timestamp.Timestamp.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the time to the current time</p>
</dd></dl>

<dl class="attribute">
<dt id="graf.timestamp.Timestamp.timestamp">
<tt class="descname">timestamp</tt><em class="property"> = None</em><a class="headerlink" href="#graf.timestamp.Timestamp.timestamp" title="Permalink to this definition">¶</a></dt>
<dd><p>Instance member holding the time the object was created</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-graf">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-graf" title="Permalink to this headline">¶</a></h2>
</div>
</div>


          <footer>
  
    <div class="rst-footer-buttons">
      
      
        <a href="modules.html" class="btn btn-neutral" title="graf"><span class="icon icon-circle-arrow-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <p>
      &copy; Copyright 2013, Dirk Roorda.
  </p>

  <a href="https://www.github.com/snide/sphinx_rtd_theme">Sphinx theme</a> provided by <a href="http://readthedocs.org">Read the Docs</a>
</footer>
        </div>
      </div>

    </section>

  </div>
  

</body>
</html>