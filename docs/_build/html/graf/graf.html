<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>graf package &mdash; LAF-Fabric 0.9.1 documentation</title>
    
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.9.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="LAF-Fabric 0.9.1 documentation" href="../index.html" />
    <link rel="up" title="graf" href="modules.html" />
    <link rel="prev" title="graf" href="modules.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="modules.html" title="graf"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">LAF-Fabric 0.9.1 documentation</a> &raquo;</li>
          <li><a href="modules.html" accesskey="U">graf</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="graf-package">
<h1>graf package<a class="headerlink" href="#graf-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-graf.compiler">
<span id="graf-compiler-module"></span><h2>graf.compiler module<a class="headerlink" href="#module-graf.compiler" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="graf.compiler.GrafCompiler">
<em class="property">class </em><tt class="descname">GrafCompiler</tt><big>(</big><em>env</em><big>)</big><a class="reference internal" href="../_modules/graf/compiler.html#GrafCompiler"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.compiler.GrafCompiler" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#graf.graf.Graf" title="graf.graf.Graf"><tt class="xref py py-class docutils literal"><span class="pre">graf.graf.Graf</span></tt></a></p>
<p>Takes care of the compilation of LAF xml data into binary data.</p>
<p>There are two stages in compilation:</p>
<ul class="simple">
<li>parsing the XML data by means of a SAX parser (a lengthy process)</li>
<li>remodeling the parse results in really tight data structures</li>
</ul>
<p>Upon creation, the relevant directories are communicated.</p>
<p>The initialization of the base class is performed, and we change working directory to the location of the LAF source.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>env</strong> (<em>str</em>) &#8211;
path information</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="graf.compiler.GrafCompiler.compiler">
<tt class="descname">compiler</tt><big>(</big><em>force=False</em><big>)</big><a class="reference internal" href="../_modules/graf/compiler.html#GrafCompiler.compiler"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.compiler.GrafCompiler.compiler" title="Permalink to this definition">¶</a></dt>
<dd><p>Manages the complete compilation process.</p>
<p>Detects the need for compiling, responds to the <em>force</em> argument. Then parses, remodels and writes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>force</strong> (<em>bool</em>) &#8211;
whether to compile even if the binary data looks up to date.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="graf.compiler.GrafCompiler.env">
<tt class="descname">env</tt><em class="property"> = None</em><a class="headerlink" href="#graf.compiler.GrafCompiler.env" title="Permalink to this definition">¶</a></dt>
<dd><p>Instance member to hold config settings etc</p>
</dd></dl>

<dl class="attribute">
<dt id="graf.compiler.GrafCompiler.has_compiled">
<tt class="descname">has_compiled</tt><em class="property"> = None</em><a class="headerlink" href="#graf.compiler.GrafCompiler.has_compiled" title="Permalink to this definition">¶</a></dt>
<dd><p>Instance member to tell whether compilation has actually taken place</p>
</dd></dl>

<dl class="method">
<dt id="graf.compiler.GrafCompiler.model">
<tt class="descname">model</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/graf/compiler.html#GrafCompiler.model"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.compiler.GrafCompiler.model" title="Permalink to this definition">¶</a></dt>
<dd><p>Call the remodeler and store the remodeled data in the object.</p>
</dd></dl>

<dl class="method">
<dt id="graf.compiler.GrafCompiler.needs_compiling">
<tt class="descname">needs_compiling</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/graf/compiler.html#GrafCompiler.needs_compiling"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.compiler.GrafCompiler.needs_compiling" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks whether the compiled binary data is still up to date.</p>
<p>The criterion is whether the generated statistics file at the binary side is newer than the chosen GrAF header file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><em>bool</em> &#8211;
whether the criterion for compiling holds.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="graf.compiler.GrafCompiler.parse">
<tt class="descname">parse</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/graf/compiler.html#GrafCompiler.parse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.compiler.GrafCompiler.parse" title="Permalink to this definition">¶</a></dt>
<dd><p>Call the XML parser and collect the parse results.</p>
<p>Some parse results must be remodelled afterwards.
After remodelling some parse data can be thrown away.
Only store data that is needed for task execution in the object.</p>
<p>The actual parsing is done in the module <a class="reference internal" href="#module-graf.parse" title="graf.parse"><tt class="xref py py-mod docutils literal"><span class="pre">parse</span></tt></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="graf.compiler.GrafCompiler.temp_data_items">
<tt class="descname">temp_data_items</tt><em class="property"> = {}</em><a class="headerlink" href="#graf.compiler.GrafCompiler.temp_data_items" title="Permalink to this definition">¶</a></dt>
<dd><p>Holds some data delivered by the parsed that can be thrown away later. The data that we must keep is stored in the object, of course.</p>
</dd></dl>

<dl class="method">
<dt id="graf.compiler.GrafCompiler.write_data">
<tt class="descname">write_data</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/graf/compiler.html#GrafCompiler.write_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.compiler.GrafCompiler.write_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes compiled data to disk.</p>
<p>Compiled data has three possible types:</p>
<dl class="docutils">
<dt><em>0: plain array</em></dt>
<dd>can be written fast with the <tt class="xref py py-meth docutils literal"><span class="pre">array.tofile()</span></tt> method</dd>
<dt><em>1: array valued dict</em></dt>
<dd>a dictionary, keyed by a feature name and with arrays as values</dd>
<dt><em>2: list of trings</em></dt>
<dd>can be dumped with the <tt class="xref py py-meth docutils literal"><span class="pre">cPickle.dump()</span></tt> method.</dd>
</dl>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-graf.graf">
<span id="graf-graf-module"></span><h2>graf.graf module<a class="headerlink" href="#module-graf.graf" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="graf.graf.Graf">
<em class="property">class </em><tt class="descname">Graf</tt><a class="reference internal" href="../_modules/graf/graf.html#Graf"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.graf.Graf" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Base class for compiling LAF resources and running analytic tasks on them.</p>
<p>This class has only a rudimentary method set. Compiling a LAF resource is done by the GrafCompiler derived class
and running analytic tasks is done by the GrafTask class.</p>
<p>The data of this class represents the compiled data on the basis of which tasks can run.
This data is created by a <a class="reference internal" href="#graf.compiler.GrafCompiler" title="graf.compiler.GrafCompiler"><tt class="xref py py-class docutils literal"><span class="pre">GrafCompiler</span></tt></a> that derives from this class.</p>
<p>Upon creation, empty datastructures are initialized to hold the binary,
compiled LAF data and create a directory for their serializations on disk.</p>
<p>The Graf object holds information that Graf tasks need to perform their operations.
The most important piece of information is the data itself.
This data consists of arrays and dictionaries that together hold the information that is compiled from a LAF resource.</p>
<p>Other things that happen:</p>
<ol class="arabic simple">
<li>a fresh Timestamp object is created, which records the current time and can issue progress messages containing the amount
of time that has elapsed since this object has been created.</li>
<li>if the directory that should hold the compiled data does not exist,
a new directory is created Of course this means that before executing any tasks,
the LAF resource has to be (re)compiled.</li>
</ol>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">object with data structures initialized, ready to load the compiled data from disk.</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="graf.graf.Graf.BIN_EXT">
<tt class="descname">BIN_EXT</tt><em class="property"> = 'bin'</em><a class="headerlink" href="#graf.graf.Graf.BIN_EXT" title="Permalink to this definition">¶</a></dt>
<dd><p>extension for binary files</p>
</dd></dl>

<dl class="attribute">
<dt id="graf.graf.Graf.COMPILE_TASK">
<tt class="descname">COMPILE_TASK</tt><em class="property"> = 'compile'</em><a class="headerlink" href="#graf.graf.Graf.COMPILE_TASK" title="Permalink to this definition">¶</a></dt>
<dd><p>name of the compile task</p>
</dd></dl>

<dl class="attribute">
<dt id="graf.graf.Graf.LOG_NAME">
<tt class="descname">LOG_NAME</tt><em class="property"> = '__log__'</em><a class="headerlink" href="#graf.graf.Graf.LOG_NAME" title="Permalink to this definition">¶</a></dt>
<dd><p>log file base name for a task</p>
</dd></dl>

<dl class="attribute">
<dt id="graf.graf.Graf.STAT_NAME">
<tt class="descname">STAT_NAME</tt><em class="property"> = '__stat__'</em><a class="headerlink" href="#graf.graf.Graf.STAT_NAME" title="Permalink to this definition">¶</a></dt>
<dd><p>statistics file base name for a task</p>
</dd></dl>

<dl class="attribute">
<dt id="graf.graf.Graf.TEXT_EXT">
<tt class="descname">TEXT_EXT</tt><em class="property"> = 'txt'</em><a class="headerlink" href="#graf.graf.Graf.TEXT_EXT" title="Permalink to this definition">¶</a></dt>
<dd><p>extension for text files</p>
</dd></dl>

<dl class="method">
<dt id="graf.graf.Graf.__del__">
<tt class="descname">__del__</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/graf/graf.html#Graf.__del__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.graf.Graf.__del__" title="Permalink to this definition">¶</a></dt>
<dd><p>Clean up</p>
<p>Close all file handles that are still open.</p>
</dd></dl>

<dl class="method">
<dt id="graf.graf.Graf.add_logfile">
<tt class="descname">add_logfile</tt><big>(</big><em>location=None</em>, <em>name=None</em><big>)</big><a class="reference internal" href="../_modules/graf/graf.html#Graf.add_logfile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.graf.Graf.add_logfile" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and open a log file for a given task.</p>
<p>When tasks run, they generate progress messages with timing information in them.
They may issue errors and warnings. All this information also goes into a log file.
The log file is placed in the result directory of the task at hand.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>location</strong> (<em>str</em>) &#8211;
override default directory for log file</li>
<li><strong>name</strong> (<em>str</em>) &#8211;
override default name for log file</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="graf.graf.Graf.data_items">
<tt class="descname">data_items</tt><em class="property"> = None</em><a class="headerlink" href="#graf.graf.Graf.data_items" title="Permalink to this definition">¶</a></dt>
<dd><p>Instance member holding the compiled data in the form of a dictionary of arrays and lists.</p>
<p>See the <a class="reference internal" href="#module-graf.compiler" title="graf.compiler"><tt class="xref py py-mod docutils literal"><span class="pre">compiler</span></tt></a> and <a class="reference internal" href="#module-graf.model" title="graf.model"><tt class="xref py py-mod docutils literal"><span class="pre">model</span></tt></a> modules for the way the compiled data is organised.</p>
</dd></dl>

<dl class="attribute">
<dt id="graf.graf.Graf.edge_feat">
<tt class="descname">edge_feat</tt><em class="property"> = None</em><a class="headerlink" href="#graf.graf.Graf.edge_feat" title="Permalink to this definition">¶</a></dt>
<dd><p>Feature data (for features on edges) stored in dictionary for fast access</p>
</dd></dl>

<dl class="attribute">
<dt id="graf.graf.Graf.env">
<tt class="descname">env</tt><em class="property"> = None</em><a class="headerlink" href="#graf.graf.Graf.env" title="Permalink to this definition">¶</a></dt>
<dd><p>Holds the environment parameters for the current task</p>
</dd></dl>

<dl class="method">
<dt id="graf.graf.Graf.init_data">
<tt class="descname">init_data</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/graf/graf.html#Graf.init_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.graf.Graf.init_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Resets all loaded data to initial values</p>
<p>This is needed when the task processor switches from one source to another,
or when a recompile has been performed.</p>
</dd></dl>

<dl class="attribute">
<dt id="graf.graf.Graf.log">
<tt class="descname">log</tt><em class="property"> = None</em><a class="headerlink" href="#graf.graf.Graf.log" title="Permalink to this definition">¶</a></dt>
<dd><p>handle of a log file, open for writing</p>
</dd></dl>

<dl class="attribute">
<dt id="graf.graf.Graf.node_feat">
<tt class="descname">node_feat</tt><em class="property"> = None</em><a class="headerlink" href="#graf.graf.Graf.node_feat" title="Permalink to this definition">¶</a></dt>
<dd><p>Feature data (for features on nodes) stored in dictionary for fast access</p>
</dd></dl>

<dl class="method">
<dt id="graf.graf.Graf.progress">
<tt class="descname">progress</tt><big>(</big><em>msg</em><big>)</big><a class="reference internal" href="../_modules/graf/graf.html#Graf.progress"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.graf.Graf.progress" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience method to call the progress of the associated stamp directly from the Graf object</p>
</dd></dl>

<dl class="method">
<dt id="graf.graf.Graf.read_stats">
<tt class="descname">read_stats</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/graf/graf.html#Graf.read_stats"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.graf.Graf.read_stats" title="Permalink to this definition">¶</a></dt>
<dd><p>Read compilation statistics from file</p>
<p>The compile process generates some statistics that must be read by the task that loads the compiled data.</p>
</dd></dl>

<dl class="method">
<dt id="graf.graf.Graf.set_environment">
<tt class="descname">set_environment</tt><big>(</big><em>source</em>, <em>task</em><big>)</big><a class="reference internal" href="../_modules/graf/graf.html#Graf.set_environment"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.graf.Graf.set_environment" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the source and result locations for a task execution.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>source</strong> (<em>str</em>) &#8211;
key for the source</li>
<li><strong>task</strong> &#8211;
the chosen task</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Sets <em>self.env</em>, a dictionary containg:</p>
<ul class="simple">
<li>source: <em>source</em></li>
<li>task: <em>task</em></li>
<li>compile (bool): whether to force (re)compilation</li>
<li>settings (<a class="reference external" href="http://docs.python.org/library/configparser.html#ConfigParser.ConfigParser" title="(in Python v2.7)"><tt class="xref py py-class docutils literal"><span class="pre">ConfigParser.ConfigParser</span></tt></a>): entries corresponding to the main configuration file</li>
<li>additional computed settings adapt to the current source and task</li>
</ul>
</dd></dl>

<dl class="attribute">
<dt id="graf.graf.Graf.stamp">
<tt class="descname">stamp</tt><em class="property"> = None</em><a class="headerlink" href="#graf.graf.Graf.stamp" title="Permalink to this definition">¶</a></dt>
<dd><p>Instance member holding the <a class="reference internal" href="#graf.timestamp.Timestamp" title="graf.timestamp.Timestamp"><tt class="xref py py-class docutils literal"><span class="pre">Timestamp</span></tt></a> object.</p>
</dd></dl>

<dl class="method">
<dt id="graf.graf.Graf.write_stats">
<tt class="descname">write_stats</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/graf/graf.html#Graf.write_stats"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.graf.Graf.write_stats" title="Permalink to this definition">¶</a></dt>
<dd><p>Write compilation statistics to file</p>
<p>The compile process generates some statistics that must be read by the task that loads the compiled data.</p>
</dd></dl>

</dd></dl>

<dl class="exception">
<dt id="graf.graf.GrafException">
<em class="property">exception </em><tt class="descname">GrafException</tt><big>(</big><em>message</em>, <em>stamp</em>, <em>Errors</em><big>)</big><a class="reference internal" href="../_modules/graf/graf.html#GrafException"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.graf.GrafException" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">exceptions.Exception</span></tt></p>
</dd></dl>

</div>
<div class="section" id="module-graf.model">
<span id="graf-model-module"></span><h2>graf.model module<a class="headerlink" href="#module-graf.model" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="graf.model.arrayify">
<tt class="descname">arrayify</tt><big>(</big><em>source_list</em><big>)</big><a class="reference internal" href="../_modules/graf/model.html#arrayify"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.model.arrayify" title="Permalink to this definition">¶</a></dt>
<dd><p>Efficient storage of a list of lists of integers in two Python <a class="reference external" href="http://docs.python.org/library/array.html#module-array" title="(in Python v2.7)"><tt class="xref py py-mod docutils literal"><span class="pre">array</span></tt></a>.</p>
<p><em>This is one of the most important tricks of the whole workbench, and yet it is only 10 lines of code!</em></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>source_list</strong> (<em>iterable</em>) &#8211;
a list of lists of integers</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><em>(index_array, items_array)</em> &#8211;
two <a class="reference external" href="http://docs.python.org/library/array.html#module-array" title="(in Python v2.7)"><tt class="xref py py-mod docutils literal"><span class="pre">array</span></tt></a> s.
<em>index_array</em> contains an index for each item in <em>source_list</em>.
<em>items_array</em> contains all the items in the following way: if an item with <em>n</em> members has to be added,
then first the number <em>n</em> is added, and then all the members.
This is how you get the original information back: if you want the
members of item <em>i</em> in <em>source_list</em>, read number <em>i</em> in <em>index_array</em>, say <em>k</em>, go to position <em>k</em> in
<em>items_array</em>, read the number at that position, say <em>n</em>,
and then find the members at the next <em>n</em> positions in <em>items_array</em>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="graf.model.model">
<tt class="descname">model</tt><big>(</big><em>data_items</em>, <em>temp_data_items</em>, <em>stamp</em><big>)</big><a class="reference internal" href="../_modules/graf/model.html#model"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.model.model" title="Permalink to this definition">¶</a></dt>
<dd><p>Remodels various data structures</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data_items</strong> &#8211;
data structures coming from <a class="reference internal" href="#module-graf.parse" title="graf.parse"><tt class="xref py py-mod docutils literal"><span class="pre">parse</span></tt></a>, that are here to stay</li>
<li><strong>temp_data_items</strong> &#8211;
data structures coming from <a class="reference internal" href="#module-graf.parse" title="graf.parse"><tt class="xref py py-mod docutils literal"><span class="pre">parse</span></tt></a> that may be thrown away</li>
<li><strong>stamp (</strong> &#8211;
class:<cite>Timestamp &lt;graf.Timestamp&gt;</cite>): object for issuing progress messages</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">The resulting permanent remodelled data structures.</p>
</td>
</tr>
</tbody>
</table>
<p>Function</p>
</dd></dl>

</div>
<div class="section" id="module-graf.parse">
<span id="graf-parse-module"></span><h2>graf.parse module<a class="headerlink" href="#module-graf.parse" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="graf.parse.AnnotationHandler">
<em class="property">class </em><tt class="descname">AnnotationHandler</tt><big>(</big><em>annotation_file</em>, <em>stamp</em><big>)</big><a class="reference internal" href="../_modules/graf/parse.html#AnnotationHandler"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.parse.AnnotationHandler" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="http://docs.python.org/library/xml.sax.handler.html#xml.sax.handler.ContentHandler" title="(in Python v2.7)"><tt class="xref py py-class docutils literal"><span class="pre">xml.sax.handler.ContentHandler</span></tt></a></p>
<p>Handlers used by SAX parsing the annotation files themselves</p>
<p>We have to collect all elements <em>region</em>, <em>node</em> and subelement <em>link</em>, <em>edge</em>, <em>a</em> (annotation) and <em>f</em> (feature).
From these elements we retrieve identifiers and other attributes. we map all identifiers to integers. When we have to associate one piece of data to other pieces, we create arrays of those integers.</p>
<p>The parse process is robust, we are not dependent on a particular ordering or distribution of the regions, nodes, edges, annotations and features in/over the annotation files.</p>
<p>Here is a description of the arrays we create:</p>
<dl class="docutils">
<dt><em>region_begin</em>, <em>region_end</em></dt>
<dd>Every region has an <em>anchors</em> attribute specifying a point or interval in the primary data. We consider a point <em>i</em> as the interval <em>i .. i</em>.
<em>region_begin</em> contains the start anchor of region <em>i</em> for each <em>i</em>, and <em>region_end</em> the end anchor.</dd>
<dt><em>edges_from</em>, <em>edges_to</em></dt>
<dd>Every edge goes from one node to an other. <em>edges_from</em> contains the from node of edge <em>i</em> for each <em>i</em>, and <em>edges_end</em> the to node.</dd>
</dl>
<p>Here is a description of the dictionaries we create:</p>
<dl class="docutils">
<dt><em>feat_name_list_node_rep</em>, <em>feat_name_list_edge_rep</em>, <em>feat_name_list_node_int</em>, <em>feat_name_list_edge_int</em></dt>
<dd>Mappings from the string representations to the internal codes and vice versa, respectively, for feature names.
These are the <em>extended</em> feature names, i.e. with the label of the annotation in which the feature occurs prepended to it (separated with a <tt class="docutils literal"><span class="pre">.</span></tt>).
Features for nodes occupy and features for edges occupy separate but similar datastructures.</dd>
<dt><em>feat_value_list_rep</em>, <em>feat_value_list_int</em></dt>
<dd>Mappings from the string representations to the internal codes and vice versa, respectively, for feature values.</dd>
</dl>
<p>There is also a list of arrays:</p>
<dl class="docutils">
<dt><em>node_region_list</em></dt>
<dd>Element <em>i</em> of this list contains an array with the regions attached to node <em>i</em>.</dd>
</dl>
<dl class="attribute">
<dt id="graf.parse.AnnotationHandler.aid">
<tt class="descname">aid</tt><em class="property"> = None</em><a class="headerlink" href="#graf.parse.AnnotationHandler.aid" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="graf.parse.AnnotationHandler.alabel">
<tt class="descname">alabel</tt><em class="property"> = None</em><a class="headerlink" href="#graf.parse.AnnotationHandler.alabel" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="graf.parse.AnnotationHandler.aref">
<tt class="descname">aref</tt><em class="property"> = None</em><a class="headerlink" href="#graf.parse.AnnotationHandler.aref" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="graf.parse.AnnotationHandler.atype">
<tt class="descname">atype</tt><em class="property"> = None</em><a class="headerlink" href="#graf.parse.AnnotationHandler.atype" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="graf.parse.AnnotationHandler.characters">
<tt class="descname">characters</tt><big>(</big><em>ch</em><big>)</big><a class="reference internal" href="../_modules/graf/parse.html#AnnotationHandler.characters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.parse.AnnotationHandler.characters" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="graf.parse.AnnotationHandler.endElement">
<tt class="descname">endElement</tt><big>(</big><em>name</em><big>)</big><a class="reference internal" href="../_modules/graf/parse.html#AnnotationHandler.endElement"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.parse.AnnotationHandler.endElement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="graf.parse.AnnotationHandler.file_name">
<tt class="descname">file_name</tt><em class="property"> = None</em><a class="headerlink" href="#graf.parse.AnnotationHandler.file_name" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="graf.parse.AnnotationHandler.nid">
<tt class="descname">nid</tt><em class="property"> = None</em><a class="headerlink" href="#graf.parse.AnnotationHandler.nid" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="graf.parse.AnnotationHandler.node_link">
<tt class="descname">node_link</tt><em class="property"> = None</em><a class="headerlink" href="#graf.parse.AnnotationHandler.node_link" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="graf.parse.AnnotationHandler.stamp">
<tt class="descname">stamp</tt><em class="property"> = None</em><a class="headerlink" href="#graf.parse.AnnotationHandler.stamp" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="graf.parse.AnnotationHandler.startElement">
<tt class="descname">startElement</tt><big>(</big><em>name</em>, <em>attrs</em><big>)</big><a class="reference internal" href="../_modules/graf/parse.html#AnnotationHandler.startElement"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.parse.AnnotationHandler.startElement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="graf.parse.HeaderHandler">
<em class="property">class </em><tt class="descname">HeaderHandler</tt><big>(</big><em>stamp</em><big>)</big><a class="reference internal" href="../_modules/graf/parse.html#HeaderHandler"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.parse.HeaderHandler" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference external" href="http://docs.python.org/library/xml.sax.handler.html#xml.sax.handler.ContentHandler" title="(in Python v2.7)"><tt class="xref py py-class docutils literal"><span class="pre">xml.sax.handler.ContentHandler</span></tt></a></p>
<p>Handlers used by SAX parsing the GrAF header file.</p>
<p>We just collect the contents of the <em>loc</em> attributes of the <em>annotation</em> elements.
These are the annotation files that we have to fetch and compile.</p>
<dl class="method">
<dt id="graf.parse.HeaderHandler.characters">
<tt class="descname">characters</tt><big>(</big><em>ch</em><big>)</big><a class="reference internal" href="../_modules/graf/parse.html#HeaderHandler.characters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.parse.HeaderHandler.characters" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="graf.parse.HeaderHandler.endElement">
<tt class="descname">endElement</tt><big>(</big><em>name</em><big>)</big><a class="reference internal" href="../_modules/graf/parse.html#HeaderHandler.endElement"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.parse.HeaderHandler.endElement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="graf.parse.HeaderHandler.stamp">
<tt class="descname">stamp</tt><em class="property"> = None</em><a class="headerlink" href="#graf.parse.HeaderHandler.stamp" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="graf.parse.HeaderHandler.startElement">
<tt class="descname">startElement</tt><big>(</big><em>name</em>, <em>attrs</em><big>)</big><a class="reference internal" href="../_modules/graf/parse.html#HeaderHandler.startElement"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.parse.HeaderHandler.startElement" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="graf.parse.add_feature_instance">
<tt class="descname">add_feature_instance</tt><big>(</big><em>atype</em>, <em>name</em>, <em>aref</em>, <em>value</em><big>)</big><a class="reference internal" href="../_modules/graf/parse.html#add_feature_instance"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.parse.add_feature_instance" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="function">
<dt id="graf.parse.parse">
<tt class="descname">parse</tt><big>(</big><em>graf_header_file</em>, <em>stamp</em><big>)</big><a class="reference internal" href="../_modules/graf/parse.html#parse"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.parse.parse" title="Permalink to this definition">¶</a></dt>
<dd><p>Parse a GrAF resource.</p>
<p>Parses a GrAF resource, starting by SAX parsing its header file and subsequently parsing all
files mentioned in that header file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>graf_header_file</strong> (<em>str</em>) &#8211;
path to the GrAF header file</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">a tuple of items which comprise the parse results.</td>
</tr>
</tbody>
</table>
<p>Every member of the returned tuple is itself a tuple of 3 pieces of information:</p>
<ol class="arabic simple">
<li>A <em>key</em> which acts as a name for this part of the result data</li>
<li>The data itself, as described in <a class="reference internal" href="#graf.parse.AnnotationHandler" title="graf.parse.AnnotationHandler"><tt class="xref py py-class docutils literal"><span class="pre">AnnotationHandler</span></tt></a></li>
<li>A boolean indicating whether this data is a temporary result or a permanent result</li>
</ol>
<p>Temporary results will be discarded after the remodeling step, permanent results will be incorporated in
the task-executing object.</p>
</dd></dl>

</div>
<div class="section" id="module-graf.shell">
<span id="graf-shell-module"></span><h2>graf.shell module<a class="headerlink" href="#module-graf.shell" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="graf.shell.Shell">
<em class="property">class </em><tt class="descname">Shell</tt><a class="reference internal" href="../_modules/graf/shell.html#Shell"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.shell.Shell" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Execute tasks, either in a single run, or with an interactive prompt.</p>
<p>This class knows about the environment, such as command line arguments
and configuration files.
It collects those information pieces and passes them in suitable form
to the factual task processor.</p>
<p>Upon creation, create a <a class="reference internal" href="#graf.task.GrafTask" title="graf.task.GrafTask"><tt class="xref py py-class docutils literal"><span class="pre">GrafTask</span></tt></a> object based on settings.</p>
<dl class="method">
<dt id="graf.shell.Shell.command_loop">
<tt class="descname">command_loop</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/graf/shell.html#Shell.command_loop"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.shell.Shell.command_loop" title="Permalink to this definition">¶</a></dt>
<dd><p>Command prompt for repeated running of tasks.</p>
</dd></dl>

<dl class="attribute">
<dt id="graf.shell.Shell.cur">
<tt class="descname">cur</tt><em class="property"> = None</em><a class="headerlink" href="#graf.shell.Shell.cur" title="Permalink to this definition">¶</a></dt>
<dd><p>Holds the current selection: the <em>source</em>, the <em>task</em> and the <em>force_compile</em> option, in that order.</p>
</dd></dl>

<dl class="attribute">
<dt id="graf.shell.Shell.default">
<tt class="descname">default</tt><em class="property"> = None</em><a class="headerlink" href="#graf.shell.Shell.default" title="Permalink to this definition">¶</a></dt>
<dd><p>Defaults for the selectable items: <em>source</em> and <em>task</em>.
If the user does not pass values for them both on the command lines, these ones are used.
If the user does pass some of these values and the command prompt is started, the
command line values are parsed here, and the command prompt will use them as initial values.</p>
</dd></dl>

<dl class="method">
<dt id="graf.shell.Shell.do_command">
<tt class="descname">do_command</tt><big>(</big><em>prompt</em>, <em>choices</em>, <em>helpstr</em><big>)</big><a class="reference internal" href="../_modules/graf/shell.html#Shell.do_command"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.shell.Shell.do_command" title="Permalink to this definition">¶</a></dt>
<dd><p>Prompts the user to enter a command and dispatches it, if correct.</p>
<p>This method asks the user for a command consisting of a single letter.
It checks whether the letter is a legal option.
It add options for quitting (Esc) and displaying help (?).
If he user enters <tt class="docutils literal"><span class="pre">?</span></tt>, the helpstring is displayed.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>prompt</strong> (<em>str</em>) &#8211;
the prompt string to be displayed.
This string will be extenden with a description of the allowed keys to press.</li>
<li><strong>choices</strong> (<em>str</em>) &#8211;
a string consisting of legal  one letter commands, not separated.</li>
<li><strong>helpstr</strong> (<em>str</em>) &#8211;
help string to be displayed if the user presses <tt class="docutils literal"><span class="pre">?</span></tt></li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>command</strong> (<em>str</em>) &#8211;
the command entered by the user, or <tt class="docutils literal"><span class="pre">None</span></tt> if escape has been pressed.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="graf.shell.Shell.get_ch">
<tt class="descname">get_ch</tt><big>(</big><em>prompt=''</em><big>)</big><a class="reference internal" href="../_modules/graf/shell.html#Shell.get_ch"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.shell.Shell.get_ch" title="Permalink to this definition">¶</a></dt>
<dd><p>Asks for unbuffered single character input, with an optional prompt.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>prompt</strong> (<em>str</em>) &#8211;
Optional text to be displayed as prompt.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>ch</strong> (<em>char</em>) &#8211;
character pressed by the user.
If something gets wrong, returns the <em>Esc</em> character.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="graf.shell.Shell.get_num">
<tt class="descname">get_num</tt><big>(</big><em>prompt</em>, <em>start</em>, <em>end</em><big>)</big><a class="reference internal" href="../_modules/graf/shell.html#Shell.get_num"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.shell.Shell.get_num" title="Permalink to this definition">¶</a></dt>
<dd><p>Asks for a numeric value, and checks whether teh value is in a legal range.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>prompt</strong> (<em>str</em>) &#8211;
prompt to be displayed</li>
<li><strong>start</strong> (<em>str</em>) &#8211;
minimum legal value</li>
<li><strong>end</strong> (<em>str</em>) &#8211;
maximum legal value</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>number</strong> (<em>int</em>) &#8211;
the number if the user entered something legal,
and <tt class="docutils literal"><span class="pre">None</span></tt> otherwise.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="graf.shell.Shell.main_command">
<tt class="descname">main_command</tt><big>(</big><em>command</em><big>)</big><a class="reference internal" href="../_modules/graf/shell.html#Shell.main_command"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.shell.Shell.main_command" title="Permalink to this definition">¶</a></dt>
<dd><p>Interprets a top level command.</p>
<p>Depending on the command passed, this methods prompts for additional information.
This happens for the commands that modify the source and task selection.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>command</strong> (<em>char</em>) &#8211;
the command character.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>message</strong> (<em>str</em>) &#8211;
response text after the command execution.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="graf.shell.Shell.message">
<tt class="descname">message</tt><em class="property"> = None</em><a class="headerlink" href="#graf.shell.Shell.message" title="Permalink to this definition">¶</a></dt>
<dd><p>Response messages to be displayed after the prompt</p>
</dd></dl>

<dl class="method">
<dt id="graf.shell.Shell.processor">
<tt class="descname">processor</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/graf/shell.html#Shell.processor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.shell.Shell.processor" title="Permalink to this definition">¶</a></dt>
<dd><p>Does work. Decides to run one task or start the command prompt.</p>
<p>The decision is based on the presence of command line arguments.
If all arguments are present to specify a task, the <em>run once</em> option will be chosen,
unless the user has explicitly stated <tt class="docutils literal"><span class="pre">--menu</span></tt>.
Otherwise the command prompt is started. If that is the case, the
command line args that did come through, are used as initial values.</p>
</dd></dl>

<dl class="method">
<dt id="graf.shell.Shell.prompt">
<tt class="descname">prompt</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/graf/shell.html#Shell.prompt"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.shell.Shell.prompt" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes an self-explanatory prompt text to the terminal.</p>
</dd></dl>

<dl class="method">
<dt id="graf.shell.Shell.weave">
<tt class="descname">weave</tt><big>(</big><em>data</em><big>)</big><a class="reference internal" href="../_modules/graf/shell.html#Shell.weave"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.shell.Shell.weave" title="Permalink to this definition">¶</a></dt>
<dd><p>Utility value that prepares data for presenting several columns of options
on a terminal screen.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>data</strong> (<em>lists of lists</em>) &#8211;
corresponds to a number of lists of options.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>woven</strong> (<em>list of lists</em>) &#8211;
correponds to a table where columns are the lists of options
and the options occupy rows. The outermost list are the rows.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>index</strong> (<em>dict of dict</em>) &#8211;
given column number and then row number as keys yields the
name of the item at that slot</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>iindex</strong> (<em>dict of dict</em>) &#8211;
given column number and then the name of an item as keys yields the
row number of that item</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-graf.task">
<span id="graf-task-module"></span><h2>graf.task module<a class="headerlink" href="#module-graf.task" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="graf.task.GrafTask">
<em class="property">class </em><tt class="descname">GrafTask</tt><big>(</big><em>settings</em><big>)</big><a class="reference internal" href="../_modules/graf/task.html#GrafTask"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.task.GrafTask" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#graf.graf.Graf" title="graf.graf.Graf"><tt class="xref py py-class docutils literal"><span class="pre">graf.graf.Graf</span></tt></a></p>
<p>Task processor.</p>
<p>A task processor must know how to compile, where the source data is and where the result is going to.
And it must be able to <a class="reference external" href="http://docs.python.org/reference/simple_stmts.html#import" title="(in Python v2.7)"><tt class="xref std std-keyword docutils literal"><span class="pre">import</span></tt></a>: and <a class="reference external" href="http://docs.python.org/library/functions.html#reload" title="(in Python v2.7)"><tt class="xref py py-func docutils literal"><span class="pre">reload()</span></tt></a>: the tasks.
To that end the search path for modules will be adapted according to the <em>task_dir</em> setting
in the main configuration file.</p>
<p>Upon creation, the configuration settings are store in the object as is</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>settings (</strong> &#8211;
py:class:<cite>ConfigParser.ConfigParser</cite>): entries corresponding to the main configuration file</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="graf.task.GrafTask.FEi">
<tt class="descname">FEi</tt><big>(</big><em>edge</em>, <em>name</em><big>)</big><a class="reference internal" href="../_modules/graf/task.html#GrafTask.FEi"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.task.GrafTask.FEi" title="Permalink to this definition">¶</a></dt>
<dd><p>Edge feature value lookup returning the value string representation.</p>
</dd></dl>

<dl class="method">
<dt id="graf.task.GrafTask.FEr">
<tt class="descname">FEr</tt><big>(</big><em>edge</em>, <em>name</em><big>)</big><a class="reference internal" href="../_modules/graf/task.html#GrafTask.FEr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.task.GrafTask.FEr" title="Permalink to this definition">¶</a></dt>
<dd><p>Edge feature value lookup returning the value string representation.
See method <a class="reference internal" href="#graf.task.GrafTask.FEi" title="graf.task.GrafTask.FEi"><tt class="xref py py-meth docutils literal"><span class="pre">FEi()</span></tt></a>.</p>
</dd></dl>

<dl class="method">
<dt id="graf.task.GrafTask.FNi">
<tt class="descname">FNi</tt><big>(</big><em>node</em>, <em>name</em><big>)</big><a class="reference internal" href="../_modules/graf/task.html#GrafTask.FNi"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.task.GrafTask.FNi" title="Permalink to this definition">¶</a></dt>
<dd><p>Node feature value lookup returning the value string representation.</p>
</dd></dl>

<dl class="method">
<dt id="graf.task.GrafTask.FNr">
<tt class="descname">FNr</tt><big>(</big><em>node</em>, <em>name</em><big>)</big><a class="reference internal" href="../_modules/graf/task.html#GrafTask.FNr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.task.GrafTask.FNr" title="Permalink to this definition">¶</a></dt>
<dd><p>Node feature value lookup returning the value string representation.
See method <a class="reference internal" href="#graf.task.GrafTask.FNi" title="graf.task.GrafTask.FNi"><tt class="xref py py-meth docutils literal"><span class="pre">FNi()</span></tt></a>.</p>
</dd></dl>

<dl class="method">
<dt id="graf.task.GrafTask.__del__">
<tt class="descname">__del__</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/graf/task.html#GrafTask.__del__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.task.GrafTask.__del__" title="Permalink to this definition">¶</a></dt>
<dd><p>Upon destruction, all file handles used by the task will be closed.</p>
</dd></dl>

<dl class="method">
<dt id="graf.task.GrafTask.add_result">
<tt class="descname">add_result</tt><big>(</big><em>file_name</em><big>)</big><a class="reference internal" href="../_modules/graf/task.html#GrafTask.add_result"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.task.GrafTask.add_result" title="Permalink to this definition">¶</a></dt>
<dd><p>Opens a file for writing and stores the handle.</p>
<p>Every task is advised to use this method for opening files for its output.
The file will be closed by the workbench when the task terminates.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>file_name</strong> (<em>str</em>) &#8211;
name of the output file.</li>
<li><strong>Its location is the result directory for this task and this source.</strong></li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A handle to the opened file.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="graf.task.GrafTask.common_loader">
<tt class="descname">common_loader</tt><big>(</big><em>source</em><big>)</big><a class="reference internal" href="../_modules/graf/task.html#GrafTask.common_loader"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.task.GrafTask.common_loader" title="Permalink to this definition">¶</a></dt>
<dd><p>Manage the common data to be loaded.</p>
<p>Common data is data  common to all tasks but specific to a source.</p>
</dd></dl>

<dl class="method">
<dt id="graf.task.GrafTask.compile">
<tt class="descname">compile</tt><big>(</big><em>force_compile</em><big>)</big><a class="reference internal" href="../_modules/graf/task.html#GrafTask.compile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.task.GrafTask.compile" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="graf.task.GrafTask.feature_loader">
<tt class="descname">feature_loader</tt><big>(</big><em>directives</em><big>)</big><a class="reference internal" href="../_modules/graf/task.html#GrafTask.feature_loader"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.task.GrafTask.feature_loader" title="Permalink to this definition">¶</a></dt>
<dd><p>Manage the feature data to be loaded.</p>
<p>The specification of which features are selected is still a string.
Here we compile it into a dictionary <em>only</em>, keyed with the extended feature name.</p>
<p>The loaded features together form a dictionary, keyed with the extended feature name.
The values are dictionaries keyed by the element, with as values the feature values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>directives</strong> (<em>dict</em>) &#8211;
dictionary of strings string specifying the features selected for feature loading.
There are two keys: <em>node</em> and <em>edge</em>, because node features and edge features are handled separately.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="graf.task.GrafTask.finish_task">
<tt class="descname">finish_task</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/graf/task.html#GrafTask.finish_task"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.task.GrafTask.finish_task" title="Permalink to this definition">¶</a></dt>
<dd><p>Finalizes the current task.</p>
<p>There will be a progress message, and a directory listing of the result directory,
for the convenience of the user.</p>
</dd></dl>

<dl class="method">
<dt id="graf.task.GrafTask.get_mappings">
<tt class="descname">get_mappings</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/graf/task.html#GrafTask.get_mappings"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.task.GrafTask.get_mappings" title="Permalink to this definition">¶</a></dt>
<dd><p>Return references to API methods of this class.</p>
<p>The caller can give convenient, local names to these methods.
It also saves method lookup,
at least, I think so.</p>
</dd></dl>

<dl class="method">
<dt id="graf.task.GrafTask.getitems">
<tt class="descname">getitems</tt><big>(</big><em>data</em>, <em>data_items</em>, <em>elem</em><big>)</big><a class="reference internal" href="../_modules/graf/task.html#GrafTask.getitems"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.task.GrafTask.getitems" title="Permalink to this definition">¶</a></dt>
<dd><p>Get related items from an arrayified data structure.</p>
<p>If a relation between integers and sets of integers has been stored as a double array
by the <a class="reference internal" href="#graf.model.arrayify" title="graf.model.arrayify"><tt class="xref py py-func docutils literal"><span class="pre">arrayify()</span></tt></a> function,
this is the way to look up the set of related integers for each integer.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<em>array</em>) &#8211;
see next</li>
<li><strong>data_items</strong> (<em>array</em>) &#8211;
together with <em>data</em> the arrayified data</li>
<li><strong>elem</strong> (<em>int</em>) &#8211;
the integer for which we want its related set of integers.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a list of the related integers.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="graf.task.GrafTask.has_compiled">
<tt class="descname">has_compiled</tt><em class="property"> = None</em><a class="headerlink" href="#graf.task.GrafTask.has_compiled" title="Permalink to this definition">¶</a></dt>
<dd><p>Instance member to tell whether compilation has actually taken place</p>
</dd></dl>

<dl class="method">
<dt id="graf.task.GrafTask.hasitem">
<tt class="descname">hasitem</tt><big>(</big><em>data</em>, <em>data_items</em>, <em>elem</em>, <em>item</em><big>)</big><a class="reference internal" href="../_modules/graf/task.html#GrafTask.hasitem"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.task.GrafTask.hasitem" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether an integer is in the set of related items
with respect to an arrayified data structure (see also <a class="reference internal" href="#graf.task.GrafTask.getitems" title="graf.task.GrafTask.getitems"><tt class="xref py py-meth docutils literal"><span class="pre">getitems()</span></tt></a>).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<em>array</em>) &#8211;
see next</li>
<li><strong>data_items</strong> (<em>array</em>) &#8211;
together with <em>data</em> the arrayified data</li>
<li><strong>elem</strong> (<em>int</em>) &#8211;
the integer for which we want its related set of integers.</li>
<li><strong>item</strong> (<em>int</em>) &#8211;
the integer whose presence in the related items set is to be tested.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><em>bool</em> &#8211;
whether the integer is in the related set or not.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="graf.task.GrafTask.hasitems">
<tt class="descname">hasitems</tt><big>(</big><em>data</em>, <em>data_items</em>, <em>elem</em>, <em>items</em><big>)</big><a class="reference internal" href="../_modules/graf/task.html#GrafTask.hasitems"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.task.GrafTask.hasitems" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether a set of integers intersects with the set of related items
with respect to an arrayified data structure (see also <a class="reference internal" href="#graf.task.GrafTask.getitems" title="graf.task.GrafTask.getitems"><tt class="xref py py-meth docutils literal"><span class="pre">getitems()</span></tt></a>).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<em>array</em>) &#8211;
see next</li>
<li><strong>data_items</strong> (<em>array</em>) &#8211;
together with <em>data</em> the arrayified data</li>
<li><strong>elem</strong> (<em>int</em>) &#8211;
the integer for which we want its related set of integers.</li>
<li><strong>items</strong> (<em>array or list of integers</em>) &#8211;
the set of integers</li>
<li><strong>whose presence in the related items set is to be tested.</strong></li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><em>bool</em> &#8211;
whether one of the integers is in the related set or not.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="graf.task.GrafTask.init_task">
<tt class="descname">init_task</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/graf/task.html#GrafTask.init_task"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.task.GrafTask.init_task" title="Permalink to this definition">¶</a></dt>
<dd><p>Initializes the current task.</p>
<p>Very trivial initialization: just issue a progress message.</p>
</dd></dl>

<dl class="method">
<dt id="graf.task.GrafTask.int_fname_edge">
<tt class="descname">int_fname_edge</tt><big>(</big><em>rep</em><big>)</big><a class="reference internal" href="../_modules/graf/task.html#GrafTask.int_fname_edge"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.task.GrafTask.int_fname_edge" title="Permalink to this definition">¶</a></dt>
<dd><p>API: <em>feature name</em> (on edges) conversion from string representation as found in LAF resource
to corresponding integer as used in compiled resource.</p>
</dd></dl>

<dl class="method">
<dt id="graf.task.GrafTask.int_fname_node">
<tt class="descname">int_fname_node</tt><big>(</big><em>rep</em><big>)</big><a class="reference internal" href="../_modules/graf/task.html#GrafTask.int_fname_node"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.task.GrafTask.int_fname_node" title="Permalink to this definition">¶</a></dt>
<dd><p>API: <em>feature name</em> (on nodes) conversion from string representation as found in LAF resource
to corresponding integer as used in compiled resource.</p>
</dd></dl>

<dl class="method">
<dt id="graf.task.GrafTask.int_fval">
<tt class="descname">int_fval</tt><big>(</big><em>rep</em><big>)</big><a class="reference internal" href="../_modules/graf/task.html#GrafTask.int_fval"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.task.GrafTask.int_fval" title="Permalink to this definition">¶</a></dt>
<dd><p>API: <em>feature value</em> conversion from string representation as found in LAF resource
to corresponding integer as used in compiled resource.</p>
</dd></dl>

<dl class="attribute">
<dt id="graf.task.GrafTask.loaded">
<tt class="descname">loaded</tt><em class="property"> = defaultdict(&lt;function &lt;lambda&gt; at 0x1026b8848&gt;, {})</em><a class="headerlink" href="#graf.task.GrafTask.loaded" title="Permalink to this definition">¶</a></dt>
<dd><p>Set of feature data sets that have been loaded, node features and edge features under different keys</p>
</dd></dl>

<dl class="method">
<dt id="graf.task.GrafTask.loader">
<tt class="descname">loader</tt><big>(</big><em>source</em>, <em>task</em>, <em>directives</em><big>)</big><a class="reference internal" href="../_modules/graf/task.html#GrafTask.loader"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.task.GrafTask.loader" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads compiled LAF data.</p>
<p>There are two kinds of data to be loaded:</p>
<dl class="docutils">
<dt><em>common data</em></dt>
<dd>Data that is common to all tasks, but dependent on the choice of source.
It is the data that holds the regions, nodes, edges, but not the features.</dd>
<dt><em>feature data</em></dt>
<dd>Data that is requested by the task at hand.
It is the data that holds feature information,
for those features that are requested by a task&#8217;s <em>feature</em> declaration.</dd>
</dl>
<p>The <em>common data</em> can be loaded in bulk fast, but it still takes 5 to 10 seconds,
and should be avoided if possible.
This data only needs to be loaded if the source has changed or if compilation has taken place.
It is taken care of by <a class="reference internal" href="#graf.task.GrafTask.common_loader" title="graf.task.GrafTask.common_loader"><tt class="xref py py-meth docutils literal"><span class="pre">common_loader()</span></tt></a>.</p>
<p>The <em>feature data</em> is loaded and unloaded on demand
and the feature manager method <a class="reference internal" href="#graf.task.GrafTask.feature_loader" title="graf.task.GrafTask.feature_loader"><tt class="xref py py-meth docutils literal"><span class="pre">feature_loader()</span></tt></a> takes care of that.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>directives</strong> (<em>dict</em>) &#8211;
a dictionary of information</li>
<li><strong>relevant to</strong> &#8211;
meth:<cite>common_loader</cite> and <a class="reference internal" href="#graf.task.GrafTask.feature_loader" title="graf.task.GrafTask.feature_loader"><tt class="xref py py-meth docutils literal"><span class="pre">feature_loader()</span></tt></a>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">directives are only used by <a class="reference internal" href="#graf.task.GrafTask.feature_loader" title="graf.task.GrafTask.feature_loader"><tt class="xref py py-meth docutils literal"><span class="pre">feature_loader()</span></tt></a>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="graf.task.GrafTask.next_node">
<tt class="descname">next_node</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/graf/task.html#GrafTask.next_node"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.task.GrafTask.next_node" title="Permalink to this definition">¶</a></dt>
<dd><p>API: iterator of all nodes in primary data order.</p>
<p>Each call <em>yields</em> the next node. The iterator walks through all nodes.
The order is implied by the attachment of nodes to the primary data,
which is itself linearly ordered.
This order is explained in the <a class="reference internal" href="../taskwriting.html#node-order"><em>guidelines for task writing</em></a>.</p>
</dd></dl>

<dl class="method">
<dt id="graf.task.GrafTask.next_node_with_fval">
<tt class="descname">next_node_with_fval</tt><big>(</big><em>name</em>, <em>value</em><big>)</big><a class="reference internal" href="../_modules/graf/task.html#GrafTask.next_node_with_fval"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.task.GrafTask.next_node_with_fval" title="Permalink to this definition">¶</a></dt>
<dd><p>API: iterator of all nodes in primary data order that have a
given value for a given feature.</p>
<p>See also <a class="reference internal" href="#graf.task.GrafTask.next_node" title="graf.task.GrafTask.next_node"><tt class="xref py py-meth docutils literal"><span class="pre">next_node()</span></tt></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> (<em>int</em>) &#8211;
the code of a feature name</li>
<li><strong>value</strong> (<em>int</em>) &#8211;
the code of a feature value</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="graf.task.GrafTask.rep_fname_edge">
<tt class="descname">rep_fname_edge</tt><big>(</big><em>intl</em><big>)</big><a class="reference internal" href="../_modules/graf/task.html#GrafTask.rep_fname_edge"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.task.GrafTask.rep_fname_edge" title="Permalink to this definition">¶</a></dt>
<dd><p>API: <em>feature name</em> (on edges) conversion from integer code as used in compiled LAF resource
to corresponding string representation as found in original LAF resource.</p>
</dd></dl>

<dl class="method">
<dt id="graf.task.GrafTask.rep_fname_node">
<tt class="descname">rep_fname_node</tt><big>(</big><em>intl</em><big>)</big><a class="reference internal" href="../_modules/graf/task.html#GrafTask.rep_fname_node"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.task.GrafTask.rep_fname_node" title="Permalink to this definition">¶</a></dt>
<dd><p>API: <em>feature name</em> (on nodes) conversion from integer code as used in compiled LAF resource
to corresponding string representation as found in original LAF resource.</p>
</dd></dl>

<dl class="method">
<dt id="graf.task.GrafTask.rep_fval">
<tt class="descname">rep_fval</tt><big>(</big><em>intl</em><big>)</big><a class="reference internal" href="../_modules/graf/task.html#GrafTask.rep_fval"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.task.GrafTask.rep_fval" title="Permalink to this definition">¶</a></dt>
<dd><p>API: <em>feature value</em> conversion from integer code as used in compiled LAF resource
to corresponding string representation as found in original LAF resource.</p>
</dd></dl>

<dl class="attribute">
<dt id="graf.task.GrafTask.result_files">
<tt class="descname">result_files</tt><em class="property"> = []</em><a class="headerlink" href="#graf.task.GrafTask.result_files" title="Permalink to this definition">¶</a></dt>
<dd><p>List of handles to result files created by the task through the method <a class="reference internal" href="#graf.task.GrafTask.add_result" title="graf.task.GrafTask.add_result"><tt class="xref py py-meth docutils literal"><span class="pre">add_result()</span></tt></a></p>
</dd></dl>

<dl class="method">
<dt id="graf.task.GrafTask.run">
<tt class="descname">run</tt><big>(</big><em>source</em>, <em>task</em>, <em>force_compile=False</em><big>)</big><a class="reference internal" href="../_modules/graf/task.html#GrafTask.run"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.task.GrafTask.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Run a task.</p>
<p>That is:
* Load the data
* (Re)load the task code
* Initialize the task
* Run tha task code
* Finalize the task</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>source</strong> (<em>str</em>) &#8211;
key for the source</li>
<li><strong>task</strong> &#8211;
the chosen task</li>
<li><strong>force_compile</strong> (<em>bool</em>) &#8211;
whether to force (re)compilation of the LAF source</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="graf.task.GrafTask.settings">
<tt class="descname">settings</tt><em class="property"> = None</em><a class="headerlink" href="#graf.task.GrafTask.settings" title="Permalink to this definition">¶</a></dt>
<dd><p>Instance member to hold configuration settings</p>
</dd></dl>

<dl class="attribute">
<dt id="graf.task.GrafTask.source_changed">
<tt class="descname">source_changed</tt><em class="property"> = None</em><a class="headerlink" href="#graf.task.GrafTask.source_changed" title="Permalink to this definition">¶</a></dt>
<dd><p>Instance member to tell whether the source name has changed</p>
</dd></dl>

<dl class="attribute">
<dt id="graf.task.GrafTask.task_changed">
<tt class="descname">task_changed</tt><em class="property"> = None</em><a class="headerlink" href="#graf.task.GrafTask.task_changed" title="Permalink to this definition">¶</a></dt>
<dd><p>Instance member to tell whether the task name has changed</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-graf.timestamp">
<span id="graf-timestamp-module"></span><h2>graf.timestamp module<a class="headerlink" href="#module-graf.timestamp" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="graf.timestamp.Timestamp">
<em class="property">class </em><tt class="descname">Timestamp</tt><big>(</big><em>log_file=None</em><big>)</big><a class="reference internal" href="../_modules/graf/timestamp.html#Timestamp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.timestamp.Timestamp" title="Permalink to this definition">¶</a></dt>
<dd><p>Time management.</p>
<p>Objects remember their creation time. So they can issue statements about how much time has been elapsed.
All timed log messages of the program should be issued through the <a class="reference internal" href="#graf.timestamp.Timestamp.progress" title="graf.timestamp.Timestamp.progress"><tt class="xref py py-meth docutils literal"><span class="pre">progress()</span></tt></a> method of this class.</p>
<p>It is also possible to connect a logfile to these objects.
When progress messages are issued, they are also written to the connected log file.</p>
<p>Upon creation, retrieves the time.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>log_file</strong> (<em>file</em>) &#8211;
open file handle for writing. Optional. If not <tt class="docutils literal"><span class="pre">None</span></tt> stores the handle in the object&#8217;s data.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="graf.timestamp.Timestamp.connect_log">
<tt class="descname">connect_log</tt><big>(</big><em>log_file</em><big>)</big><a class="reference internal" href="../_modules/graf/timestamp.html#Timestamp.connect_log"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.timestamp.Timestamp.connect_log" title="Permalink to this definition">¶</a></dt>
<dd><p>Connects a log file to the object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>log_file</strong> (<em>file</em>) &#8211;
open handle for writing.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="graf.timestamp.Timestamp.elapsed">
<tt class="descname">elapsed</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/graf/timestamp.html#Timestamp.elapsed"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.timestamp.Timestamp.elapsed" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the time elapsed since creation of the <a class="reference internal" href="#graf.timestamp.Timestamp" title="graf.timestamp.Timestamp"><tt class="xref py py-class docutils literal"><span class="pre">Timestamp</span></tt></a> object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A pretty formatted string, ready to include in a message.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="graf.timestamp.Timestamp.log">
<tt class="descname">log</tt><em class="property"> = None</em><a class="headerlink" href="#graf.timestamp.Timestamp.log" title="Permalink to this definition">¶</a></dt>
<dd><p>Instance member holding a handle to a logfile, open for writing, if a log file has been attached to the object.</p>
</dd></dl>

<dl class="method">
<dt id="graf.timestamp.Timestamp.progress">
<tt class="descname">progress</tt><big>(</big><em>msg</em>, <em>newline=True</em><big>)</big><a class="reference internal" href="../_modules/graf/timestamp.html#Timestamp.progress"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.timestamp.Timestamp.progress" title="Permalink to this definition">¶</a></dt>
<dd><p>API: issues a timed progress message.</p>
<p>The message is issued to the standard output, and, if a log file has been connected, also to the log file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>msg</strong> (<em>str</em>) &#8211;
text of the message</li>
<li><strong>newline</strong> (<em>bool</em>) &#8211;
whether or not to add a newline. Optional. Make it <tt class="docutils literal"><span class="pre">False</span></tt> to not add a newline.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="graf.timestamp.Timestamp.reset">
<tt class="descname">reset</tt><big>(</big><big>)</big><a class="reference internal" href="../_modules/graf/timestamp.html#Timestamp.reset"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#graf.timestamp.Timestamp.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the time to the current time</p>
</dd></dl>

<dl class="attribute">
<dt id="graf.timestamp.Timestamp.timestamp">
<tt class="descname">timestamp</tt><em class="property"> = None</em><a class="headerlink" href="#graf.timestamp.Timestamp.timestamp" title="Permalink to this definition">¶</a></dt>
<dd><p>Instance member holding the time the object was created</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-graf">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-graf" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="graf.Graf">
<em class="property">class </em><tt class="descname">Graf</tt><a class="headerlink" href="#graf.Graf" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Base class for compiling LAF resources and running analytic tasks on them.</p>
<p>This class has only a rudimentary method set. Compiling a LAF resource is done by the GrafCompiler derived class
and running analytic tasks is done by the GrafTask class.</p>
<p>The data of this class represents the compiled data on the basis of which tasks can run.
This data is created by a <a class="reference internal" href="#graf.compiler.GrafCompiler" title="graf.compiler.GrafCompiler"><tt class="xref py py-class docutils literal"><span class="pre">GrafCompiler</span></tt></a> that derives from this class.</p>
<p>Upon creation, empty datastructures are initialized to hold the binary,
compiled LAF data and create a directory for their serializations on disk.</p>
<p>The Graf object holds information that Graf tasks need to perform their operations.
The most important piece of information is the data itself.
This data consists of arrays and dictionaries that together hold the information that is compiled from a LAF resource.</p>
<p>Other things that happen:</p>
<ol class="arabic simple">
<li>a fresh Timestamp object is created, which records the current time and can issue progress messages containing the amount
of time that has elapsed since this object has been created.</li>
<li>if the directory that should hold the compiled data does not exist,
a new directory is created Of course this means that before executing any tasks,
the LAF resource has to be (re)compiled.</li>
</ol>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">object with data structures initialized, ready to load the compiled data from disk.</td>
</tr>
</tbody>
</table>
<dl class="attribute">
<dt id="graf.Graf.BIN_EXT">
<tt class="descname">BIN_EXT</tt><em class="property"> = 'bin'</em><a class="headerlink" href="#graf.Graf.BIN_EXT" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="graf.Graf.COMPILE_TASK">
<tt class="descname">COMPILE_TASK</tt><em class="property"> = 'compile'</em><a class="headerlink" href="#graf.Graf.COMPILE_TASK" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="graf.Graf.LOG_NAME">
<tt class="descname">LOG_NAME</tt><em class="property"> = '__log__'</em><a class="headerlink" href="#graf.Graf.LOG_NAME" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="graf.Graf.STAT_NAME">
<tt class="descname">STAT_NAME</tt><em class="property"> = '__stat__'</em><a class="headerlink" href="#graf.Graf.STAT_NAME" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="graf.Graf.TEXT_EXT">
<tt class="descname">TEXT_EXT</tt><em class="property"> = 'txt'</em><a class="headerlink" href="#graf.Graf.TEXT_EXT" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="graf.Graf.__del__">
<tt class="descname">__del__</tt><big>(</big><big>)</big><a class="headerlink" href="#graf.Graf.__del__" title="Permalink to this definition">¶</a></dt>
<dd><p>Clean up</p>
<p>Close all file handles that are still open.</p>
</dd></dl>

<dl class="method">
<dt id="graf.Graf.add_logfile">
<tt class="descname">add_logfile</tt><big>(</big><em>location=None</em>, <em>name=None</em><big>)</big><a class="headerlink" href="#graf.Graf.add_logfile" title="Permalink to this definition">¶</a></dt>
<dd><p>Create and open a log file for a given task.</p>
<p>When tasks run, they generate progress messages with timing information in them.
They may issue errors and warnings. All this information also goes into a log file.
The log file is placed in the result directory of the task at hand.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>location</strong> (<em>str</em>) &#8211;
override default directory for log file</li>
<li><strong>name</strong> (<em>str</em>) &#8211;
override default name for log file</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="graf.Graf.env">
<tt class="descname">env</tt><em class="property"> = None</em><a class="headerlink" href="#graf.Graf.env" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="graf.Graf.init_data">
<tt class="descname">init_data</tt><big>(</big><big>)</big><a class="headerlink" href="#graf.Graf.init_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Resets all loaded data to initial values</p>
<p>This is needed when the task processor switches from one source to another,
or when a recompile has been performed.</p>
</dd></dl>

<dl class="attribute">
<dt id="graf.Graf.log">
<tt class="descname">log</tt><em class="property"> = None</em><a class="headerlink" href="#graf.Graf.log" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="graf.Graf.progress">
<tt class="descname">progress</tt><big>(</big><em>msg</em><big>)</big><a class="headerlink" href="#graf.Graf.progress" title="Permalink to this definition">¶</a></dt>
<dd><p>Convenience method to call the progress of the associated stamp directly from the Graf object</p>
</dd></dl>

<dl class="method">
<dt id="graf.Graf.read_stats">
<tt class="descname">read_stats</tt><big>(</big><big>)</big><a class="headerlink" href="#graf.Graf.read_stats" title="Permalink to this definition">¶</a></dt>
<dd><p>Read compilation statistics from file</p>
<p>The compile process generates some statistics that must be read by the task that loads the compiled data.</p>
</dd></dl>

<dl class="method">
<dt id="graf.Graf.set_environment">
<tt class="descname">set_environment</tt><big>(</big><em>source</em>, <em>task</em><big>)</big><a class="headerlink" href="#graf.Graf.set_environment" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the source and result locations for a task execution.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>source</strong> (<em>str</em>) &#8211;
key for the source</li>
<li><strong>task</strong> &#8211;
the chosen task</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Sets <em>self.env</em>, a dictionary containg:</p>
<ul class="simple">
<li>source: <em>source</em></li>
<li>task: <em>task</em></li>
<li>compile (bool): whether to force (re)compilation</li>
<li>settings (<a class="reference external" href="http://docs.python.org/library/configparser.html#ConfigParser.ConfigParser" title="(in Python v2.7)"><tt class="xref py py-class docutils literal"><span class="pre">ConfigParser.ConfigParser</span></tt></a>): entries corresponding to the main configuration file</li>
<li>additional computed settings adapt to the current source and task</li>
</ul>
</dd></dl>

<dl class="attribute">
<dt id="graf.Graf.stamp">
<tt class="descname">stamp</tt><em class="property"> = None</em><a class="headerlink" href="#graf.Graf.stamp" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="graf.Graf.write_stats">
<tt class="descname">write_stats</tt><big>(</big><big>)</big><a class="headerlink" href="#graf.Graf.write_stats" title="Permalink to this definition">¶</a></dt>
<dd><p>Write compilation statistics to file</p>
<p>The compile process generates some statistics that must be read by the task that loads the compiled data.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="graf.GrafCompiler">
<em class="property">class </em><tt class="descname">GrafCompiler</tt><big>(</big><em>env</em><big>)</big><a class="headerlink" href="#graf.GrafCompiler" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#graf.graf.Graf" title="graf.graf.Graf"><tt class="xref py py-class docutils literal"><span class="pre">graf.graf.Graf</span></tt></a></p>
<p>Takes care of the compilation of LAF xml data into binary data.</p>
<p>There are two stages in compilation:</p>
<ul class="simple">
<li>parsing the XML data by means of a SAX parser (a lengthy process)</li>
<li>remodeling the parse results in really tight data structures</li>
</ul>
<p>Upon creation, the relevant directories are communicated.</p>
<p>The initialization of the base class is performed, and we change working directory to the location of the LAF source.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>env</strong> (<em>str</em>) &#8211;
path information</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="graf.GrafCompiler.compiler">
<tt class="descname">compiler</tt><big>(</big><em>force=False</em><big>)</big><a class="headerlink" href="#graf.GrafCompiler.compiler" title="Permalink to this definition">¶</a></dt>
<dd><p>Manages the complete compilation process.</p>
<p>Detects the need for compiling, responds to the <em>force</em> argument. Then parses, remodels and writes.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>force</strong> (<em>bool</em>) &#8211;
whether to compile even if the binary data looks up to date.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="graf.GrafCompiler.model">
<tt class="descname">model</tt><big>(</big><big>)</big><a class="headerlink" href="#graf.GrafCompiler.model" title="Permalink to this definition">¶</a></dt>
<dd><p>Call the remodeler and store the remodeled data in the object.</p>
</dd></dl>

<dl class="method">
<dt id="graf.GrafCompiler.needs_compiling">
<tt class="descname">needs_compiling</tt><big>(</big><big>)</big><a class="headerlink" href="#graf.GrafCompiler.needs_compiling" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks whether the compiled binary data is still up to date.</p>
<p>The criterion is whether the generated statistics file at the binary side is newer than the chosen GrAF header file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><em>bool</em> &#8211;
whether the criterion for compiling holds.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="graf.GrafCompiler.parse">
<tt class="descname">parse</tt><big>(</big><big>)</big><a class="headerlink" href="#graf.GrafCompiler.parse" title="Permalink to this definition">¶</a></dt>
<dd><p>Call the XML parser and collect the parse results.</p>
<p>Some parse results must be remodelled afterwards.
After remodelling some parse data can be thrown away.
Only store data that is needed for task execution in the object.</p>
<p>The actual parsing is done in the module <a class="reference internal" href="#module-graf.parse" title="graf.parse"><tt class="xref py py-mod docutils literal"><span class="pre">parse</span></tt></a>.</p>
</dd></dl>

<dl class="attribute">
<dt id="graf.GrafCompiler.temp_data_items">
<tt class="descname">temp_data_items</tt><em class="property"> = {}</em><a class="headerlink" href="#graf.GrafCompiler.temp_data_items" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="graf.GrafCompiler.write_data">
<tt class="descname">write_data</tt><big>(</big><big>)</big><a class="headerlink" href="#graf.GrafCompiler.write_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes compiled data to disk.</p>
<p>Compiled data has three possible types:</p>
<dl class="docutils">
<dt><em>0: plain array</em></dt>
<dd>can be written fast with the <tt class="xref py py-meth docutils literal"><span class="pre">array.tofile()</span></tt> method</dd>
<dt><em>1: array valued dict</em></dt>
<dd>a dictionary, keyed by a feature name and with arrays as values</dd>
<dt><em>2: list of trings</em></dt>
<dd>can be dumped with the <tt class="xref py py-meth docutils literal"><span class="pre">cPickle.dump()</span></tt> method.</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="graf.GrafTask">
<em class="property">class </em><tt class="descname">GrafTask</tt><big>(</big><em>settings</em><big>)</big><a class="headerlink" href="#graf.GrafTask" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#graf.graf.Graf" title="graf.graf.Graf"><tt class="xref py py-class docutils literal"><span class="pre">graf.graf.Graf</span></tt></a></p>
<p>Task processor.</p>
<p>A task processor must know how to compile, where the source data is and where the result is going to.
And it must be able to <a class="reference external" href="http://docs.python.org/reference/simple_stmts.html#import" title="(in Python v2.7)"><tt class="xref std std-keyword docutils literal"><span class="pre">import</span></tt></a>: and <a class="reference external" href="http://docs.python.org/library/functions.html#reload" title="(in Python v2.7)"><tt class="xref py py-func docutils literal"><span class="pre">reload()</span></tt></a>: the tasks.
To that end the search path for modules will be adapted according to the <em>task_dir</em> setting
in the main configuration file.</p>
<p>Upon creation, the configuration settings are store in the object as is</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>settings (</strong> &#8211;
py:class:<cite>ConfigParser.ConfigParser</cite>): entries corresponding to the main configuration file</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="graf.GrafTask.FEi">
<tt class="descname">FEi</tt><big>(</big><em>edge</em>, <em>name</em><big>)</big><a class="headerlink" href="#graf.GrafTask.FEi" title="Permalink to this definition">¶</a></dt>
<dd><p>Edge feature value lookup returning the value string representation.</p>
</dd></dl>

<dl class="method">
<dt id="graf.GrafTask.FEr">
<tt class="descname">FEr</tt><big>(</big><em>edge</em>, <em>name</em><big>)</big><a class="headerlink" href="#graf.GrafTask.FEr" title="Permalink to this definition">¶</a></dt>
<dd><p>Edge feature value lookup returning the value string representation.
See method <a class="reference internal" href="#graf.GrafTask.FEi" title="graf.GrafTask.FEi"><tt class="xref py py-meth docutils literal"><span class="pre">FEi()</span></tt></a>.</p>
</dd></dl>

<dl class="method">
<dt id="graf.GrafTask.FNi">
<tt class="descname">FNi</tt><big>(</big><em>node</em>, <em>name</em><big>)</big><a class="headerlink" href="#graf.GrafTask.FNi" title="Permalink to this definition">¶</a></dt>
<dd><p>Node feature value lookup returning the value string representation.</p>
</dd></dl>

<dl class="method">
<dt id="graf.GrafTask.FNr">
<tt class="descname">FNr</tt><big>(</big><em>node</em>, <em>name</em><big>)</big><a class="headerlink" href="#graf.GrafTask.FNr" title="Permalink to this definition">¶</a></dt>
<dd><p>Node feature value lookup returning the value string representation.
See method <a class="reference internal" href="#graf.GrafTask.FNi" title="graf.GrafTask.FNi"><tt class="xref py py-meth docutils literal"><span class="pre">FNi()</span></tt></a>.</p>
</dd></dl>

<dl class="method">
<dt id="graf.GrafTask.__del__">
<tt class="descname">__del__</tt><big>(</big><big>)</big><a class="headerlink" href="#graf.GrafTask.__del__" title="Permalink to this definition">¶</a></dt>
<dd><p>Upon destruction, all file handles used by the task will be closed.</p>
</dd></dl>

<dl class="method">
<dt id="graf.GrafTask.add_result">
<tt class="descname">add_result</tt><big>(</big><em>file_name</em><big>)</big><a class="headerlink" href="#graf.GrafTask.add_result" title="Permalink to this definition">¶</a></dt>
<dd><p>Opens a file for writing and stores the handle.</p>
<p>Every task is advised to use this method for opening files for its output.
The file will be closed by the workbench when the task terminates.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>file_name</strong> (<em>str</em>) &#8211;
name of the output file.</li>
<li><strong>Its location is the result directory for this task and this source.</strong></li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A handle to the opened file.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="graf.GrafTask.common_loader">
<tt class="descname">common_loader</tt><big>(</big><em>source</em><big>)</big><a class="headerlink" href="#graf.GrafTask.common_loader" title="Permalink to this definition">¶</a></dt>
<dd><p>Manage the common data to be loaded.</p>
<p>Common data is data  common to all tasks but specific to a source.</p>
</dd></dl>

<dl class="method">
<dt id="graf.GrafTask.compile">
<tt class="descname">compile</tt><big>(</big><em>force_compile</em><big>)</big><a class="headerlink" href="#graf.GrafTask.compile" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="graf.GrafTask.feature_loader">
<tt class="descname">feature_loader</tt><big>(</big><em>directives</em><big>)</big><a class="headerlink" href="#graf.GrafTask.feature_loader" title="Permalink to this definition">¶</a></dt>
<dd><p>Manage the feature data to be loaded.</p>
<p>The specification of which features are selected is still a string.
Here we compile it into a dictionary <em>only</em>, keyed with the extended feature name.</p>
<p>The loaded features together form a dictionary, keyed with the extended feature name.
The values are dictionaries keyed by the element, with as values the feature values.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>directives</strong> (<em>dict</em>) &#8211;
dictionary of strings string specifying the features selected for feature loading.
There are two keys: <em>node</em> and <em>edge</em>, because node features and edge features are handled separately.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="graf.GrafTask.finish_task">
<tt class="descname">finish_task</tt><big>(</big><big>)</big><a class="headerlink" href="#graf.GrafTask.finish_task" title="Permalink to this definition">¶</a></dt>
<dd><p>Finalizes the current task.</p>
<p>There will be a progress message, and a directory listing of the result directory,
for the convenience of the user.</p>
</dd></dl>

<dl class="method">
<dt id="graf.GrafTask.get_mappings">
<tt class="descname">get_mappings</tt><big>(</big><big>)</big><a class="headerlink" href="#graf.GrafTask.get_mappings" title="Permalink to this definition">¶</a></dt>
<dd><p>Return references to API methods of this class.</p>
<p>The caller can give convenient, local names to these methods.
It also saves method lookup,
at least, I think so.</p>
</dd></dl>

<dl class="method">
<dt id="graf.GrafTask.getitems">
<tt class="descname">getitems</tt><big>(</big><em>data</em>, <em>data_items</em>, <em>elem</em><big>)</big><a class="headerlink" href="#graf.GrafTask.getitems" title="Permalink to this definition">¶</a></dt>
<dd><p>Get related items from an arrayified data structure.</p>
<p>If a relation between integers and sets of integers has been stored as a double array
by the <a class="reference internal" href="#graf.model.arrayify" title="graf.model.arrayify"><tt class="xref py py-func docutils literal"><span class="pre">arrayify()</span></tt></a> function,
this is the way to look up the set of related integers for each integer.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<em>array</em>) &#8211;
see next</li>
<li><strong>data_items</strong> (<em>array</em>) &#8211;
together with <em>data</em> the arrayified data</li>
<li><strong>elem</strong> (<em>int</em>) &#8211;
the integer for which we want its related set of integers.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">a list of the related integers.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="graf.GrafTask.hasitem">
<tt class="descname">hasitem</tt><big>(</big><em>data</em>, <em>data_items</em>, <em>elem</em>, <em>item</em><big>)</big><a class="headerlink" href="#graf.GrafTask.hasitem" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether an integer is in the set of related items
with respect to an arrayified data structure (see also <a class="reference internal" href="#graf.GrafTask.getitems" title="graf.GrafTask.getitems"><tt class="xref py py-meth docutils literal"><span class="pre">getitems()</span></tt></a>).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<em>array</em>) &#8211;
see next</li>
<li><strong>data_items</strong> (<em>array</em>) &#8211;
together with <em>data</em> the arrayified data</li>
<li><strong>elem</strong> (<em>int</em>) &#8211;
the integer for which we want its related set of integers.</li>
<li><strong>item</strong> (<em>int</em>) &#8211;
the integer whose presence in the related items set is to be tested.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><em>bool</em> &#8211;
whether the integer is in the related set or not.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="graf.GrafTask.hasitems">
<tt class="descname">hasitems</tt><big>(</big><em>data</em>, <em>data_items</em>, <em>elem</em>, <em>items</em><big>)</big><a class="headerlink" href="#graf.GrafTask.hasitems" title="Permalink to this definition">¶</a></dt>
<dd><p>Check whether a set of integers intersects with the set of related items
with respect to an arrayified data structure (see also <a class="reference internal" href="#graf.GrafTask.getitems" title="graf.GrafTask.getitems"><tt class="xref py py-meth docutils literal"><span class="pre">getitems()</span></tt></a>).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>data</strong> (<em>array</em>) &#8211;
see next</li>
<li><strong>data_items</strong> (<em>array</em>) &#8211;
together with <em>data</em> the arrayified data</li>
<li><strong>elem</strong> (<em>int</em>) &#8211;
the integer for which we want its related set of integers.</li>
<li><strong>items</strong> (<em>array or list of integers</em>) &#8211;
the set of integers</li>
<li><strong>whose presence in the related items set is to be tested.</strong></li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><em>bool</em> &#8211;
whether one of the integers is in the related set or not.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="graf.GrafTask.init_task">
<tt class="descname">init_task</tt><big>(</big><big>)</big><a class="headerlink" href="#graf.GrafTask.init_task" title="Permalink to this definition">¶</a></dt>
<dd><p>Initializes the current task.</p>
<p>Very trivial initialization: just issue a progress message.</p>
</dd></dl>

<dl class="method">
<dt id="graf.GrafTask.int_fname_edge">
<tt class="descname">int_fname_edge</tt><big>(</big><em>rep</em><big>)</big><a class="headerlink" href="#graf.GrafTask.int_fname_edge" title="Permalink to this definition">¶</a></dt>
<dd><p>API: <em>feature name</em> (on edges) conversion from string representation as found in LAF resource
to corresponding integer as used in compiled resource.</p>
</dd></dl>

<dl class="method">
<dt id="graf.GrafTask.int_fname_node">
<tt class="descname">int_fname_node</tt><big>(</big><em>rep</em><big>)</big><a class="headerlink" href="#graf.GrafTask.int_fname_node" title="Permalink to this definition">¶</a></dt>
<dd><p>API: <em>feature name</em> (on nodes) conversion from string representation as found in LAF resource
to corresponding integer as used in compiled resource.</p>
</dd></dl>

<dl class="method">
<dt id="graf.GrafTask.int_fval">
<tt class="descname">int_fval</tt><big>(</big><em>rep</em><big>)</big><a class="headerlink" href="#graf.GrafTask.int_fval" title="Permalink to this definition">¶</a></dt>
<dd><p>API: <em>feature value</em> conversion from string representation as found in LAF resource
to corresponding integer as used in compiled resource.</p>
</dd></dl>

<dl class="attribute">
<dt id="graf.GrafTask.loaded">
<tt class="descname">loaded</tt><em class="property"> = defaultdict(&lt;function &lt;lambda&gt; at 0x1026b8848&gt;, {})</em><a class="headerlink" href="#graf.GrafTask.loaded" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="graf.GrafTask.loader">
<tt class="descname">loader</tt><big>(</big><em>source</em>, <em>task</em>, <em>directives</em><big>)</big><a class="headerlink" href="#graf.GrafTask.loader" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads compiled LAF data.</p>
<p>There are two kinds of data to be loaded:</p>
<dl class="docutils">
<dt><em>common data</em></dt>
<dd>Data that is common to all tasks, but dependent on the choice of source.
It is the data that holds the regions, nodes, edges, but not the features.</dd>
<dt><em>feature data</em></dt>
<dd>Data that is requested by the task at hand.
It is the data that holds feature information,
for those features that are requested by a task&#8217;s <em>feature</em> declaration.</dd>
</dl>
<p>The <em>common data</em> can be loaded in bulk fast, but it still takes 5 to 10 seconds,
and should be avoided if possible.
This data only needs to be loaded if the source has changed or if compilation has taken place.
It is taken care of by <a class="reference internal" href="#graf.GrafTask.common_loader" title="graf.GrafTask.common_loader"><tt class="xref py py-meth docutils literal"><span class="pre">common_loader()</span></tt></a>.</p>
<p>The <em>feature data</em> is loaded and unloaded on demand
and the feature manager method <a class="reference internal" href="#graf.GrafTask.feature_loader" title="graf.GrafTask.feature_loader"><tt class="xref py py-meth docutils literal"><span class="pre">feature_loader()</span></tt></a> takes care of that.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>directives</strong> (<em>dict</em>) &#8211;
a dictionary of information</li>
<li><strong>relevant to</strong> &#8211;
meth:<cite>common_loader</cite> and <a class="reference internal" href="#graf.GrafTask.feature_loader" title="graf.GrafTask.feature_loader"><tt class="xref py py-meth docutils literal"><span class="pre">feature_loader()</span></tt></a>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">directives are only used by <a class="reference internal" href="#graf.GrafTask.feature_loader" title="graf.GrafTask.feature_loader"><tt class="xref py py-meth docutils literal"><span class="pre">feature_loader()</span></tt></a>.</p>
</div>
</dd></dl>

<dl class="method">
<dt id="graf.GrafTask.next_node">
<tt class="descname">next_node</tt><big>(</big><big>)</big><a class="headerlink" href="#graf.GrafTask.next_node" title="Permalink to this definition">¶</a></dt>
<dd><p>API: iterator of all nodes in primary data order.</p>
<p>Each call <em>yields</em> the next node. The iterator walks through all nodes.
The order is implied by the attachment of nodes to the primary data,
which is itself linearly ordered.
This order is explained in the <a class="reference internal" href="../taskwriting.html#node-order"><em>guidelines for task writing</em></a>.</p>
</dd></dl>

<dl class="method">
<dt id="graf.GrafTask.next_node_with_fval">
<tt class="descname">next_node_with_fval</tt><big>(</big><em>name</em>, <em>value</em><big>)</big><a class="headerlink" href="#graf.GrafTask.next_node_with_fval" title="Permalink to this definition">¶</a></dt>
<dd><p>API: iterator of all nodes in primary data order that have a
given value for a given feature.</p>
<p>See also <a class="reference internal" href="#graf.GrafTask.next_node" title="graf.GrafTask.next_node"><tt class="xref py py-meth docutils literal"><span class="pre">next_node()</span></tt></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> (<em>int</em>) &#8211;
the code of a feature name</li>
<li><strong>value</strong> (<em>int</em>) &#8211;
the code of a feature value</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="graf.GrafTask.rep_fname_edge">
<tt class="descname">rep_fname_edge</tt><big>(</big><em>intl</em><big>)</big><a class="headerlink" href="#graf.GrafTask.rep_fname_edge" title="Permalink to this definition">¶</a></dt>
<dd><p>API: <em>feature name</em> (on edges) conversion from integer code as used in compiled LAF resource
to corresponding string representation as found in original LAF resource.</p>
</dd></dl>

<dl class="method">
<dt id="graf.GrafTask.rep_fname_node">
<tt class="descname">rep_fname_node</tt><big>(</big><em>intl</em><big>)</big><a class="headerlink" href="#graf.GrafTask.rep_fname_node" title="Permalink to this definition">¶</a></dt>
<dd><p>API: <em>feature name</em> (on nodes) conversion from integer code as used in compiled LAF resource
to corresponding string representation as found in original LAF resource.</p>
</dd></dl>

<dl class="method">
<dt id="graf.GrafTask.rep_fval">
<tt class="descname">rep_fval</tt><big>(</big><em>intl</em><big>)</big><a class="headerlink" href="#graf.GrafTask.rep_fval" title="Permalink to this definition">¶</a></dt>
<dd><p>API: <em>feature value</em> conversion from integer code as used in compiled LAF resource
to corresponding string representation as found in original LAF resource.</p>
</dd></dl>

<dl class="attribute">
<dt id="graf.GrafTask.result_files">
<tt class="descname">result_files</tt><em class="property"> = []</em><a class="headerlink" href="#graf.GrafTask.result_files" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="graf.GrafTask.run">
<tt class="descname">run</tt><big>(</big><em>source</em>, <em>task</em>, <em>force_compile=False</em><big>)</big><a class="headerlink" href="#graf.GrafTask.run" title="Permalink to this definition">¶</a></dt>
<dd><p>Run a task.</p>
<p>That is:
* Load the data
* (Re)load the task code
* Initialize the task
* Run tha task code
* Finalize the task</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>source</strong> (<em>str</em>) &#8211;
key for the source</li>
<li><strong>task</strong> &#8211;
the chosen task</li>
<li><strong>force_compile</strong> (<em>bool</em>) &#8211;
whether to force (re)compilation of the LAF source</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="graf.Timestamp">
<em class="property">class </em><tt class="descname">Timestamp</tt><big>(</big><em>log_file=None</em><big>)</big><a class="headerlink" href="#graf.Timestamp" title="Permalink to this definition">¶</a></dt>
<dd><p>Time management.</p>
<p>Objects remember their creation time. So they can issue statements about how much time has been elapsed.
All timed log messages of the program should be issued through the <a class="reference internal" href="#graf.Timestamp.progress" title="graf.Timestamp.progress"><tt class="xref py py-meth docutils literal"><span class="pre">progress()</span></tt></a> method of this class.</p>
<p>It is also possible to connect a logfile to these objects.
When progress messages are issued, they are also written to the connected log file.</p>
<p>Upon creation, retrieves the time.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>log_file</strong> (<em>file</em>) &#8211;
open file handle for writing. Optional. If not <tt class="docutils literal"><span class="pre">None</span></tt> stores the handle in the object&#8217;s data.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="graf.Timestamp.connect_log">
<tt class="descname">connect_log</tt><big>(</big><em>log_file</em><big>)</big><a class="headerlink" href="#graf.Timestamp.connect_log" title="Permalink to this definition">¶</a></dt>
<dd><p>Connects a log file to the object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>log_file</strong> (<em>file</em>) &#8211;
open handle for writing.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="graf.Timestamp.elapsed">
<tt class="descname">elapsed</tt><big>(</big><big>)</big><a class="headerlink" href="#graf.Timestamp.elapsed" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the time elapsed since creation of the <a class="reference internal" href="#graf.Timestamp" title="graf.Timestamp"><tt class="xref py py-class docutils literal"><span class="pre">Timestamp</span></tt></a> object.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">A pretty formatted string, ready to include in a message.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="graf.Timestamp.progress">
<tt class="descname">progress</tt><big>(</big><em>msg</em>, <em>newline=True</em><big>)</big><a class="headerlink" href="#graf.Timestamp.progress" title="Permalink to this definition">¶</a></dt>
<dd><p>API: issues a timed progress message.</p>
<p>The message is issued to the standard output, and, if a log file has been connected, also to the log file.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>msg</strong> (<em>str</em>) &#8211;
text of the message</li>
<li><strong>newline</strong> (<em>bool</em>) &#8211;
whether or not to add a newline. Optional. Make it <tt class="docutils literal"><span class="pre">False</span></tt> to not add a newline.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="graf.Timestamp.reset">
<tt class="descname">reset</tt><big>(</big><big>)</big><a class="headerlink" href="#graf.Timestamp.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the time to the current time</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="graf.Shell">
<em class="property">class </em><tt class="descname">Shell</tt><a class="headerlink" href="#graf.Shell" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <tt class="xref py py-class docutils literal"><span class="pre">object</span></tt></p>
<p>Execute tasks, either in a single run, or with an interactive prompt.</p>
<p>This class knows about the environment, such as command line arguments
and configuration files.
It collects those information pieces and passes them in suitable form
to the factual task processor.</p>
<p>Upon creation, create a <a class="reference internal" href="#graf.task.GrafTask" title="graf.task.GrafTask"><tt class="xref py py-class docutils literal"><span class="pre">GrafTask</span></tt></a> object based on settings.</p>
<dl class="method">
<dt id="graf.Shell.command_loop">
<tt class="descname">command_loop</tt><big>(</big><big>)</big><a class="headerlink" href="#graf.Shell.command_loop" title="Permalink to this definition">¶</a></dt>
<dd><p>Command prompt for repeated running of tasks.</p>
</dd></dl>

<dl class="method">
<dt id="graf.Shell.do_command">
<tt class="descname">do_command</tt><big>(</big><em>prompt</em>, <em>choices</em>, <em>helpstr</em><big>)</big><a class="headerlink" href="#graf.Shell.do_command" title="Permalink to this definition">¶</a></dt>
<dd><p>Prompts the user to enter a command and dispatches it, if correct.</p>
<p>This method asks the user for a command consisting of a single letter.
It checks whether the letter is a legal option.
It add options for quitting (Esc) and displaying help (?).
If he user enters <tt class="docutils literal"><span class="pre">?</span></tt>, the helpstring is displayed.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>prompt</strong> (<em>str</em>) &#8211;
the prompt string to be displayed.
This string will be extenden with a description of the allowed keys to press.</li>
<li><strong>choices</strong> (<em>str</em>) &#8211;
a string consisting of legal  one letter commands, not separated.</li>
<li><strong>helpstr</strong> (<em>str</em>) &#8211;
help string to be displayed if the user presses <tt class="docutils literal"><span class="pre">?</span></tt></li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>command</strong> (<em>str</em>) &#8211;
the command entered by the user, or <tt class="docutils literal"><span class="pre">None</span></tt> if escape has been pressed.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="graf.Shell.get_ch">
<tt class="descname">get_ch</tt><big>(</big><em>prompt=''</em><big>)</big><a class="headerlink" href="#graf.Shell.get_ch" title="Permalink to this definition">¶</a></dt>
<dd><p>Asks for unbuffered single character input, with an optional prompt.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>prompt</strong> (<em>str</em>) &#8211;
Optional text to be displayed as prompt.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>ch</strong> (<em>char</em>) &#8211;
character pressed by the user.
If something gets wrong, returns the <em>Esc</em> character.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="graf.Shell.get_num">
<tt class="descname">get_num</tt><big>(</big><em>prompt</em>, <em>start</em>, <em>end</em><big>)</big><a class="headerlink" href="#graf.Shell.get_num" title="Permalink to this definition">¶</a></dt>
<dd><p>Asks for a numeric value, and checks whether teh value is in a legal range.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>prompt</strong> (<em>str</em>) &#8211;
prompt to be displayed</li>
<li><strong>start</strong> (<em>str</em>) &#8211;
minimum legal value</li>
<li><strong>end</strong> (<em>str</em>) &#8211;
maximum legal value</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><strong>number</strong> (<em>int</em>) &#8211;
the number if the user entered something legal,
and <tt class="docutils literal"><span class="pre">None</span></tt> otherwise.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="graf.Shell.main_command">
<tt class="descname">main_command</tt><big>(</big><em>command</em><big>)</big><a class="headerlink" href="#graf.Shell.main_command" title="Permalink to this definition">¶</a></dt>
<dd><p>Interprets a top level command.</p>
<p>Depending on the command passed, this methods prompts for additional information.
This happens for the commands that modify the source and task selection.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>command</strong> (<em>char</em>) &#8211;
the command character.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>message</strong> (<em>str</em>) &#8211;
response text after the command execution.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="graf.Shell.processor">
<tt class="descname">processor</tt><big>(</big><big>)</big><a class="headerlink" href="#graf.Shell.processor" title="Permalink to this definition">¶</a></dt>
<dd><p>Does work. Decides to run one task or start the command prompt.</p>
<p>The decision is based on the presence of command line arguments.
If all arguments are present to specify a task, the <em>run once</em> option will be chosen,
unless the user has explicitly stated <tt class="docutils literal"><span class="pre">--menu</span></tt>.
Otherwise the command prompt is started. If that is the case, the
command line args that did come through, are used as initial values.</p>
</dd></dl>

<dl class="method">
<dt id="graf.Shell.prompt">
<tt class="descname">prompt</tt><big>(</big><big>)</big><a class="headerlink" href="#graf.Shell.prompt" title="Permalink to this definition">¶</a></dt>
<dd><p>Writes an self-explanatory prompt text to the terminal.</p>
</dd></dl>

<dl class="method">
<dt id="graf.Shell.weave">
<tt class="descname">weave</tt><big>(</big><em>data</em><big>)</big><a class="headerlink" href="#graf.Shell.weave" title="Permalink to this definition">¶</a></dt>
<dd><p>Utility value that prepares data for presenting several columns of options
on a terminal screen.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>data</strong> (<em>lists of lists</em>) &#8211;
corresponds to a number of lists of options.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>woven</strong> (<em>list of lists</em>) &#8211;
correponds to a table where columns are the lists of options
and the options occupy rows. The outermost list are the rows.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><strong>index</strong> (<em>dict of dict</em>) &#8211;
given column number and then row number as keys yields the
name of the item at that slot</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><strong>iindex</strong> (<em>dict of dict</em>) &#8211;
given column number and then the name of an item as keys yields the
row number of that item</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">graf package</a><ul>
<li><a class="reference internal" href="#submodules">Submodules</a></li>
<li><a class="reference internal" href="#module-graf.compiler">graf.compiler module</a></li>
<li><a class="reference internal" href="#module-graf.graf">graf.graf module</a></li>
<li><a class="reference internal" href="#module-graf.model">graf.model module</a></li>
<li><a class="reference internal" href="#module-graf.parse">graf.parse module</a></li>
<li><a class="reference internal" href="#module-graf.shell">graf.shell module</a></li>
<li><a class="reference internal" href="#module-graf.task">graf.task module</a></li>
<li><a class="reference internal" href="#module-graf.timestamp">graf.timestamp module</a></li>
<li><a class="reference internal" href="#module-graf">Module contents</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="modules.html"
                        title="previous chapter">graf</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/graf/graf.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="modules.html" title="graf"
             >previous</a> |</li>
        <li><a href="../index.html">LAF-Fabric 0.9.1 documentation</a> &raquo;</li>
          <li><a href="modules.html" >graf</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2013, Dirk Roorda.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2b3.
    </div>
  </body>
</html>