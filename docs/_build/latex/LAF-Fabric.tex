% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\usepackage[utf8]{inputenc}
\DeclareUnicodeCharacter{00A0}{\nobreakspace}
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{longtable}
\usepackage{sphinx}
\usepackage{multirow}


\title{LAF-Fabric Documentation}
\date{November 19, 2013}
\release{0.9.1}
\author{Dirk Roorda}
\newcommand{\sphinxlogo}{}
\renewcommand{\releasename}{Release}
\makeindex

\makeatletter
\def\PYG@reset{\let\PYG@it=\relax \let\PYG@bf=\relax%
    \let\PYG@ul=\relax \let\PYG@tc=\relax%
    \let\PYG@bc=\relax \let\PYG@ff=\relax}
\def\PYG@tok#1{\csname PYG@tok@#1\endcsname}
\def\PYG@toks#1+{\ifx\relax#1\empty\else%
    \PYG@tok{#1}\expandafter\PYG@toks\fi}
\def\PYG@do#1{\PYG@bc{\PYG@tc{\PYG@ul{%
    \PYG@it{\PYG@bf{\PYG@ff{#1}}}}}}}
\def\PYG#1#2{\PYG@reset\PYG@toks#1+\relax+\PYG@do{#2}}

\expandafter\def\csname PYG@tok@gd\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.63,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gu\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.50,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@gt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.27,0.87}{##1}}}
\expandafter\def\csname PYG@tok@gs\endcsname{\let\PYG@bf=\textbf}
\expandafter\def\csname PYG@tok@gr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{1.00,0.00,0.00}{##1}}}
\expandafter\def\csname PYG@tok@cm\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@vg\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@m\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@cs\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\colorbox[rgb]{1.00,0.94,0.94}{\strut ##1}}}
\expandafter\def\csname PYG@tok@ge\endcsname{\let\PYG@it=\textit}
\expandafter\def\csname PYG@tok@vc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@il\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@go\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.20,0.20,0.20}{##1}}}
\expandafter\def\csname PYG@tok@cp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@gi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.63,0.00}{##1}}}
\expandafter\def\csname PYG@tok@gh\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.00,0.50}{##1}}}
\expandafter\def\csname PYG@tok@ni\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.84,0.33,0.22}{##1}}}
\expandafter\def\csname PYG@tok@nl\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.13,0.44}{##1}}}
\expandafter\def\csname PYG@tok@nn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@no\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.38,0.68,0.84}{##1}}}
\expandafter\def\csname PYG@tok@na\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@nb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.05,0.52,0.71}{##1}}}
\expandafter\def\csname PYG@tok@nd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.33,0.33,0.33}{##1}}}
\expandafter\def\csname PYG@tok@ne\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@nf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.49}{##1}}}
\expandafter\def\csname PYG@tok@si\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.44,0.63,0.82}{##1}}}
\expandafter\def\csname PYG@tok@s2\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@vi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@nt\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.02,0.16,0.45}{##1}}}
\expandafter\def\csname PYG@tok@nv\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.38,0.84}{##1}}}
\expandafter\def\csname PYG@tok@s1\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@gp\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@sh\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@ow\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@sx\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.78,0.36,0.04}{##1}}}
\expandafter\def\csname PYG@tok@bp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c1\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@kc\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@c\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.50,0.56}{##1}}}
\expandafter\def\csname PYG@tok@mf\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@err\endcsname{\def\PYG@bc##1{\setlength{\fboxsep}{0pt}\fcolorbox[rgb]{1.00,0.00,0.00}{1,1,1}{\strut ##1}}}
\expandafter\def\csname PYG@tok@kd\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@ss\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.32,0.47,0.09}{##1}}}
\expandafter\def\csname PYG@tok@sr\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.14,0.33,0.53}{##1}}}
\expandafter\def\csname PYG@tok@mo\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@mi\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.13,0.50,0.31}{##1}}}
\expandafter\def\csname PYG@tok@kn\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@o\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.40,0.40,0.40}{##1}}}
\expandafter\def\csname PYG@tok@kr\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@s\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@kp\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@w\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.73,0.73,0.73}{##1}}}
\expandafter\def\csname PYG@tok@kt\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.56,0.13,0.00}{##1}}}
\expandafter\def\csname PYG@tok@sc\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sb\endcsname{\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@k\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.00,0.44,0.13}{##1}}}
\expandafter\def\csname PYG@tok@se\endcsname{\let\PYG@bf=\textbf\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}
\expandafter\def\csname PYG@tok@sd\endcsname{\let\PYG@it=\textit\def\PYG@tc##1{\textcolor[rgb]{0.25,0.44,0.63}{##1}}}

\def\PYGZbs{\char`\\}
\def\PYGZus{\char`\_}
\def\PYGZob{\char`\{}
\def\PYGZcb{\char`\}}
\def\PYGZca{\char`\^}
\def\PYGZam{\char`\&}
\def\PYGZlt{\char`\<}
\def\PYGZgt{\char`\>}
\def\PYGZsh{\char`\#}
\def\PYGZpc{\char`\%}
\def\PYGZdl{\char`\$}
\def\PYGZhy{\char`\-}
\def\PYGZsq{\char`\'}
\def\PYGZdq{\char`\"}
\def\PYGZti{\char`\~}
% for compatibility with earlier versions
\def\PYGZat{@}
\def\PYGZlb{[}
\def\PYGZrb{]}
\makeatother

\begin{document}

\maketitle
\tableofcontents
\phantomsection\label{index::doc}


Contents:


\chapter{LAF/GrAF and data analysis}
\label{overview:laf-graf-and-data-analysis}\label{overview::doc}\label{overview:welcome-to-laf-fabric-s-documentation}

\section{What is LAF/GrAF}
\label{overview:what-is-laf-graf}
LAF/GrAF is a framework for representing linguistic source material plus associated annotations.
LAF, Linguistic Annotation Framework is an
ISO standard (\href{http://www.iso.org/iso/catalogue\_detail.htm?csnumber=37326}{24612:2012})
that describes the organization of the data.
GrAF, Graph Annotation Framework, is a set of
\href{http://www.xces.org/ns/GrAF/1.0/}{schemas} for the XML-annotations in a LAF resource.

Despite the L of linguistics, there is nothing particularly linguistic to LAF.
LAF describes data that comes as a linearly ordered \emph{primary data} stream
(audio, video, text, or anything that has a one dimensional order), in which \emph{regions} can be defined.
\emph{Annotations} are key=value pairs or \emph{feature structures} in general,
which conform to the joint definition with the Text Encoding Initiative
(\href{http://www.tei-c.org/release/doc/tei-p5-doc/en/html/FS.html}{TEI Feature Structures}
and \href{http://www.iso.org/iso/catalogue\_detail.htm?csnumber=37324}{ISO version}).
Between the primary data and the annotations is a \emph{graph} of \emph{nodes} and \emph{edges}.
Some nodes are linked to regions of primary data.
Some nodes are linked to other nodes by means of edges.
An annotation may refer to a node or to an edge, but not both.

So, features target the primary data through annotations.
Annotations can be labeled and they can be organized in \emph{annotation spaces}.


\section{Data}
\label{overview:id2}\label{overview:data}
Although this tool is written to deal with LAF resources in general, it has been developed with a particular
LAF resource in mind:
the \href{http://www.dans.knaw.nl/en/content/categorieen/projecten/text-database-hebrew-old-testament}{WIVU text database of the Hebrew Bible}.
This data set is available (by request) from the national research data archive in the Netherlands, DANS,
by following this persistent identifier:
\href{http://www.persistent-identifier.nl/?identifier=urn\%3Anbn\%3Anl\%3Aui\%3A13-ukhm-eb}{urn:nbn:nl:ui:13-ukhm-eb}.
This data is not yet in LAF format.
The \href{http://www.slideshare.net/dirkroorda/shebanq-gniezno}{SHEBANQ} project has
converted the database into LAF (the conversion code is to be published on GitHub shortly),
and the resulting LAF resource is a file set of 2.27 GB, being predominantly linguistic annotations.
It is this LAF resource that is the reference context for this workbench.
It is to be deposited into the DANS archive shortly, under an Open Access licence, with the
restriction that it may not be used commercially.


\section{Existing tools for LAF/GrAF resources}
\label{overview:existing-tools-for-laf-graf-resources}
There is an interesting Python module (\href{http://media.cidles.eu/poio/graf-python/}{POIO, Graf-python})
that can read generic GrAF resources.
It exposes an API to work with the graph and annotations of such resources.
However, when feeding it a resource with 430 k words and 2 GB of annotation material,
the performance is such that the graph does not fit into memory of a laptop.
Clearly, the tool has been defined for bunches of smaller GrAF documents,
and not for a single documents of 500 k words and GBs of annotation material.


\section{This workbench}
\label{overview:this-workbench}
The present workbench seeks to remedy that situation.
Its aim is to provide a framework on top of which users can write small Python scripts that
perform analytic tasks on big GrAF resources.
It achieves this goal by efficient storage of data, both on disk and in RAM and by precomputing indices.


\subsection{Limitations}
\label{overview:limitations}
While the \href{http://media.cidles.eu/poio/graf-python/}{POIO, Graf-python} module
mentioned above is capable to read generic resources, the present Graf tool is less generic.
It does not support the full complexity of the Graf model.
In particular, it does not support annotation spaces, it does not read dependencies,
and it cannot handle feature structures in full generality, it only handles key-value pairs.
Currently, there is very little API support for dealing with \emph{edges} and their features.


\subsection{Future work}
\label{overview:future-work}
The current workbench has proven to function well for a small set of tasks.
This proves that the methodology works and that we can try more challenging tasks.
The direction of the future work should be determined by the experiences coming out of that.
That said, it is not difficult to spot immediate areas for improvement:
\begin{enumerate}
\item {} 
gain experience with the tool by adding more example tasks

\item {} 
improve the API, add extra primitives, especially for edges

\item {} 
make the workbench more programmer friendly

\item {} 
look out for even better performance for various tasks

\item {} 
increase the support for more GrAF features, and to make the workbench fully compatible with GrAF/LAF

\item {} 
merge the tool with the existing \href{http://media.cidles.eu/poio/graf-python/}{POIO, Graf-python},
preferably as a user selectable implementation choice

\end{enumerate}


\section{Rationale}
\label{overview:rationale}
The paradigms for biblical research are becoming \emph{data-driven}.
Researchers need increasingly sophisticated ways to get qualitative and quantitative data out of their resources.
They are in the best position to define what they need and ... to fulfill those needs.
To that end they need the freedom to access the data and tools relevant to them and to adapt them to their needs.

This workbench is a stepping stone for humanities researchers with limited time for programming
to the wonderful world of computing. With it they can extract data from their resources of interest and
feed it into other tools.

See for example the task {\hyperref[tasks/esther:module-esther]{\code{esther}}}, which codes in less than a page an extraction of \textbf{data tables} relevant to the
study of linguistic variation in the Hebrew Bible. These tables are suitable for subsequent data analysis
by means of the open source \href{http://www.r-project.org}{statistics toolkit R}.

An other example is the task {\hyperref[tasks/proper:module-proper]{\code{proper}}}, which outputs a \textbf{vizualization} of the text of the Hebrew Bible in which
the syntactic structure is visible and the proper nouns and their gender.
With this visualization it becomes possible to discern genealogies from other genres with the unaided eye,
even without being able to read a letter of Hebrew.

All this code is on Github, workbench and example tasks.
Researchers are invited to develop their own tasks and share them, either through data archives or directly through
Github. In doing so, they will create a truly state of the art research tool, adapted to
the scholarly needs of analysis, review and publication.


\section{Author}
\label{overview:id5}\label{overview:author}
This work has been undertaken first in November 2013 by Dirk Roorda, working for
\href{http://www.dans.knaw.nl/en}{Data Archiving and Networked Services (DANS)} and
\href{http://tla.mpi.nl}{The Language Archive (TLA)}.
The work has been triggered by the execution of the
\href{http://www.slideshare.net/dirkroorda/shebanq-gniezno}{SHEBANQ} project
together with the researchers at the
\href{http://www.godgeleerdheid.vu.nl/nl/onderzoek/instituten-en-centra/eep-talstra-centre-for-bible-and-computer/index.asp}{Eep Talstra Centre for Bible and Computing (ETCBC), VU University}.

See also a description on the \href{http://demo.datanetworkservice.nl/mediawiki/index.php/LAF\_Fabric}{DANS-lab site}.

Thanks to Martijn Naaijer and Gino Kalkman for first experiments with the workbench.


\chapter{LAF workbench}
\label{workbench:laf-workbench}\label{workbench::doc}

\section{What is this workbench?}
\label{workbench:what-is-this-workbench}
This workbench is a pure Python tool for running Python scripts with access to the information in a LAF resource.
It has two major components:
\begin{enumerate}
\item {} 
a LAF compiler for transforming a LAF resource into binary data that loads very fast by Python

\item {} 
an execution environment that gives Python scripts access to LAF data and optimalization features

\end{enumerate}

The selling point of the workbench is performance, both in terms of speed and memory usage.
The second goal is to make it really easy for users to write analytic tasks straightforwardly in terms of LAF concepts
without bothering about performance.

The typical workflow is:
\begin{enumerate}
\item {} 
install a LAF resource somewhere on the filesystem.
A LAF resource is a directory with a primary data file, annotation files and header files.
In testing the workbench, I used a the {\hyperref[overview:data]{\emph{LAF version of the Hebrew Bible}}}

\item {} 
install the LAF workbench package somewhere on a computing system.

\item {} 
in a configuration file, adapt the locations of the LAF directory and a work/results directory.

\item {} 
write your own script, and put it in the right directory.

\item {} 
run the workbench by invoking the calling script.

\end{enumerate}

The workbench behaves in the same pattern as the \code{mysql\textgreater{}} prompt for a database. You can use it as in interactive
command interpreter that lets you select and run tasks.
You can also invoke it to run a single task without interaction.

During a prompt session you can make a selection of source and task.
You can run your selection, modify the selection, run it again, ad libitum.
While this session is alive, loading and unloading of data will be done only when it is really needed.
Data that is needed for one task, will be reused for the next task.

So I you have to debug a script, you can do so without repeatedly waiting for the loading of the data.

The first time a source is used, the LAF resource will be compiled.
This may take considerable time, say 10 minutes for a 2 GB resource on a Macbook Air (2012).
The compiled source will be saved to disk across runs of the workbench.
Loading the compiled data takes, in the same setting with the Hebrew Bible, 5 to 10 seconds.
And you can even cut out this loading time by running multiple tasks in a single session.

After loading the data, the workbench invokes your task script(s).
You must declare the LAF-features that you use in your script, and the workbench will load data for them.
It will also unload the data for features that the script has not declared.
This is in order not to burden the RAM with data that does not pertain to the task.


\section{License}
\label{workbench:license}
The intention is to make this work freely available, without any restrictions.
It is free for commerical use and non-commercial use.
The only limitation is that applications that include this work may not in anyway restrict the freedom
of others to use it.


\section{How to use the workbench?}
\label{workbench:how-to-use-the-workbench}
Here are detailed instructions for installing, configuring and using the workbench.


\subsection{Installation}
\label{workbench:installation}
In this Github project \emph{LAF-Fabric} there is a Python package called {\hyperref[graf/graf:module-graf]{\code{graf}}}.
It is a package without extension modules, so it will run from anywhere in your system.
I did not use the Python distutils to create a distribution that you can incorporate in your local Python installation.
You can just clone it from github and work with it right away:

\begin{Verbatim}[commandchars=\\\{\}]
cd «directory of your choice»
git clone https://github.com/dirkroorda/laf-fabric
\end{Verbatim}

You get a directory \emph{laf-fabric} with the following inside:
\begin{itemize}
\item {} 
\emph{graf}: the workbench itself, a Python package

\item {} 
\emph{laf-fabric.py}: a script to call the workbench

\item {} 
\emph{docs}: this documentation

\item {} 
\emph{tasks}: a directory with example tasks.

\end{itemize}

\begin{notice}{caution}{Caution:}
If you develop your own tasks, put them in a separate directory, otherwise you
may loose your work in them when you pull updates from Github.
See \emph{Configuration} below.
\end{notice}

Before running the workbench, the calling script has to be configured.


\subsection{Configuration}
\label{workbench:configuration}
The configuration file script is \emph{laf-fabric.cfg}.
In it is a configuration section:

\begin{Verbatim}[commandchars=\\\{\}]
[locations]                                     ; paths in the file system
data\_root: /Users/dirk/Scratch/shebanq/results  ; working directory
laf\_source: laf                                 ; subdirectory for the LAF data
task\_dir: tasks                                 ; absolute or relative path to the directory with the tasks
compiled\_source: db                             ; subdirectory for task results
bin\_subdir: bin                                 ; subdirectory of specific tasks
feat\_subdir: feat                               ; subdirectory within bin\_dir for feature data

[source\_choices]                                ; several GrAF header files
edge: bhs3.txt-edge.hdr
tiny: bhs3.txt-tiny.hdr
test: bhs3.txt-bhstext.hdr
total: bhs3.txt.hdr
\end{Verbatim}

You are likely to want to change the following entries:
\begin{description}
\item[{\emph{data\_root}}] \leavevmode
point to the folder containing your LAF directory.

\item[{\emph{laf\_source}}] \leavevmode
change into the directory name of your LAF directory.

\item[{\emph{source\_choices}}] \leavevmode
Normally, a LAF resource has a \emph{LAF-header file} and a \emph{primary data header file}, aka. \emph{the GrAF header file}.
The workbench needs to look at a \emph{GrAF header file}.
This header file has references to all files that make up the resource.
You might want to restrict the workbench to only part of the annotation files in the resource,
e.g. if there are big annotation files that do not contain features that are relevant for your analysis.
In that case, you can copy the original GrAF header file,
and leave out all references to files that you do not want to take into consideration.
The \emph{source\_choices} dictionary must contain all GrAF header files that you want to choose from.

\end{description}
\phantomsection\label{workbench:task-dir}\begin{description}
\item[{\emph{task\_dir}}] \leavevmode
The directory in which your tasks can be found. If you have your own tasks outside this distribution,
adapt \emph{task\_dir} to point to that. By default, \emph{task\_dir} points to the directory with example tasks
that come with the distribution of the workbench.

\end{description}

You probably do not need to change the following settings, since they are used for generating subdirectories under control of
the workbench.
\begin{description}
\item[{\emph{compiled\_source}}] \leavevmode
master directory that holds the binary data, compiled from the LAF original,plus the output of tasks,
organized by source and then task.

\item[{\emph{bin\_subdir}}] \leavevmode
subdirectory within \emph{compiled\_source} for the binary data only

\item[{\emph{feat\_subdir}}] \leavevmode
subdirectory within \emph{bin\_subdir} for the feature data only

\end{description}

Now you are set to run your tasks.
You might want to run an example task from the examples in the \emph{tasks} directory
but they might fail because they refer to features that might not occur in your resource.
You can also write a task yourself and add it to the \emph{tasks} directory. See {\hyperref[taskwriting::doc]{\emph{Writing Tasks}}}.


\subsection{Usage}
\label{workbench:usage}
Go to the directory where \emph{laf-fabric.py} resides:

\begin{Verbatim}[commandchars=\\\{\}]
cd «path\_to\_dir\_of\_laf-fabric.py»
\end{Verbatim}

\emph{single use mode}:

\begin{Verbatim}[commandchars=\\\{\}]
python laf-fabric.py --source=«source» --task=«task» [--force-compile]
\end{Verbatim}

\emph{to start the command interpreter mode}:

\begin{Verbatim}[commandchars=\\\{\}]
python laf-fabric.py [--source=«source» ] [--task=«task» ] [--force-compile]
\end{Verbatim}

The workbench is a Python program that is invoked from the command line.
\begin{description}
\item[{\emph{interactive use mode}}] \leavevmode
If either or both of the \code{«source»} and \code{«task»} arguments are missing or if the \code{-{-}menu} argument is present
it starts in interactive mode prompting you for sources and commands to run tasks.
The \code{«source»} and \code{«task»} arguments are given are used for initial values.
In interactive mode you can change your \code{«source»} and \code{«task»} selection, and run tasks.
the need for it. There is a help command and the prompt is self explanatory.

\item[{\emph{single use mode}}] \leavevmode
If both the \code{«source»} and \code{«task»} arguments are present and if the \code{-{-}menu} argument is absent
the workbench runs the specified task without asking and quits.

\end{description}


\subsection{Other options}
\label{workbench:other-options}\begin{description}
\item[{\code{-{-}force-compile}}] \leavevmode
If you have changed the LAF resource, the workbench will detect it and recompile it.
The detection is based on the modified dates of the GrAF header file and the compiled files.
In cases where the workbench did not detect a change, but you need to recompile, use this flag.
In interactive mode, there is a command to force recompilation of the current source.

\end{description}


\section{Designed for Performance}
\label{workbench:designed-for-performance}
Since there is a generic LAF tool for smaller resources, this tool has been designed with performance in mind.
In fact, performance has been the most important design criterion of all
In this section the decision and particulars are listed.
There are also a few simplifications involved, see the section of GrAF {\hyperref[workbench:feature-coverage]{\emph{GrAF feature coverage}}} below.

There are several ideas involved in compiling a LAF resource into something that is compact, fast loadable, and amenable to efficient computing.
\begin{enumerate}
\item {} 
Replace everything by integers (nearly everything)

\item {} 
Store relationships between integers in \emph{arrays}, that is, Python arrays

\item {} 
Store relationships between integers and sets of integers also in \emph{arrays}.

\end{enumerate}


\subsection{Explanation of these ideas}
\label{workbench:explanation-of-these-ideas}
\textbf{Everything is integer}
In LAF the pieces of data are heavily connected, and the expression of the connections are XML identifiers.
Besides that, absolutely everything gets an identifier, whether or not those identifiers are targeted or not.
In the compiled version we get rid of all identifiers.
Everything: regions, nodes, edges, features, feature names, feature values, annotation labels will end up in an array,
and hence can be identified by its numerical index in that array.
For the only things that are essentially not integers (feature names, feature values, annotation labels) we will create mapping tables.

\textbf{Relationships between integers as Python arrays}
In Python, an array is a C-like structure of memory slots of fixed size.
You do not have arrays of arrays, nor arrays with mixed types.
This makes array handling very efficient, especially loading data from disk and saving it to disk.
Moreover, the amount of space in memory needed is like in C, without the overhead a scripting language usually adds to its data types.

There is an other advantage:
a mapping normally consists of two columns of numbers, and numbers in the left column map to numbers in the right column.
In the case of arrays of integers, we can leave out the left column: it is the array index, and does not have to be stored.

\textbf{Relationships between integers as Python arrays}
If we want to map numbers to sets of numbers,
we need to be more tricky, because we cannot store sets of numbers as integers.
What we do instead is: we build two arrays, the first array points to data records in the second array.
A data record in the second array consists of a number giving the length of the record,
followed by that number of integers.
The function {\hyperref[graf/graf:graf.model.arrayify]{\code{arrayify()}}} takes a list of items and turns it in a double array.


\subsection{Consequences}
\label{workbench:consequences}
The concrete XML identifiers present in the LAF resource get lost.
Whoever designs a LAF resource to be worked on by this workbench,
should not rely on the values of the XML identifiers to derive implicit meanings from.
I did that in initial stages, producing identifiers \code{n\_1, n\_2, e\_1, e\_2} etcetera for node 1, 2 and edge 1, 2.
There is nothing wrong with such identifiers, but do not expect to determine in your tasks whether
something is a node or edge by looking at an identifier.


\section{GrAF feature coverage}
\label{workbench:feature-coverage}\label{workbench:graf-feature-coverage}
This tool cannot deal with LAF resources in their full generality.

In LAF, annotations have labels, and annotations are organized in annotation spaces.
So an annotation space and a label uniquely define a kind of annotation.
The content of an annotation can be a feature structure.
A feature structure is a set of features and sub features, ordered again as a graph.
These are the main simplifications:
\begin{description}
\item[{\emph{annotation spaces}}] \leavevmode
The workbench ignores annotation spaces altogether.
So annotations are only grouped by annotation labels.

\item[{\emph{feature structures}}] \leavevmode
This workbench can deal with feature structures that are merely sets of key-value pairs.
The graph-like model of features and subfeatures is not supported.

\item[{\emph{annotations}}] \leavevmode
Even annotations get lost. The workbench is primarily interested in features and values.
It forgets the annotations in which they have been packaged except for:
* the annotation label,
* the target of the annotation (node or edge)
So in order to retrieve a feature value, one must specify
an annotation label, a feature name, and a node or edge
to which the annotation containing the feature had been attached.

\item[{\emph{dependencies}}] \leavevmode
In LAF one can specify the dependencies of the files containing regions, nodes, edges and/or annotations.
The workbench assumes that all dependent files are present in the resource.
Hence the workbench reads all files mentioned in the GrAF header, in no particular order.

\end{description}


\section{Development}
\label{workbench:development}

\subsection{API completion}
\label{workbench:api-completion}
Many reasonable candidates for an API have not yet been implemented. Basically we have only:
\begin{description}
\item[{\emph{node iterator}}] \leavevmode
iterator that produces nodes in the order by which they are anchored to the primary data (which are linearly ordered)

\item[{\emph{feature lookup}}] \leavevmode
a function that gives the value of a feature attached by some annotation to some edge or node

\end{description}

Now Python does not have strict encapsulation of data structures,
so by just inspecting the classes and objects you can reach out
for all aspects of the LAF data that went into the compiled data.
See the GrAF {\hyperref[workbench:feature-coverage]{\emph{GrAF feature coverage}}} for a specification of what data ends up in the compilation.


\chapter{Writing Tasks}
\label{taskwriting:writing-tasks}\label{taskwriting::doc}

\section{What is a task?}
\label{taskwriting:what-is-a-task}
A task is an ordinary Python script with some magical capabilities
for looking into a LAF resource (a \emph{compiled} LAF resource to be precise).

A task gets those capabilities because it is called by the workbench.
In order to be called by the workbench, you have to put into the \emph{tasks} directory
(see {\hyperref[workbench:task-dir]{\emph{configuration}}}).

The workbench passes an object to your task,
which contains the information needed to peek into the LAF resource.
Conversely, in your task script you can pass some initialization information to the workbench,
so that it can build or load the appropriate feature data.

Apart from these things, your script may contain arbitrary Python code,
it may import arbitrary modules.
The workbench is agnostic of your code.


\section{A leading example}
\label{taskwriting:a-leading-example}
Our target LAF resource is the Hebrew text data base (see {\hyperref[overview:data]{\emph{Data}}}).
In the text database there are objects carrying features.
The conversion to LAF has translated objects in to nodes, and relationships between objects into edges.
The features of the text database have been grouped and put into annotations, which carry labels.
Objects have types in the database.
The types of objects translate to annotations with label \emph{db} with the feature \emph{otype}.
Likewise the \emph{id} of objects translates into feature \emph{db.oid}.
The anchoring of objects to primary data: the features \emph{minmonad}, \emph{maxmonad} and \emph{monads} take care of that.
In the original LAF it looks like this:

\begin{Verbatim}[commandchars=\\\{\}]
\textless{}node xml:id="n28737"\textgreater{}\textless{}link targets="w\_1 w\_2 w\_3 w\_4 w\_5 w\_6 w\_7 w\_8 w\_9 w\_10 w\_11"/\textgreater{}\textless{}/node\textgreater{}
\textless{}a xml:id="al28737" label="db" ref="n28737"\textgreater{}\textless{}fs\textgreater{}
    \textless{}f name="otype" value="clause"/\textgreater{}
    \textless{}f name="oid" value="28737"/\textgreater{}
    \textless{}f name="monads" value="1-11"/\textgreater{}
    \textless{}f name="minmonad" value="1"/\textgreater{}
    \textless{}f name="maxmonad" value="11"/\textgreater{}
\textless{}/fs\textgreater{}\textless{}/a\textgreater{}
\end{Verbatim}


\section{More on features}
\label{taskwriting:more-on-features}
When the workbench compiles features into binary data, it forgets the annotations in which the features come,
but the annotation \emph{label} is retained as a prefix to the feature name.
In the example above, you see an annotation with label \code{db} and in it a feature structure
with features named \code{otype}, \code{oid}, etc.
The workbench remembers those features by their \emph{fully qualified} names: \code{db.otype}, \code{db.oid} etc.
There may also be annotations without feature contents. Such annotations will be stored as features with as name the
annotation label only, without the dot: \code{db}.

\begin{notice}{note}{Note:}
Annotations may reference nodes or edges.
It is possible that nodes and edges have features with the same name.
However, the workbench maintains a strict distinction between features
of nodes and features of edges. They have separate name spaces, implicitly.
The API has different methods to the address the features of nodes and edges.
And features names that are used for nodes and edges may coexist, but their
internal representations are separate tables.
\end{notice}

The example task \emph{object.py} lists all objects in ``resource order'' with their original ids,
object types etc and even their node number in the compiled resource.
Not very useful, but handy for debugging or linking new annotation files to the existing data.
Here is a snippet of output:

\begin{Verbatim}[commandchars=\\\{\}]
 426500   28737 clause               \PYGZob{}1-11         \PYGZcb{}
 514887   34680 clause\_atom          \PYGZob{}1-11         \PYGZcb{}
1131695   84383 sentence             \PYGZob{}1-11         \PYGZcb{}
1203049   88917 sentence\_atom        \PYGZob{}1-11         \PYGZcb{}
1385280   95056 half\_verse           \PYGZob{}1-4          \PYGZcb{}
 604948   59556 phrase               \PYGZob{}1-2          \PYGZcb{}
 862057   40767 phrase\_atom          \PYGZob{}1-2          \PYGZcb{}
      1       2 word                 \PYGZob{}1            \PYGZcb{}
      2       3 word                 \PYGZob{}2            \PYGZcb{}
      3       4 word                 \PYGZob{}3            \PYGZcb{}
 604949   59557 phrase               \PYGZob{}3            \PYGZcb{}
 862058   40768 phrase\_atom          \PYGZob{}3            \PYGZcb{}
      4       5 word                 \PYGZob{}4            \PYGZcb{}
\end{Verbatim}

Note the same clause object \emph{28737} as in the original LAF file.
Finally, here is the complete Python code of the task that produced this output:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{features} \PYG{o}{=} \PYG{p}{\PYGZob{}}
        \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{node}\PYG{l+s}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{db:oid,otype,monads}\PYG{l+s}{\PYGZdq{}}\PYG{p}{,}
        \PYG{l+s}{\PYGZdq{}}\PYG{l+s}{edge}\PYG{l+s}{\PYGZdq{}}\PYG{p}{:} \PYG{l+s}{\PYGZsq{}}\PYG{l+s}{\PYGZsq{}}\PYG{p}{,}
\PYG{p}{\PYGZcb{}}

\PYG{k}{def} \PYG{n+nf}{task}\PYG{p}{(}\PYG{n}{graftask}\PYG{p}{)}\PYG{p}{:}
        \PYG{p}{(}\PYG{n}{msg}\PYG{p}{,} \PYG{n}{NNi}\PYG{p}{,} \PYG{n}{NNr}\PYG{p}{,} \PYG{n}{NEi}\PYG{p}{,} \PYG{n}{NEr}\PYG{p}{,} \PYG{n}{Vi}\PYG{p}{,} \PYG{n}{Vr}\PYG{p}{,} \PYG{n}{NN}\PYG{p}{,} \PYG{n}{NNFV}\PYG{p}{,} \PYG{n}{FNi}\PYG{p}{,} \PYG{n}{FNr}\PYG{p}{,} \PYG{n}{FEi}\PYG{p}{,} \PYG{n}{FEr}\PYG{p}{)} \PYG{o}{=} \PYG{n}{graftask}\PYG{o}{.}\PYG{n}{get\PYGZus{}mappings}\PYG{p}{(}\PYG{p}{)}

        \PYG{n}{out} \PYG{o}{=} \PYG{n}{graftask}\PYG{o}{.}\PYG{n}{add\PYGZus{}result}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{output.txt}\PYG{l+s}{\PYGZdq{}}\PYG{p}{)}

        \PYG{k}{for} \PYG{n}{i} \PYG{o+ow}{in} \PYG{n}{NN}\PYG{p}{(}\PYG{p}{)}\PYG{p}{:}
                \PYG{n}{oid} \PYG{o}{=} \PYG{n}{FNr}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{n}{NNi}\PYG{p}{[}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{db.oid}\PYG{l+s}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{)}
                \PYG{n}{otype} \PYG{o}{=} \PYG{n}{FNr}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{n}{NNi}\PYG{p}{[}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{db.otype}\PYG{l+s}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{)}
                \PYG{n}{monads} \PYG{o}{=} \PYG{n}{FNr}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{n}{NNi}\PYG{p}{[}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{db.monads}\PYG{l+s}{\PYGZdq{}}\PYG{p}{]}\PYG{p}{)}
                \PYG{n}{out}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}}\PYG{l+s}{\PYGZob{}:\PYGZgt{}7\PYGZcb{} \PYGZob{}:\PYGZgt{}7\PYGZcb{} \PYGZob{}:\PYGZlt{}20\PYGZcb{} \PYGZob{}\PYGZob{}\PYGZob{}:\PYGZlt{}13\PYGZcb{}\PYGZcb{}\PYGZcb{}}\PYG{l+s+se}{\PYGZbs{}n}\PYG{l+s}{\PYGZdq{}}\PYG{o}{.}\PYG{n}{format}\PYG{p}{(}\PYG{n}{i}\PYG{p}{,} \PYG{n}{oid}\PYG{p}{,} \PYG{n}{otype}\PYG{p}{,} \PYG{n}{monads}\PYG{p}{)}\PYG{p}{)}
\end{Verbatim}


\section{Information flow from task to workbench}
\label{taskwriting:information-flow-from-task-to-workbench}
The main thing the workbench needs to know about the task are directives for its processing.
The task needs to be told for which features data should be loaded.
This must be specified separately for features that occur on nodes and that occur on edges.

The feature specification takes the form of a space separated string of items of the form:

\begin{Verbatim}[commandchars=\\\{\}]
«annotation label»:«unqualified feature names»
\end{Verbatim}

where \code{«unqualified feature names»} is a comma separated list of feature names without annotation labels.
For all implied features \code{«annotion label»:«feature name»} data will be loaded.
For all other features data will be unloaded, if still loaded.

\begin{notice}{caution}{Caution:}
Missing feature data.
\begin{description}
\item[{If you forget to mention a feature in the directives,}] \leavevmode
the workbench will deliver the value \code{None},
even if the compiled LAF has a real value there.

\item[{The reason for this behaviour is that it is to costly}] \leavevmode
to let every feature lookup check whether its data has been loaded.

\end{description}
\end{notice}


\section{Information flow from workbench to task}
\label{taskwriting:information-flow-from-workbench-to-task}
The workbench will call the function \emph{task(object)} in your task script,
and the thing that is passed to it as \emph{object} is an object of
class {\hyperref[graf/graf:graf.task.GrafTask]{\code{GrafTask}}}.
By using this object, you have to access all of its methods.

In order to write an efficient task,
it is convenient to import the names of the most important methods as \emph{local variables} of the \emph{task} function.
The lookup of names in Python is fastest for local names.
And it makes the code much cleaner.

The method {\hyperref[graf/graf:graf.task.GrafTask.get_mappings]{\code{get\_mappings()}}} delivers the methods,
and it is up to you to give them names.
It is recommended to stick to the names provided here in this example.
Here is a short description of the corresponding methods.
\begin{description}
\item[{\emph{FNi()} and \emph{FNr()}, \emph{FEi()} and \emph{FEr()}}] \leavevmode
The \emph{FNx} versions need a node, the \emph{FEx} versions and edge,
then they need an a qualified feature name.
They return the value that the feature carries on that node or edge.
The \emph{FXi} versions return the value code that the compiler has assigned
to the real value (read \emph{i} as \emph{internal}).
The \emph{FXr} versions return the real values as strings, exactly as
they appear in the original LAF resource (read \emph{r} as \emph{real}).

All arguments must be given as integers,
the integers to which nodes and labels and names have been mapped during compiling.
(There are ways to get those numbers).
Use \emph{FXi} versions when the value is needed in other parts of your script,
and the \emph{FXr} versions when you need to output values.

\item[{\emph{NNi}, \emph{NEi} and \emph{NNr}, \emph{NEr}}] \leavevmode
Tables to convert between qualified feature names as real values
found in the original LAF and the integers they have been mapped to during compilation.
\emph{NXi} yields integers from string representations,
\emph{NXr} yields representations (strings) from internal integers.
\emph{XNx} is for features on nodes,
\emph{XEx} is for features on edges.

\item[{\emph{Vi} and \emph{Vr}}] \leavevmode
Same pattern as above, but now for feature values.

\item[{\emph{NN()} and \emph{NNFV()}}] \leavevmode
\emph{iterators} that yield a new node everytime they are called.
They yield the nodes in so-called \emph{primary data order}, which will be explained below.
The difference between \emph{NN()} and \emph{NNFV()} is
that \emph{NN()} iterates over absolutely all nodes,
and \emph{NNFV()} only yields node that have a certain value for a certain feature.
See {\hyperref[graf/graf:module-graf.task]{\code{GrafTask}}},
methods {\hyperref[graf/graf:graf.task.GrafTask.next_node]{\code{nextnode()}}}
and {\hyperref[graf/graf:graf.task.GrafTask.next_node_with_fval]{\code{next\_node\_with\_fval()}}}.

\end{description}


\section{Output}
\label{taskwriting:output}
You can create an output filehandle, open for writing, by calling the
method {\hyperref[graf/graf:graf.task.GrafTask.add_result]{\code{add\_result()}}}
of the {\hyperref[graf/graf:module-graf.task]{\code{GrafTask}}} class
and assigning the result to a variable, say \emph{out}.
From then on you can write output simply by saying:

\begin{Verbatim}[commandchars=\\\{\}]
\PYG{n}{out}\PYG{o}{.}\PYG{n}{write}\PYG{p}{(}\PYG{n}{text}\PYG{p}{)}
\end{Verbatim}

You can create as many output handles as you like in this way.
Once your task has finished, the workbench will close them all.


\section{Node order}
\label{taskwriting:node-order}\label{taskwriting:id1}
There is an implicit partial order on nodes, derived from their attachment to \emph{regions}
which are stretches of primary data, and the primary data is totally ordered.
The order we use in the workbench is defined as follows.

Suppose we compare node \emph{A} and node \emph{B}.
Look up all regions for \emph{A} and for \emph{B} and determine the first point of the first region
and the last point of the last region for \emph{A} and \emph{B}, and call those points \emph{Amin, Amax}, \emph{Bmin, Bmax} respectively.

Then region \emph{A} comes before region \emph{B} if and only if \emph{Amin} \textless{} \emph{Bmin} or \emph{Amin} = \emph{Bmin} and \emph{Amax} \textgreater{} \emph{Bmax}.

In other words: if \emph{A} starts before \emph{B}, then \emph{A} becomes before \emph{B}.
If \emph{A} and \emph{B} start at the same point, the one that ends last, counts as the earlier of the two.

If neither \emph{A} \textless{} \emph{B} nor \emph{B} \textless{} \emph{A} then the order is not specified.
The workbench will select an arbitrary but consistent order between thoses nodes.
The only way this can happen is when \emph{A} and \emph{B} start and end at the same point.
Between those points they might be very different.

The nice property of this ordering is that if a set of nodes consists of a proper hierarchy with respect to embedding,
the order specifies a walk through the nodes were enclosing nodes come first,
and embedded children come in the order dictated by the primary data.


\chapter{tasks}
\label{tasks/modules:tasks}\label{tasks/modules::doc}

\section{esther module}
\label{tasks/esther:esther-module}\label{tasks/esther::doc}\label{tasks/esther:module-esther}\index{esther (module)}\index{task() (in module esther)}

\begin{fulllineitems}
\phantomsection\label{tasks/esther:esther.task}\pysiglinewithargsret{\bfcode{task}}{\emph{graftask}}{}
Collect frequency data of common nouns in Esther per bible book.

This is part of reproducing results in Martijn Naaijer's thesis.

We count lexemes of common nouns throughout the bible
and we deliver a table of counts of all lexemes and a table of
frequencies of lexemes restricted to the common nouns of Esther.

When counting lexemes, we count the occurrences of \emph{words}.
If \emph{word1} and \emph{word2} have \emph{n1} and \emph{n2} occurrences, and both
have the same \emph{lexeme}, then \emph{lexeme} has \emph{n1} plus \emph{n2}
occurrences.

When we compute frequencies, we divide lexeme occurrences as defined
above by the total number of word occurrences.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\emph{lexemes\_all.txt (file)} --
a table of all lexemes, ordered by bible book, with the number
of occurrences in that bible book.
lexemes\_esther.txt (file): a matrix with as rows the lexemes of
common nouns in Esther and as columns the books of the bible.
A cell contain the frequency of that lexeme in that book multiplied by 1000

\end{description}\end{quote}

\end{fulllineitems}



\section{gender module}
\label{tasks/gender::doc}\label{tasks/gender:gender-module}\label{tasks/gender:module-gender}\index{gender (module)}\index{task() (in module gender)}

\begin{fulllineitems}
\phantomsection\label{tasks/gender:gender.task}\pysiglinewithargsret{\bfcode{task}}{\emph{graftask}}{}
\end{fulllineitems}



\section{involved module}
\label{tasks/involved::doc}\label{tasks/involved:involved-module}\label{tasks/involved:module-involved}\index{involved (module)}\index{task() (in module involved)}

\begin{fulllineitems}
\phantomsection\label{tasks/involved:involved.task}\pysiglinewithargsret{\bfcode{task}}{\emph{graftask}}{}
\end{fulllineitems}



\section{isaiah module}
\label{tasks/isaiah:module-isaiah}\label{tasks/isaiah:isaiah-module}\label{tasks/isaiah::doc}\index{isaiah (module)}\index{task() (in module isaiah)}

\begin{fulllineitems}
\phantomsection\label{tasks/isaiah:isaiah.task}\pysiglinewithargsret{\bfcode{task}}{\emph{graftask}}{}
\end{fulllineitems}



\section{lingo module}
\label{tasks/lingo:lingo-module}\label{tasks/lingo:module-lingo}\label{tasks/lingo::doc}\index{lingo (module)}\index{task() (in module lingo)}

\begin{fulllineitems}
\phantomsection\label{tasks/lingo:lingo.task}\pysiglinewithargsret{\bfcode{task}}{\emph{graftask}}{}
\end{fulllineitems}



\section{objects module}
\label{tasks/objects:module-objects}\label{tasks/objects:objects-module}\label{tasks/objects::doc}\index{objects (module)}\index{task() (in module objects)}

\begin{fulllineitems}
\phantomsection\label{tasks/objects:objects.task}\pysiglinewithargsret{\bfcode{task}}{\emph{graftask}}{}
\end{fulllineitems}



\section{plain module}
\label{tasks/plain:plain-module}\label{tasks/plain::doc}\label{tasks/plain:module-plain}\index{plain (module)}\index{task() (in module plain)}

\begin{fulllineitems}
\phantomsection\label{tasks/plain:plain.task}\pysiglinewithargsret{\bfcode{task}}{\emph{graftask}}{}
\end{fulllineitems}



\section{proper module}
\label{tasks/proper:module-proper}\label{tasks/proper::doc}\label{tasks/proper:proper-module}\index{proper (module)}\index{task() (in module proper)}

\begin{fulllineitems}
\phantomsection\label{tasks/proper:proper.task}\pysiglinewithargsret{\bfcode{task}}{\emph{graftask}}{}
An exercise in visualizing and distant reading.

We count proper nouns and their relative frequencies, we record the gender of the nouns.
We produce output in various tables.

We also produce a projection of the complete bible text to a set of symbols,
where verbs map to ♠, male proper nouns to ♂,
female proper nouns to ♀, and unknown gender proper nouns to ⊙.
All other words map to a dash. Moreover, the sentence, clause and phrase
structure is also rendered by means of boundary characters.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
\emph{output.txt (file)} --
the projection of the full text as described above
stats\_v\_raw.txt (file): a table with per verse counts for words, verbs, proper nouns per gender
stats\_v\_compact.txt (file): a table with per verse frequencies for verbs, and proper nouns
stats\_c\_compact.txt (file): a table with per chapter frequencies for verbs, and proper nouns

\end{description}\end{quote}

\end{fulllineitems}



\chapter{graf}
\label{graf/modules::doc}\label{graf/modules:graf}

\section{graf package}
\label{graf/graf:graf-package}\label{graf/graf::doc}

\subsection{Submodules}
\label{graf/graf:submodules}

\subsection{graf.compiler module}
\label{graf/graf:module-graf.compiler}\label{graf/graf:graf-compiler-module}\index{graf.compiler (module)}\index{GrafCompiler (class in graf.compiler)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.compiler.GrafCompiler}\pysiglinewithargsret{\strong{class }\bfcode{GrafCompiler}}{\emph{env}}{}
Bases: {\hyperref[graf/graf:graf.graf.Graf]{\code{graf.graf.Graf}}}

Takes care of the compilation of LAF xml data into binary data.

There are two stages in compilation:
\begin{itemize}
\item {} 
parsing the XML data by means of a SAX parser (a lengthy process)

\item {} 
remodeling the parse results in really tight data structures

\end{itemize}

Upon creation, the relevant directories are communicated.

The initialization of the base class is performed, and we change working directory to the location of the LAF source.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{env} (\emph{str}) --
path information

\end{description}\end{quote}
\index{compiler() (GrafCompiler method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.compiler.GrafCompiler.compiler}\pysiglinewithargsret{\bfcode{compiler}}{\emph{force=False}}{}
Manages the complete compilation process.

Detects the need for compiling, responds to the \emph{force} argument. Then parses, remodels and writes.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{force} (\emph{bool}) --
whether to compile even if the binary data looks up to date.

\end{description}\end{quote}

\end{fulllineitems}

\index{env (GrafCompiler attribute)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.compiler.GrafCompiler.env}\pysigline{\bfcode{env}\strong{ = None}}
Instance member to hold config settings etc

\end{fulllineitems}

\index{has\_compiled (GrafCompiler attribute)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.compiler.GrafCompiler.has_compiled}\pysigline{\bfcode{has\_compiled}\strong{ = None}}
Instance member to tell whether compilation has actually taken place

\end{fulllineitems}

\index{model() (GrafCompiler method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.compiler.GrafCompiler.model}\pysiglinewithargsret{\bfcode{model}}{}{}
Call the remodeler and store the remodeled data in the object.

\end{fulllineitems}

\index{needs\_compiling() (GrafCompiler method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.compiler.GrafCompiler.needs_compiling}\pysiglinewithargsret{\bfcode{needs\_compiling}}{}{}
Checks whether the compiled binary data is still up to date.

The criterion is whether the generated statistics file at the binary side is newer than the chosen GrAF header file.

\end{fulllineitems}

\index{parse() (GrafCompiler method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.compiler.GrafCompiler.parse}\pysiglinewithargsret{\bfcode{parse}}{}{}
Call the XML parser and collect the parse results.

Some parse results must be remodelled afterwards.
After remodelling some parse data can be thrown away.
Only store data that is needed for task execution in the object.

The actual parsing is done in the module {\hyperref[graf/graf:module-graf.parse]{\code{parse}}}.

\end{fulllineitems}

\index{temp\_data\_items (GrafCompiler attribute)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.compiler.GrafCompiler.temp_data_items}\pysigline{\bfcode{temp\_data\_items}\strong{ = \{\}}}
Holds some data delivered by the parsed that can be thrown away later. The data that we must keep is stored in the object, of course.

\end{fulllineitems}

\index{write\_data() (GrafCompiler method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.compiler.GrafCompiler.write_data}\pysiglinewithargsret{\bfcode{write\_data}}{}{}
Writes compiled data to disk.

Compiled data has three possible types:
\begin{description}
\item[{\emph{0: plain array}}] \leavevmode
can be written fast with the \code{array.tofile()} method

\item[{\emph{1: array valued dict}}] \leavevmode
a dictionary, keyed by a feature name and with arrays as values

\item[{\emph{2: list of trings}}] \leavevmode
can be dumped with the \code{cPickle.dump()} method.

\end{description}

\end{fulllineitems}


\end{fulllineitems}



\subsection{graf.graf module}
\label{graf/graf:module-graf.graf}\label{graf/graf:graf-graf-module}\index{graf.graf (module)}\index{Graf (class in graf.graf)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.graf.Graf}\pysigline{\strong{class }\bfcode{Graf}}
Bases: \code{object}

Base class for compiling LAF resources and running analytic tasks on them.

This class has only a rudimentary method set. Compiling a LAF resource is done by the GrafCompiler derived class
and running analytic tasks is done by the GrafTask class.

The data of this class represents the compiled data on the basis of which tasks can run.
This data is created by a {\hyperref[graf/graf:graf.compiler.GrafCompiler]{\code{GrafCompiler}}} that derives from this class.

Upon creation, empty datastructures are initialized to hold the binary,
compiled LAF data and create a directory for their serializations on disk.

The Graf object holds information that Graf tasks need to perform their operations.
The most important piece of information is the data itself.
This data consists of arrays and dictionaries that together hold the information that is compiled from a LAF resource.

Other things that happen:
\begin{enumerate}
\item {} 
a fresh Timestamp object is created, which records the current time and can issue progress messages containing the amount
of time that has elapsed since this object has been created.

\item {} 
if the directory that should hold the compiled data does not exist,
a new directory is created Of course this means that before executing any tasks,
the LAF resource has to be (re)compiled.

\end{enumerate}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
object with data structures initialized, ready to load the compiled data from disk.

\end{description}\end{quote}
\index{BIN\_EXT (Graf attribute)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.graf.Graf.BIN_EXT}\pysigline{\bfcode{BIN\_EXT}\strong{ = `bin'}}
extension for binary files

\end{fulllineitems}

\index{COMPILE\_TASK (Graf attribute)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.graf.Graf.COMPILE_TASK}\pysigline{\bfcode{COMPILE\_TASK}\strong{ = `compile'}}
name of the compile task

\end{fulllineitems}

\index{LOG\_NAME (Graf attribute)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.graf.Graf.LOG_NAME}\pysigline{\bfcode{LOG\_NAME}\strong{ = `\_\_log\_\_'}}
log file base name for a task

\end{fulllineitems}

\index{STAT\_NAME (Graf attribute)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.graf.Graf.STAT_NAME}\pysigline{\bfcode{STAT\_NAME}\strong{ = `\_\_stat\_\_'}}
statistics file base name for a task

\end{fulllineitems}

\index{TEXT\_EXT (Graf attribute)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.graf.Graf.TEXT_EXT}\pysigline{\bfcode{TEXT\_EXT}\strong{ = `txt'}}
extension for text files

\end{fulllineitems}

\index{\_\_del\_\_() (Graf method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.graf.Graf.__del__}\pysiglinewithargsret{\bfcode{\_\_del\_\_}}{}{}
Clean up

Close all file handles that are still open.

\end{fulllineitems}

\index{add\_logfile() (Graf method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.graf.Graf.add_logfile}\pysiglinewithargsret{\bfcode{add\_logfile}}{\emph{location=None}, \emph{name=None}}{}
Create and open a log file for a given task.

When tasks run, they generate progress messages with timing information in them.
They may issue errors and warnings. All this information also goes into a log file.
The log file is placed in the result directory of the task at hand.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{location} (\emph{str}) --
override default directory for log file

\item {} 
\textbf{name} (\emph{str}) --
override default name for log file

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{data\_items (Graf attribute)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.graf.Graf.data_items}\pysigline{\bfcode{data\_items}\strong{ = None}}
Instance member holding the compiled data in the form of a dictionary of arrays and lists.

See the {\hyperref[graf/graf:module-graf.compiler]{\code{compiler}}} and {\hyperref[graf/graf:module-graf.model]{\code{model}}} modules for the way the compiled data is organised.

\end{fulllineitems}

\index{edge\_feat (Graf attribute)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.graf.Graf.edge_feat}\pysigline{\bfcode{edge\_feat}\strong{ = None}}
Feature data (for features on edges) stored in dictionary for fast access

\end{fulllineitems}

\index{env (Graf attribute)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.graf.Graf.env}\pysigline{\bfcode{env}\strong{ = None}}
Holds the environment parameters for the current task

\end{fulllineitems}

\index{init\_data() (Graf method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.graf.Graf.init_data}\pysiglinewithargsret{\bfcode{init\_data}}{}{}
Resets all loaded data to initial values

This is needed when the task processor switches from one source to another,
or when a recompile has been performed.

\end{fulllineitems}

\index{log (Graf attribute)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.graf.Graf.log}\pysigline{\bfcode{log}\strong{ = None}}
handle of a log file, open for writing

\end{fulllineitems}

\index{node\_feat (Graf attribute)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.graf.Graf.node_feat}\pysigline{\bfcode{node\_feat}\strong{ = None}}
Feature data (for features on nodes) stored in dictionary for fast access

\end{fulllineitems}

\index{progress() (Graf method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.graf.Graf.progress}\pysiglinewithargsret{\bfcode{progress}}{\emph{msg}}{}
Convenience method to call the progress of the associated stamp directly from the Graf object

\end{fulllineitems}

\index{read\_stats() (Graf method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.graf.Graf.read_stats}\pysiglinewithargsret{\bfcode{read\_stats}}{}{}
Read compilation statistics from file

The compile process generates some statistics that must be read by the task that loads the compiled data.

\end{fulllineitems}

\index{set\_environment() (Graf method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.graf.Graf.set_environment}\pysiglinewithargsret{\bfcode{set\_environment}}{\emph{source}, \emph{task}}{}
Set the source and result locations for a task execution.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{source} (\emph{str}) --
key for the source

\item {} 
\textbf{task} --
the chosen task

\end{itemize}

\end{description}\end{quote}

Sets \emph{self.env}, a dictionary containg:
\begin{itemize}
\item {} 
source: \emph{source}

\item {} 
task: \emph{task}

\item {} 
compile (bool): whether to force (re)compilation

\item {} 
settings (\href{http://docs.python.org/library/configparser.html\#ConfigParser.ConfigParser}{\code{ConfigParser.ConfigParser}}): entries corresponding to the main configuration file

\item {} 
additional computed settings adapt to the current source and task

\end{itemize}

\end{fulllineitems}

\index{stamp (Graf attribute)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.graf.Graf.stamp}\pysigline{\bfcode{stamp}\strong{ = None}}
Instance member holding the {\hyperref[graf/graf:graf.timestamp.Timestamp]{\code{Timestamp}}} object.

\end{fulllineitems}

\index{write\_stats() (Graf method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.graf.Graf.write_stats}\pysiglinewithargsret{\bfcode{write\_stats}}{}{}
Write compilation statistics to file

The compile process generates some statistics that must be read by the task that loads the compiled data.

\end{fulllineitems}


\end{fulllineitems}

\index{GrafException}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.graf.GrafException}\pysiglinewithargsret{\strong{exception }\bfcode{GrafException}}{\emph{message}, \emph{stamp}, \emph{Errors}}{}
Bases: \code{exceptions.Exception}

\end{fulllineitems}



\subsection{graf.model module}
\label{graf/graf:graf-model-module}\label{graf/graf:module-graf.model}\index{graf.model (module)}\index{arrayify() (in module graf.model)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.model.arrayify}\pysiglinewithargsret{\bfcode{arrayify}}{\emph{source\_list}}{}
Efficient storage of a list of lists of integers in two Python \href{http://docs.python.org/library/array.html\#module-array}{\code{array}}.

\emph{This is one of the most important tricks of the whole workbench, and yet it is only 10 lines of code!}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{source\_list} (\emph{iterable}) --
a list of lists of integers

\item[{Returns}] \leavevmode
\emph{(index\_array, items\_array)} --
two \href{http://docs.python.org/library/array.html\#module-array}{\code{array}} s.
\emph{index\_array} contains an index for each item in \emph{source\_list}.
\emph{items\_array} contains all the items in the following way: if an item with \emph{n} members has to be added,
then first the number \emph{n} is added, and then all the members.
This is how you get the original information back: if you want the
members of item \emph{i} in \emph{source\_list}, read number \emph{i} in \emph{index\_array}, say \emph{k}, go to position \emph{k} in
\emph{items\_array}, read the number at that position, say \emph{n},
and then find the members at the next \emph{n} positions in \emph{items\_array}.

\end{description}\end{quote}

\end{fulllineitems}

\index{model() (in module graf.model)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.model.model}\pysiglinewithargsret{\bfcode{model}}{\emph{data\_items}, \emph{temp\_data\_items}, \emph{stamp}}{}
\end{fulllineitems}



\subsection{graf.parse module}
\label{graf/graf:graf-parse-module}\label{graf/graf:module-graf.parse}\index{graf.parse (module)}\index{AnnotationHandler (class in graf.parse)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.parse.AnnotationHandler}\pysiglinewithargsret{\strong{class }\bfcode{AnnotationHandler}}{\emph{annotation\_file}, \emph{stamp}}{}
Bases: \href{http://docs.python.org/library/xml.sax.handler.html\#xml.sax.handler.ContentHandler}{\code{xml.sax.handler.ContentHandler}}

Handlers used by SAX parsing the annotation files themselves

We have to collect all elements \emph{region}, \emph{node} and subelement \emph{link}, \emph{edge}, \emph{a} (annotation) and \emph{f} (feature).
From these elements we retrieve identifiers and other attributes. we map all identifiers to integers. When we have to associate one piece of data to other pieces, we create arrays of those integers.

The parse process is robust, we are not dependent on a particular ordering or distribution of the regions, nodes, edges, annotations and features in/over the annotation files.

Here is a description of the arrays we create:
\begin{description}
\item[{\emph{region\_begin}, \emph{region\_end}}] \leavevmode
Every region has an \emph{anchors} attribute specifying a point or interval in the primary data. We consider a point \emph{i} as the interval \emph{i .. i}.
\emph{region\_begin} contains the start anchor of region \emph{i} for each \emph{i}, and \emph{region\_end} the end anchor.

\item[{\emph{edges\_from}, \emph{edges\_to}}] \leavevmode
Every edge goes from one node to an other. \emph{edges\_from} contains the from node of edge \emph{i} for each \emph{i}, and \emph{edges\_end} the to node.

\end{description}

Here is a description of the dictionaries we create:
\begin{description}
\item[{\emph{feat\_name\_list\_node\_rep}, \emph{feat\_name\_list\_edge\_rep}, \emph{feat\_name\_list\_node\_int}, \emph{feat\_name\_list\_edge\_int}}] \leavevmode
Mappings from the string representations to the internal codes and vice versa, respectively, for feature names.
These are the \emph{extended} feature names, i.e. with the label of the annotation in which the feature occurs prepended to it (separated with a \code{.}).
Features for nodes occupy and features for edges occupy separate but similar datastructures.

\item[{\emph{feat\_value\_list\_rep}, \emph{feat\_value\_list\_int}}] \leavevmode
Mappings from the string representations to the internal codes and vice versa, respectively, for feature values.

\end{description}

There is also a list of arrays:
\begin{description}
\item[{\emph{node\_region\_list}}] \leavevmode
Element \emph{i} of this list contains an array with the regions attached to node \emph{i}.

\end{description}
\index{aid (AnnotationHandler attribute)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.parse.AnnotationHandler.aid}\pysigline{\bfcode{aid}\strong{ = None}}
\end{fulllineitems}

\index{alabel (AnnotationHandler attribute)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.parse.AnnotationHandler.alabel}\pysigline{\bfcode{alabel}\strong{ = None}}
\end{fulllineitems}

\index{aref (AnnotationHandler attribute)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.parse.AnnotationHandler.aref}\pysigline{\bfcode{aref}\strong{ = None}}
\end{fulllineitems}

\index{atype (AnnotationHandler attribute)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.parse.AnnotationHandler.atype}\pysigline{\bfcode{atype}\strong{ = None}}
\end{fulllineitems}

\index{characters() (AnnotationHandler method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.parse.AnnotationHandler.characters}\pysiglinewithargsret{\bfcode{characters}}{\emph{ch}}{}
\end{fulllineitems}

\index{endElement() (AnnotationHandler method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.parse.AnnotationHandler.endElement}\pysiglinewithargsret{\bfcode{endElement}}{\emph{name}}{}
\end{fulllineitems}

\index{file\_name (AnnotationHandler attribute)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.parse.AnnotationHandler.file_name}\pysigline{\bfcode{file\_name}\strong{ = None}}
\end{fulllineitems}

\index{nid (AnnotationHandler attribute)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.parse.AnnotationHandler.nid}\pysigline{\bfcode{nid}\strong{ = None}}
\end{fulllineitems}

\index{node\_link (AnnotationHandler attribute)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.parse.AnnotationHandler.node_link}\pysigline{\bfcode{node\_link}\strong{ = None}}
\end{fulllineitems}

\index{stamp (AnnotationHandler attribute)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.parse.AnnotationHandler.stamp}\pysigline{\bfcode{stamp}\strong{ = None}}
\end{fulllineitems}

\index{startElement() (AnnotationHandler method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.parse.AnnotationHandler.startElement}\pysiglinewithargsret{\bfcode{startElement}}{\emph{name}, \emph{attrs}}{}
\end{fulllineitems}


\end{fulllineitems}

\index{HeaderHandler (class in graf.parse)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.parse.HeaderHandler}\pysiglinewithargsret{\strong{class }\bfcode{HeaderHandler}}{\emph{stamp}}{}
Bases: \href{http://docs.python.org/library/xml.sax.handler.html\#xml.sax.handler.ContentHandler}{\code{xml.sax.handler.ContentHandler}}

Handlers used by SAX parsing the GrAF header file.

We just collect the contents of the \emph{loc} attributes of the \emph{annotation} elements.
These are the annotation files that we have to fetch and compile.
\index{characters() (HeaderHandler method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.parse.HeaderHandler.characters}\pysiglinewithargsret{\bfcode{characters}}{\emph{ch}}{}
\end{fulllineitems}

\index{endElement() (HeaderHandler method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.parse.HeaderHandler.endElement}\pysiglinewithargsret{\bfcode{endElement}}{\emph{name}}{}
\end{fulllineitems}

\index{stamp (HeaderHandler attribute)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.parse.HeaderHandler.stamp}\pysigline{\bfcode{stamp}\strong{ = None}}
\end{fulllineitems}

\index{startElement() (HeaderHandler method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.parse.HeaderHandler.startElement}\pysiglinewithargsret{\bfcode{startElement}}{\emph{name}, \emph{attrs}}{}
\end{fulllineitems}


\end{fulllineitems}

\index{add\_feature\_instance() (in module graf.parse)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.parse.add_feature_instance}\pysiglinewithargsret{\bfcode{add\_feature\_instance}}{\emph{atype}, \emph{name}, \emph{aref}, \emph{value}}{}
\end{fulllineitems}

\index{parse() (in module graf.parse)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.parse.parse}\pysiglinewithargsret{\bfcode{parse}}{\emph{graf\_header\_file}, \emph{stamp}}{}
Parse a GrAF resource.

Parses a GrAF resource, starting by SAX parsing its header file and subsequently parsing all
files mentioned in that header file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{graf\_header\_file} (\emph{str}) --
path to the GrAF header file

\item[{Returns}] \leavevmode
a tuple of items which comprise the parse results.

\end{description}\end{quote}

Every member of the returned tuple is itself a tuple of 3 pieces of information:
\begin{enumerate}
\item {} 
A \emph{key} which acts as a name for this part of the result data

\item {} 
The data itself, as described in {\hyperref[graf/graf:graf.parse.AnnotationHandler]{\code{AnnotationHandler}}}

\item {} 
A boolean indicating whether this data is a temporary result or a permanent result

\end{enumerate}

Temporary results will be discarded after the remodeling step, permanent results will be incorporated in
the task-executing object.

\end{fulllineitems}



\subsection{graf.shell module}
\label{graf/graf:graf-shell-module}\label{graf/graf:module-graf.shell}\index{graf.shell (module)}\index{Shell (class in graf.shell)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.shell.Shell}\pysigline{\strong{class }\bfcode{Shell}}
Bases: \code{object}

Execute tasks, either in a single run, or with an interactive prompt.

This class knows about the environment, such as command line arguments
and configuration files.
It collects those information pieces and passes them in suitable form
to the factual task processor.

Upon creation, create a {\hyperref[graf/graf:graf.task.GrafTask]{\code{GrafTask}}} object based on settings.
\index{command\_loop() (Shell method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.shell.Shell.command_loop}\pysiglinewithargsret{\bfcode{command\_loop}}{}{}
Command prompt for repeated running of tasks.

\end{fulllineitems}

\index{cur (Shell attribute)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.shell.Shell.cur}\pysigline{\bfcode{cur}\strong{ = None}}
Holds the current selection: the \emph{source}, the \emph{task} and the \emph{force\_compile} option, in that order.

\end{fulllineitems}

\index{default (Shell attribute)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.shell.Shell.default}\pysigline{\bfcode{default}\strong{ = None}}
Defaults for the selectable items: \emph{source} and \emph{task}.
If the user does not pass values for them both on the command lines, these ones are used.
If the user does pass some of these values and the command prompt is started, the
command line values are parsed here, and the command prompt will use them as initial values.

\end{fulllineitems}

\index{do\_command() (Shell method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.shell.Shell.do_command}\pysiglinewithargsret{\bfcode{do\_command}}{\emph{prompt}, \emph{choices}, \emph{helpstr}}{}
Prompts the user to enter a command and dispatches it, if correct.

This method asks the user for a command consisting of a single letter.
It checks whether the letter is a legal option.
It add options for quitting (Esc) and displaying help (?).
If he user enters \code{?}, the helpstring is displayed.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{prompt} (\emph{str}) --
the prompt string to be displayed.
This string will be extenden with a description of the allowed keys to press.

\item {} 
\textbf{choices} (\emph{str}) --
a string consisting of legal  one letter commands, not separated.

\item {} 
\textbf{helpstr} (\emph{str}) --
help string to be displayed if the user presses \code{?}

\end{itemize}

\item[{Returns}] \leavevmode
\textbf{command} (\emph{str}) --
the command entered by the user, or \code{None} if escape has been pressed.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_ch() (Shell method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.shell.Shell.get_ch}\pysiglinewithargsret{\bfcode{get\_ch}}{\emph{prompt='`}}{}
Asks for unbuffered single character input, with an optional prompt.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{prompt} (\emph{str}) --
Optional text to be displayed as prompt.

\item[{Returns}] \leavevmode
\textbf{ch} (\emph{char}) --
character pressed by the user.
If something gets wrong, returns the \emph{Esc} character.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_num() (Shell method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.shell.Shell.get_num}\pysiglinewithargsret{\bfcode{get\_num}}{\emph{prompt}, \emph{start}, \emph{end}}{}
Asks for a numeric value, and checks whether teh value is in a legal range.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{prompt} (\emph{str}) --
prompt to be displayed

\item {} 
\textbf{start} (\emph{str}) --
minimum legal value

\item {} 
\textbf{end} (\emph{str}) --
maximum legal value

\end{itemize}

\item[{Returns}] \leavevmode
\textbf{number} (\emph{int}) --
the number if the user entered something legal,
and \code{None} otherwise.

\end{description}\end{quote}

\end{fulllineitems}

\index{main\_command() (Shell method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.shell.Shell.main_command}\pysiglinewithargsret{\bfcode{main\_command}}{\emph{command}}{}
Interprets a top level command.

Depending on the command passed, this methods prompts for additional information.
This happens for the commands that modify the source and task selection.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{command} (\emph{char}) --
the command character.

\item[{Returns}] \leavevmode
\textbf{message} (\emph{str}) --
response text after the command execution.

\end{description}\end{quote}

\end{fulllineitems}

\index{message (Shell attribute)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.shell.Shell.message}\pysigline{\bfcode{message}\strong{ = None}}
Response messages to be displayed after the prompt

\end{fulllineitems}

\index{processor() (Shell method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.shell.Shell.processor}\pysiglinewithargsret{\bfcode{processor}}{}{}
Does work. Decides to run one task or start the command prompt.

The decision is based on the presence of command line arguments.
If all arguments are present to specify a task, the \emph{run once} option will be chosen,
unless the user has explicitly stated \code{-{-}menu}.
Otherwise the command prompt is started. If that is the case, the
command line args that did come through, are used as initial values.

\end{fulllineitems}

\index{prompt() (Shell method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.shell.Shell.prompt}\pysiglinewithargsret{\bfcode{prompt}}{}{}
Writes an self-explanatory prompt text to the terminal.

\end{fulllineitems}

\index{weave() (Shell method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.shell.Shell.weave}\pysiglinewithargsret{\bfcode{weave}}{\emph{data}}{}
Utility value that prepares data for presenting several columns of options
on a terminal screen.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{data} (\emph{lists of lists}) --
corresponds to a number of lists of options.

\item[{Returns}] \leavevmode
\textbf{woven} (\emph{list of lists}) --
correponds to a table where columns are the lists of options
and the options occupy rows. The outermost list are the rows.
index(dict of dict): given column number and then row number as keys yields the
name of the item at that slot
iindex(dict of dict): given column number and then the name of an item as keys yields the
row number of that item

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\subsection{graf.task module}
\label{graf/graf:graf-task-module}\label{graf/graf:module-graf.task}\index{graf.task (module)}\index{GrafTask (class in graf.task)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.task.GrafTask}\pysiglinewithargsret{\strong{class }\bfcode{GrafTask}}{\emph{settings}}{}
Bases: {\hyperref[graf/graf:graf.graf.Graf]{\code{graf.graf.Graf}}}

Task processor.

A task processor must know how to compile, where the source data is and where the result is going to.
And it must be able to \href{http://docs.python.org/reference/simple\_stmts.html\#import}{\code{import}}: and \href{http://docs.python.org/library/functions.html\#reload}{\code{reload()}}: the tasks.
To that end the search path for modules will be adapted according to the \emph{task\_dir} setting
in the main configuration file.

Upon creation, the configuration settings are store in the object as is
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{settings (} --
py:class:\emph{ConfigParser.ConfigParser}): entries corresponding to the main configuration file

\end{description}\end{quote}
\index{FEi() (GrafTask method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.task.GrafTask.FEi}\pysiglinewithargsret{\bfcode{FEi}}{\emph{edge}, \emph{name}}{}
Edge feature value lookup returning the value string representation.

\end{fulllineitems}

\index{FEr() (GrafTask method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.task.GrafTask.FEr}\pysiglinewithargsret{\bfcode{FEr}}{\emph{edge}, \emph{name}}{}
Edge feature value lookup returning the value string representation.
See method {\hyperref[graf/graf:graf.task.GrafTask.FEi]{\code{FEi()}}}.

\end{fulllineitems}

\index{FNi() (GrafTask method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.task.GrafTask.FNi}\pysiglinewithargsret{\bfcode{FNi}}{\emph{node}, \emph{name}}{}
Node feature value lookup returning the value string representation.

\end{fulllineitems}

\index{FNr() (GrafTask method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.task.GrafTask.FNr}\pysiglinewithargsret{\bfcode{FNr}}{\emph{node}, \emph{name}}{}
Node feature value lookup returning the value string representation.
See method {\hyperref[graf/graf:graf.task.GrafTask.FNi]{\code{FNi()}}}.

\end{fulllineitems}

\index{\_\_del\_\_() (GrafTask method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.task.GrafTask.__del__}\pysiglinewithargsret{\bfcode{\_\_del\_\_}}{}{}
Upon destruction, all file handles used by the task will be closed.

\end{fulllineitems}

\index{add\_result() (GrafTask method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.task.GrafTask.add_result}\pysiglinewithargsret{\bfcode{add\_result}}{\emph{file\_name}}{}
Opens a file for writing and stores the handle.

Every task is advised to use this method for opening files for its output.
The file will be closed by the workbench when the task terminates.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{file\_name} (\emph{str}) --
name of the output file.

\item {} 
\textbf{Its location is the result directory for this task and this source.}

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{common\_loader() (GrafTask method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.task.GrafTask.common_loader}\pysiglinewithargsret{\bfcode{common\_loader}}{\emph{source}}{}
Manage the common data to be loaded.

Common data is data  common to all tasks but specific to a source.

\end{fulllineitems}

\index{compile() (GrafTask method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.task.GrafTask.compile}\pysiglinewithargsret{\bfcode{compile}}{\emph{force\_compile}}{}
\end{fulllineitems}

\index{feature\_loader() (GrafTask method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.task.GrafTask.feature_loader}\pysiglinewithargsret{\bfcode{feature\_loader}}{\emph{directives}}{}
Manage the feature data to be loaded.

The specification of which features are selected is still a string.
Here we compile it into a dictionary \emph{only}, keyed with the extended feature name.

The loaded features together form a dictionary, keyed with the extended feature name.
The values are dictionaries keyed by the element, with as values the feature values.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{directives} (\emph{dict}) --
dictionary of strings string specifying the features selected for feature loading.
There are two keys: \emph{node} and \emph{edge}, because node features and edge features are handled separately.

\end{description}\end{quote}

\end{fulllineitems}

\index{finish\_task() (GrafTask method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.task.GrafTask.finish_task}\pysiglinewithargsret{\bfcode{finish\_task}}{}{}
Finalizes the current task.

There will be a progress message, and a directory listing of the result directory,
for the convenience of the user.

\end{fulllineitems}

\index{get\_mappings() (GrafTask method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.task.GrafTask.get_mappings}\pysiglinewithargsret{\bfcode{get\_mappings}}{}{}
Return references to API methods of this class.

The caller can give convenient, local names to these methods.
It also saves method lookup,
at least, I think so.

\end{fulllineitems}

\index{getitems() (GrafTask method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.task.GrafTask.getitems}\pysiglinewithargsret{\bfcode{getitems}}{\emph{data}, \emph{data\_items}, \emph{elem}}{}
Get related items from an arrayified data structure.

If a relation between integers and sets of integers has been stored as a double array
by the {\hyperref[graf/graf:graf.model.arrayify]{\code{arrayify()}}} function,
this is the way to look up the set of related integers for each integer.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{data} (\emph{array}) --
see next

\item {} 
\textbf{data\_items} (\emph{array}) --
together with \emph{data} the arrayified data

\item {} 
\textbf{elem} (\emph{int}) --
the integer for which we want its related set of integers.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{has\_compiled (GrafTask attribute)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.task.GrafTask.has_compiled}\pysigline{\bfcode{has\_compiled}\strong{ = None}}
Instance member to tell whether compilation has actually taken place

\end{fulllineitems}

\index{hasitem() (GrafTask method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.task.GrafTask.hasitem}\pysiglinewithargsret{\bfcode{hasitem}}{\emph{data}, \emph{data\_items}, \emph{elem}, \emph{item}}{}
Check whether an integer is in the set of related items
with respect to an arrayified data structure (see also {\hyperref[graf/graf:graf.task.GrafTask.getitems]{\code{getitems()}}}).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{data} (\emph{array}) --
see next

\item {} 
\textbf{data\_items} (\emph{array}) --
together with \emph{data} the arrayified data

\item {} 
\textbf{elem} (\emph{int}) --
the integer for which we want its related set of integers.

\item {} 
\textbf{item} (\emph{int}) --
the integer whose presence in the related items set is to be tested.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{hasitems() (GrafTask method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.task.GrafTask.hasitems}\pysiglinewithargsret{\bfcode{hasitems}}{\emph{data}, \emph{data\_items}, \emph{elem}, \emph{items}}{}
Check whether a set of integers intersects with the set of related items
with respect to an arrayified data structure (see also {\hyperref[graf/graf:graf.task.GrafTask.getitems]{\code{getitems()}}}).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{data} (\emph{array}) --
see next

\item {} 
\textbf{data\_items} (\emph{array}) --
together with \emph{data} the arrayified data

\item {} 
\textbf{elem} (\emph{int}) --
the integer for which we want its related set of integers.

\item {} 
\textbf{items} (\emph{array or list of integers}) --
the set of integers

\item {} 
\textbf{whose presence in the related items set is to be tested.}

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{init\_task() (GrafTask method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.task.GrafTask.init_task}\pysiglinewithargsret{\bfcode{init\_task}}{}{}
Initializes the current task.

Very trivial initialization: just issue a progress message.

\end{fulllineitems}

\index{int\_fname\_edge() (GrafTask method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.task.GrafTask.int_fname_edge}\pysiglinewithargsret{\bfcode{int\_fname\_edge}}{\emph{rep}}{}
API: \emph{feature name} (on edges) conversion from string representation as found in LAF resource
to corresponding integer as used in compiled resource.

\end{fulllineitems}

\index{int\_fname\_node() (GrafTask method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.task.GrafTask.int_fname_node}\pysiglinewithargsret{\bfcode{int\_fname\_node}}{\emph{rep}}{}
API: \emph{feature name} (on nodes) conversion from string representation as found in LAF resource
to corresponding integer as used in compiled resource.

\end{fulllineitems}

\index{int\_fval() (GrafTask method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.task.GrafTask.int_fval}\pysiglinewithargsret{\bfcode{int\_fval}}{\emph{rep}}{}
API: \emph{feature value} conversion from string representation as found in LAF resource
to corresponding integer as used in compiled resource.

\end{fulllineitems}

\index{loaded (GrafTask attribute)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.task.GrafTask.loaded}\pysigline{\bfcode{loaded}\strong{ = defaultdict(\textless{}function \textless{}lambda\textgreater{} at 0x10b70b8c0\textgreater{}, \{\})}}
Set of feature data sets that have been loaded, node features and edge features under different keys

\end{fulllineitems}

\index{loader() (GrafTask method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.task.GrafTask.loader}\pysiglinewithargsret{\bfcode{loader}}{\emph{source}, \emph{task}, \emph{directives}}{}
Loads compiled LAF data.

There are two kinds of data to be loaded:
\begin{description}
\item[{\emph{common data}}] \leavevmode
Data that is common to all tasks, but dependent on the choice of source.
It is the data that holds the regions, nodes, edges, but not the features.

\item[{\emph{feature data}}] \leavevmode
Data that is requested by the task at hand.
It is the data that holds feature information,
for those features that are requested by a task's \emph{feature} declaration.

\end{description}

The \emph{common data} can be loaded in bulk fast, but it still takes 5 to 10 seconds,
and should be avoided if possible.
This data only needs to be loaded if the source has changed or if compilation has taken place.
It is taken care of by {\hyperref[graf/graf:graf.task.GrafTask.common_loader]{\code{common\_loader()}}}.

The \emph{feature data} is loaded and unloaded on demand
and the feature manager method {\hyperref[graf/graf:graf.task.GrafTask.feature_loader]{\code{feature\_loader()}}} takes care of that.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{directives} (\emph{dict}) --
a dictionary of information

\item {} 
\textbf{relevant to} --
meth:\emph{common\_loader} and {\hyperref[graf/graf:graf.task.GrafTask.feature_loader]{\code{feature\_loader()}}}.

\end{itemize}

\end{description}\end{quote}

\begin{notice}{note}{Note:}
directives are only used by {\hyperref[graf/graf:graf.task.GrafTask.feature_loader]{\code{feature\_loader()}}}.
\end{notice}

\end{fulllineitems}

\index{next\_node() (GrafTask method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.task.GrafTask.next_node}\pysiglinewithargsret{\bfcode{next\_node}}{}{}
API: iterator of all nodes in primary data order.

Each call returns the next node. The iterator walks through all nodes.
The order is implied by the attachment of nodes to the primary data,
which is itself linearly ordered.
This order is explained in the {\hyperref[taskwriting:node-order]{\emph{guidelines for task writing}}}.

\end{fulllineitems}

\index{next\_node\_with\_fval() (GrafTask method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.task.GrafTask.next_node_with_fval}\pysiglinewithargsret{\bfcode{next\_node\_with\_fval}}{\emph{name}, \emph{value}}{}
API: iterator of all nodes in primary data order that have a
given value for a given feature.

See also {\hyperref[graf/graf:graf.task.GrafTask.next_node]{\code{next\_node()}}}.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{name} (\emph{int}) --
the code of a feature name

\item {} 
\textbf{value} (\emph{int}) --
the code of a feature value

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{rep\_fname\_edge() (GrafTask method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.task.GrafTask.rep_fname_edge}\pysiglinewithargsret{\bfcode{rep\_fname\_edge}}{\emph{intl}}{}
API: \emph{feature name} (on edges) conversion from integer code as used in compiled LAF resource
to corresponding string representation as found in original LAF resource.

\end{fulllineitems}

\index{rep\_fname\_node() (GrafTask method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.task.GrafTask.rep_fname_node}\pysiglinewithargsret{\bfcode{rep\_fname\_node}}{\emph{intl}}{}
API: \emph{feature name} (on nodes) conversion from integer code as used in compiled LAF resource
to corresponding string representation as found in original LAF resource.

\end{fulllineitems}

\index{rep\_fval() (GrafTask method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.task.GrafTask.rep_fval}\pysiglinewithargsret{\bfcode{rep\_fval}}{\emph{intl}}{}
API: \emph{feature value} conversion from integer code as used in compiled LAF resource
to corresponding string representation as found in original LAF resource.

\end{fulllineitems}

\index{result\_files (GrafTask attribute)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.task.GrafTask.result_files}\pysigline{\bfcode{result\_files}\strong{ = {[}{]}}}
List of handles to result files created by the task through the method {\hyperref[graf/graf:graf.task.GrafTask.add_result]{\code{add\_result()}}}

\end{fulllineitems}

\index{run() (GrafTask method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.task.GrafTask.run}\pysiglinewithargsret{\bfcode{run}}{\emph{source}, \emph{task}, \emph{force\_compile=False}}{}
Run a task.

That is:
* Load the data
* (Re)load the task code
* Initialize the task
* Run tha task code
* Finalize the task
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{source} (\emph{str}) --
key for the source

\item {} 
\textbf{task} --
the chosen task

\item {} 
\textbf{force\_compile} (\emph{bool}) --
whether to force (re)compilation of the LAF source

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{settings (GrafTask attribute)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.task.GrafTask.settings}\pysigline{\bfcode{settings}\strong{ = None}}
Instance member to hold configuration settings

\end{fulllineitems}

\index{source\_changed (GrafTask attribute)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.task.GrafTask.source_changed}\pysigline{\bfcode{source\_changed}\strong{ = None}}
Instance member to tell whether the source name has changed

\end{fulllineitems}

\index{task\_changed (GrafTask attribute)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.task.GrafTask.task_changed}\pysigline{\bfcode{task\_changed}\strong{ = None}}
Instance member to tell whether the task name has changed

\end{fulllineitems}


\end{fulllineitems}



\subsection{graf.timestamp module}
\label{graf/graf:graf-timestamp-module}\label{graf/graf:module-graf.timestamp}\index{graf.timestamp (module)}\index{Timestamp (class in graf.timestamp)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.timestamp.Timestamp}\pysiglinewithargsret{\strong{class }\bfcode{Timestamp}}{\emph{log\_file=None}}{}
Time management.

Objects remember their creation time. So they can issue statements about how much time has been elapsed.
All timed log messages of the program should be issued through the {\hyperref[graf/graf:graf.timestamp.Timestamp.progress]{\code{progress()}}} method of this class.

It is also possible to connect a logfile to these objects.
When progress messages are issued, they are also written to the connected log file.

Upon creation, retrieves the time.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{log\_file} (\emph{file}) --
open file handle for writing. Optional. If not \code{None} stores the handle in the object's data.

\end{description}\end{quote}
\index{connect\_log() (Timestamp method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.timestamp.Timestamp.connect_log}\pysiglinewithargsret{\bfcode{connect\_log}}{\emph{log\_file}}{}
Connects a log file to the object.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{log\_file} (\emph{file}) --
open handle for writing.

\end{description}\end{quote}

\end{fulllineitems}

\index{elapsed() (Timestamp method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.timestamp.Timestamp.elapsed}\pysiglinewithargsret{\bfcode{elapsed}}{}{}
Returns the time elapsed since creation of the {\hyperref[graf/graf:graf.timestamp.Timestamp]{\code{Timestamp}}} object.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
A pretty formatted string, ready to include in a message.

\end{description}\end{quote}

\end{fulllineitems}

\index{log (Timestamp attribute)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.timestamp.Timestamp.log}\pysigline{\bfcode{log}\strong{ = None}}
Instance member holding a handle to a logfile, open for writing, if a log file has been attached to the object.

\end{fulllineitems}

\index{progress() (Timestamp method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.timestamp.Timestamp.progress}\pysiglinewithargsret{\bfcode{progress}}{\emph{msg}, \emph{newline=True}}{}
API: issues a timed progress message.

The message is issued to the standard output, and, if a log file has been connected, also to the log file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{msg} (\emph{str}) --
text of the message

\item {} 
\textbf{newline} (\emph{bool}) --
whether or not to add a newline. Optional. Make it \code{False} to not add a newline.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{reset() (Timestamp method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.timestamp.Timestamp.reset}\pysiglinewithargsret{\bfcode{reset}}{}{}
Set the time to the current time

\end{fulllineitems}

\index{timestamp (Timestamp attribute)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.timestamp.Timestamp.timestamp}\pysigline{\bfcode{timestamp}\strong{ = None}}
Instance member holding the time the object was created

\end{fulllineitems}


\end{fulllineitems}



\subsection{Module contents}
\label{graf/graf:module-graf}\label{graf/graf:module-contents}\index{graf (module)}\index{Graf (class in graf)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.Graf}\pysigline{\strong{class }\bfcode{Graf}}
Bases: \code{object}

Base class for compiling LAF resources and running analytic tasks on them.

This class has only a rudimentary method set. Compiling a LAF resource is done by the GrafCompiler derived class
and running analytic tasks is done by the GrafTask class.

The data of this class represents the compiled data on the basis of which tasks can run.
This data is created by a {\hyperref[graf/graf:graf.compiler.GrafCompiler]{\code{GrafCompiler}}} that derives from this class.

Upon creation, empty datastructures are initialized to hold the binary,
compiled LAF data and create a directory for their serializations on disk.

The Graf object holds information that Graf tasks need to perform their operations.
The most important piece of information is the data itself.
This data consists of arrays and dictionaries that together hold the information that is compiled from a LAF resource.

Other things that happen:
\begin{enumerate}
\item {} 
a fresh Timestamp object is created, which records the current time and can issue progress messages containing the amount
of time that has elapsed since this object has been created.

\item {} 
if the directory that should hold the compiled data does not exist,
a new directory is created Of course this means that before executing any tasks,
the LAF resource has to be (re)compiled.

\end{enumerate}
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
object with data structures initialized, ready to load the compiled data from disk.

\end{description}\end{quote}
\index{BIN\_EXT (Graf attribute)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.Graf.BIN_EXT}\pysigline{\bfcode{BIN\_EXT}\strong{ = `bin'}}
\end{fulllineitems}

\index{COMPILE\_TASK (Graf attribute)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.Graf.COMPILE_TASK}\pysigline{\bfcode{COMPILE\_TASK}\strong{ = `compile'}}
\end{fulllineitems}

\index{LOG\_NAME (Graf attribute)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.Graf.LOG_NAME}\pysigline{\bfcode{LOG\_NAME}\strong{ = `\_\_log\_\_'}}
\end{fulllineitems}

\index{STAT\_NAME (Graf attribute)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.Graf.STAT_NAME}\pysigline{\bfcode{STAT\_NAME}\strong{ = `\_\_stat\_\_'}}
\end{fulllineitems}

\index{TEXT\_EXT (Graf attribute)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.Graf.TEXT_EXT}\pysigline{\bfcode{TEXT\_EXT}\strong{ = `txt'}}
\end{fulllineitems}

\index{\_\_del\_\_() (Graf method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.Graf.__del__}\pysiglinewithargsret{\bfcode{\_\_del\_\_}}{}{}
Clean up

Close all file handles that are still open.

\end{fulllineitems}

\index{add\_logfile() (Graf method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.Graf.add_logfile}\pysiglinewithargsret{\bfcode{add\_logfile}}{\emph{location=None}, \emph{name=None}}{}
Create and open a log file for a given task.

When tasks run, they generate progress messages with timing information in them.
They may issue errors and warnings. All this information also goes into a log file.
The log file is placed in the result directory of the task at hand.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{location} (\emph{str}) --
override default directory for log file

\item {} 
\textbf{name} (\emph{str}) --
override default name for log file

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{env (Graf attribute)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.Graf.env}\pysigline{\bfcode{env}\strong{ = None}}
\end{fulllineitems}

\index{init\_data() (Graf method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.Graf.init_data}\pysiglinewithargsret{\bfcode{init\_data}}{}{}
Resets all loaded data to initial values

This is needed when the task processor switches from one source to another,
or when a recompile has been performed.

\end{fulllineitems}

\index{log (Graf attribute)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.Graf.log}\pysigline{\bfcode{log}\strong{ = None}}
\end{fulllineitems}

\index{progress() (Graf method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.Graf.progress}\pysiglinewithargsret{\bfcode{progress}}{\emph{msg}}{}
Convenience method to call the progress of the associated stamp directly from the Graf object

\end{fulllineitems}

\index{read\_stats() (Graf method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.Graf.read_stats}\pysiglinewithargsret{\bfcode{read\_stats}}{}{}
Read compilation statistics from file

The compile process generates some statistics that must be read by the task that loads the compiled data.

\end{fulllineitems}

\index{set\_environment() (Graf method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.Graf.set_environment}\pysiglinewithargsret{\bfcode{set\_environment}}{\emph{source}, \emph{task}}{}
Set the source and result locations for a task execution.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{source} (\emph{str}) --
key for the source

\item {} 
\textbf{task} --
the chosen task

\end{itemize}

\end{description}\end{quote}

Sets \emph{self.env}, a dictionary containg:
\begin{itemize}
\item {} 
source: \emph{source}

\item {} 
task: \emph{task}

\item {} 
compile (bool): whether to force (re)compilation

\item {} 
settings (\href{http://docs.python.org/library/configparser.html\#ConfigParser.ConfigParser}{\code{ConfigParser.ConfigParser}}): entries corresponding to the main configuration file

\item {} 
additional computed settings adapt to the current source and task

\end{itemize}

\end{fulllineitems}

\index{stamp (Graf attribute)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.Graf.stamp}\pysigline{\bfcode{stamp}\strong{ = None}}
\end{fulllineitems}

\index{write\_stats() (Graf method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.Graf.write_stats}\pysiglinewithargsret{\bfcode{write\_stats}}{}{}
Write compilation statistics to file

The compile process generates some statistics that must be read by the task that loads the compiled data.

\end{fulllineitems}


\end{fulllineitems}

\index{GrafCompiler (class in graf)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.GrafCompiler}\pysiglinewithargsret{\strong{class }\bfcode{GrafCompiler}}{\emph{env}}{}
Bases: {\hyperref[graf/graf:graf.graf.Graf]{\code{graf.graf.Graf}}}

Takes care of the compilation of LAF xml data into binary data.

There are two stages in compilation:
\begin{itemize}
\item {} 
parsing the XML data by means of a SAX parser (a lengthy process)

\item {} 
remodeling the parse results in really tight data structures

\end{itemize}

Upon creation, the relevant directories are communicated.

The initialization of the base class is performed, and we change working directory to the location of the LAF source.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{env} (\emph{str}) --
path information

\end{description}\end{quote}
\index{compiler() (GrafCompiler method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.GrafCompiler.compiler}\pysiglinewithargsret{\bfcode{compiler}}{\emph{force=False}}{}
Manages the complete compilation process.

Detects the need for compiling, responds to the \emph{force} argument. Then parses, remodels and writes.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{force} (\emph{bool}) --
whether to compile even if the binary data looks up to date.

\end{description}\end{quote}

\end{fulllineitems}

\index{model() (GrafCompiler method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.GrafCompiler.model}\pysiglinewithargsret{\bfcode{model}}{}{}
Call the remodeler and store the remodeled data in the object.

\end{fulllineitems}

\index{needs\_compiling() (GrafCompiler method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.GrafCompiler.needs_compiling}\pysiglinewithargsret{\bfcode{needs\_compiling}}{}{}
Checks whether the compiled binary data is still up to date.

The criterion is whether the generated statistics file at the binary side is newer than the chosen GrAF header file.

\end{fulllineitems}

\index{parse() (GrafCompiler method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.GrafCompiler.parse}\pysiglinewithargsret{\bfcode{parse}}{}{}
Call the XML parser and collect the parse results.

Some parse results must be remodelled afterwards.
After remodelling some parse data can be thrown away.
Only store data that is needed for task execution in the object.

The actual parsing is done in the module {\hyperref[graf/graf:module-graf.parse]{\code{parse}}}.

\end{fulllineitems}

\index{temp\_data\_items (GrafCompiler attribute)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.GrafCompiler.temp_data_items}\pysigline{\bfcode{temp\_data\_items}\strong{ = \{\}}}
\end{fulllineitems}

\index{write\_data() (GrafCompiler method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.GrafCompiler.write_data}\pysiglinewithargsret{\bfcode{write\_data}}{}{}
Writes compiled data to disk.

Compiled data has three possible types:
\begin{description}
\item[{\emph{0: plain array}}] \leavevmode
can be written fast with the \code{array.tofile()} method

\item[{\emph{1: array valued dict}}] \leavevmode
a dictionary, keyed by a feature name and with arrays as values

\item[{\emph{2: list of trings}}] \leavevmode
can be dumped with the \code{cPickle.dump()} method.

\end{description}

\end{fulllineitems}


\end{fulllineitems}

\index{GrafTask (class in graf)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.GrafTask}\pysiglinewithargsret{\strong{class }\bfcode{GrafTask}}{\emph{settings}}{}
Bases: {\hyperref[graf/graf:graf.graf.Graf]{\code{graf.graf.Graf}}}

Task processor.

A task processor must know how to compile, where the source data is and where the result is going to.
And it must be able to \href{http://docs.python.org/reference/simple\_stmts.html\#import}{\code{import}}: and \href{http://docs.python.org/library/functions.html\#reload}{\code{reload()}}: the tasks.
To that end the search path for modules will be adapted according to the \emph{task\_dir} setting
in the main configuration file.

Upon creation, the configuration settings are store in the object as is
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{settings (} --
py:class:\emph{ConfigParser.ConfigParser}): entries corresponding to the main configuration file

\end{description}\end{quote}
\index{FEi() (GrafTask method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.GrafTask.FEi}\pysiglinewithargsret{\bfcode{FEi}}{\emph{edge}, \emph{name}}{}
Edge feature value lookup returning the value string representation.

\end{fulllineitems}

\index{FEr() (GrafTask method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.GrafTask.FEr}\pysiglinewithargsret{\bfcode{FEr}}{\emph{edge}, \emph{name}}{}
Edge feature value lookup returning the value string representation.
See method {\hyperref[graf/graf:graf.GrafTask.FEi]{\code{FEi()}}}.

\end{fulllineitems}

\index{FNi() (GrafTask method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.GrafTask.FNi}\pysiglinewithargsret{\bfcode{FNi}}{\emph{node}, \emph{name}}{}
Node feature value lookup returning the value string representation.

\end{fulllineitems}

\index{FNr() (GrafTask method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.GrafTask.FNr}\pysiglinewithargsret{\bfcode{FNr}}{\emph{node}, \emph{name}}{}
Node feature value lookup returning the value string representation.
See method {\hyperref[graf/graf:graf.GrafTask.FNi]{\code{FNi()}}}.

\end{fulllineitems}

\index{\_\_del\_\_() (GrafTask method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.GrafTask.__del__}\pysiglinewithargsret{\bfcode{\_\_del\_\_}}{}{}
Upon destruction, all file handles used by the task will be closed.

\end{fulllineitems}

\index{add\_result() (GrafTask method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.GrafTask.add_result}\pysiglinewithargsret{\bfcode{add\_result}}{\emph{file\_name}}{}
Opens a file for writing and stores the handle.

Every task is advised to use this method for opening files for its output.
The file will be closed by the workbench when the task terminates.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{file\_name} (\emph{str}) --
name of the output file.

\item {} 
\textbf{Its location is the result directory for this task and this source.}

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{common\_loader() (GrafTask method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.GrafTask.common_loader}\pysiglinewithargsret{\bfcode{common\_loader}}{\emph{source}}{}
Manage the common data to be loaded.

Common data is data  common to all tasks but specific to a source.

\end{fulllineitems}

\index{compile() (GrafTask method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.GrafTask.compile}\pysiglinewithargsret{\bfcode{compile}}{\emph{force\_compile}}{}
\end{fulllineitems}

\index{feature\_loader() (GrafTask method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.GrafTask.feature_loader}\pysiglinewithargsret{\bfcode{feature\_loader}}{\emph{directives}}{}
Manage the feature data to be loaded.

The specification of which features are selected is still a string.
Here we compile it into a dictionary \emph{only}, keyed with the extended feature name.

The loaded features together form a dictionary, keyed with the extended feature name.
The values are dictionaries keyed by the element, with as values the feature values.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{directives} (\emph{dict}) --
dictionary of strings string specifying the features selected for feature loading.
There are two keys: \emph{node} and \emph{edge}, because node features and edge features are handled separately.

\end{description}\end{quote}

\end{fulllineitems}

\index{finish\_task() (GrafTask method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.GrafTask.finish_task}\pysiglinewithargsret{\bfcode{finish\_task}}{}{}
Finalizes the current task.

There will be a progress message, and a directory listing of the result directory,
for the convenience of the user.

\end{fulllineitems}

\index{get\_mappings() (GrafTask method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.GrafTask.get_mappings}\pysiglinewithargsret{\bfcode{get\_mappings}}{}{}
Return references to API methods of this class.

The caller can give convenient, local names to these methods.
It also saves method lookup,
at least, I think so.

\end{fulllineitems}

\index{getitems() (GrafTask method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.GrafTask.getitems}\pysiglinewithargsret{\bfcode{getitems}}{\emph{data}, \emph{data\_items}, \emph{elem}}{}
Get related items from an arrayified data structure.

If a relation between integers and sets of integers has been stored as a double array
by the {\hyperref[graf/graf:graf.model.arrayify]{\code{arrayify()}}} function,
this is the way to look up the set of related integers for each integer.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{data} (\emph{array}) --
see next

\item {} 
\textbf{data\_items} (\emph{array}) --
together with \emph{data} the arrayified data

\item {} 
\textbf{elem} (\emph{int}) --
the integer for which we want its related set of integers.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{hasitem() (GrafTask method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.GrafTask.hasitem}\pysiglinewithargsret{\bfcode{hasitem}}{\emph{data}, \emph{data\_items}, \emph{elem}, \emph{item}}{}
Check whether an integer is in the set of related items
with respect to an arrayified data structure (see also {\hyperref[graf/graf:graf.GrafTask.getitems]{\code{getitems()}}}).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{data} (\emph{array}) --
see next

\item {} 
\textbf{data\_items} (\emph{array}) --
together with \emph{data} the arrayified data

\item {} 
\textbf{elem} (\emph{int}) --
the integer for which we want its related set of integers.

\item {} 
\textbf{item} (\emph{int}) --
the integer whose presence in the related items set is to be tested.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{hasitems() (GrafTask method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.GrafTask.hasitems}\pysiglinewithargsret{\bfcode{hasitems}}{\emph{data}, \emph{data\_items}, \emph{elem}, \emph{items}}{}
Check whether a set of integers intersects with the set of related items
with respect to an arrayified data structure (see also {\hyperref[graf/graf:graf.GrafTask.getitems]{\code{getitems()}}}).
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{data} (\emph{array}) --
see next

\item {} 
\textbf{data\_items} (\emph{array}) --
together with \emph{data} the arrayified data

\item {} 
\textbf{elem} (\emph{int}) --
the integer for which we want its related set of integers.

\item {} 
\textbf{items} (\emph{array or list of integers}) --
the set of integers

\item {} 
\textbf{whose presence in the related items set is to be tested.}

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{init\_task() (GrafTask method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.GrafTask.init_task}\pysiglinewithargsret{\bfcode{init\_task}}{}{}
Initializes the current task.

Very trivial initialization: just issue a progress message.

\end{fulllineitems}

\index{int\_fname\_edge() (GrafTask method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.GrafTask.int_fname_edge}\pysiglinewithargsret{\bfcode{int\_fname\_edge}}{\emph{rep}}{}
API: \emph{feature name} (on edges) conversion from string representation as found in LAF resource
to corresponding integer as used in compiled resource.

\end{fulllineitems}

\index{int\_fname\_node() (GrafTask method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.GrafTask.int_fname_node}\pysiglinewithargsret{\bfcode{int\_fname\_node}}{\emph{rep}}{}
API: \emph{feature name} (on nodes) conversion from string representation as found in LAF resource
to corresponding integer as used in compiled resource.

\end{fulllineitems}

\index{int\_fval() (GrafTask method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.GrafTask.int_fval}\pysiglinewithargsret{\bfcode{int\_fval}}{\emph{rep}}{}
API: \emph{feature value} conversion from string representation as found in LAF resource
to corresponding integer as used in compiled resource.

\end{fulllineitems}

\index{loaded (GrafTask attribute)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.GrafTask.loaded}\pysigline{\bfcode{loaded}\strong{ = defaultdict(\textless{}function \textless{}lambda\textgreater{} at 0x10b70b8c0\textgreater{}, \{\})}}
\end{fulllineitems}

\index{loader() (GrafTask method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.GrafTask.loader}\pysiglinewithargsret{\bfcode{loader}}{\emph{source}, \emph{task}, \emph{directives}}{}
Loads compiled LAF data.

There are two kinds of data to be loaded:
\begin{description}
\item[{\emph{common data}}] \leavevmode
Data that is common to all tasks, but dependent on the choice of source.
It is the data that holds the regions, nodes, edges, but not the features.

\item[{\emph{feature data}}] \leavevmode
Data that is requested by the task at hand.
It is the data that holds feature information,
for those features that are requested by a task's \emph{feature} declaration.

\end{description}

The \emph{common data} can be loaded in bulk fast, but it still takes 5 to 10 seconds,
and should be avoided if possible.
This data only needs to be loaded if the source has changed or if compilation has taken place.
It is taken care of by {\hyperref[graf/graf:graf.GrafTask.common_loader]{\code{common\_loader()}}}.

The \emph{feature data} is loaded and unloaded on demand
and the feature manager method {\hyperref[graf/graf:graf.GrafTask.feature_loader]{\code{feature\_loader()}}} takes care of that.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{directives} (\emph{dict}) --
a dictionary of information

\item {} 
\textbf{relevant to} --
meth:\emph{common\_loader} and {\hyperref[graf/graf:graf.GrafTask.feature_loader]{\code{feature\_loader()}}}.

\end{itemize}

\end{description}\end{quote}

\begin{notice}{note}{Note:}
directives are only used by {\hyperref[graf/graf:graf.GrafTask.feature_loader]{\code{feature\_loader()}}}.
\end{notice}

\end{fulllineitems}

\index{next\_node() (GrafTask method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.GrafTask.next_node}\pysiglinewithargsret{\bfcode{next\_node}}{}{}
API: iterator of all nodes in primary data order.

Each call returns the next node. The iterator walks through all nodes.
The order is implied by the attachment of nodes to the primary data,
which is itself linearly ordered.
This order is explained in the {\hyperref[taskwriting:node-order]{\emph{guidelines for task writing}}}.

\end{fulllineitems}

\index{next\_node\_with\_fval() (GrafTask method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.GrafTask.next_node_with_fval}\pysiglinewithargsret{\bfcode{next\_node\_with\_fval}}{\emph{name}, \emph{value}}{}
API: iterator of all nodes in primary data order that have a
given value for a given feature.

See also {\hyperref[graf/graf:graf.GrafTask.next_node]{\code{next\_node()}}}.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{name} (\emph{int}) --
the code of a feature name

\item {} 
\textbf{value} (\emph{int}) --
the code of a feature value

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{rep\_fname\_edge() (GrafTask method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.GrafTask.rep_fname_edge}\pysiglinewithargsret{\bfcode{rep\_fname\_edge}}{\emph{intl}}{}
API: \emph{feature name} (on edges) conversion from integer code as used in compiled LAF resource
to corresponding string representation as found in original LAF resource.

\end{fulllineitems}

\index{rep\_fname\_node() (GrafTask method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.GrafTask.rep_fname_node}\pysiglinewithargsret{\bfcode{rep\_fname\_node}}{\emph{intl}}{}
API: \emph{feature name} (on nodes) conversion from integer code as used in compiled LAF resource
to corresponding string representation as found in original LAF resource.

\end{fulllineitems}

\index{rep\_fval() (GrafTask method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.GrafTask.rep_fval}\pysiglinewithargsret{\bfcode{rep\_fval}}{\emph{intl}}{}
API: \emph{feature value} conversion from integer code as used in compiled LAF resource
to corresponding string representation as found in original LAF resource.

\end{fulllineitems}

\index{result\_files (GrafTask attribute)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.GrafTask.result_files}\pysigline{\bfcode{result\_files}\strong{ = {[}{]}}}
\end{fulllineitems}

\index{run() (GrafTask method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.GrafTask.run}\pysiglinewithargsret{\bfcode{run}}{\emph{source}, \emph{task}, \emph{force\_compile=False}}{}
Run a task.

That is:
* Load the data
* (Re)load the task code
* Initialize the task
* Run tha task code
* Finalize the task
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{source} (\emph{str}) --
key for the source

\item {} 
\textbf{task} --
the chosen task

\item {} 
\textbf{force\_compile} (\emph{bool}) --
whether to force (re)compilation of the LAF source

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{Timestamp (class in graf)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.Timestamp}\pysiglinewithargsret{\strong{class }\bfcode{Timestamp}}{\emph{log\_file=None}}{}
Time management.

Objects remember their creation time. So they can issue statements about how much time has been elapsed.
All timed log messages of the program should be issued through the {\hyperref[graf/graf:graf.Timestamp.progress]{\code{progress()}}} method of this class.

It is also possible to connect a logfile to these objects.
When progress messages are issued, they are also written to the connected log file.

Upon creation, retrieves the time.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{log\_file} (\emph{file}) --
open file handle for writing. Optional. If not \code{None} stores the handle in the object's data.

\end{description}\end{quote}
\index{connect\_log() (Timestamp method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.Timestamp.connect_log}\pysiglinewithargsret{\bfcode{connect\_log}}{\emph{log\_file}}{}
Connects a log file to the object.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{log\_file} (\emph{file}) --
open handle for writing.

\end{description}\end{quote}

\end{fulllineitems}

\index{elapsed() (Timestamp method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.Timestamp.elapsed}\pysiglinewithargsret{\bfcode{elapsed}}{}{}
Returns the time elapsed since creation of the {\hyperref[graf/graf:graf.Timestamp]{\code{Timestamp}}} object.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
A pretty formatted string, ready to include in a message.

\end{description}\end{quote}

\end{fulllineitems}

\index{progress() (Timestamp method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.Timestamp.progress}\pysiglinewithargsret{\bfcode{progress}}{\emph{msg}, \emph{newline=True}}{}
API: issues a timed progress message.

The message is issued to the standard output, and, if a log file has been connected, also to the log file.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{msg} (\emph{str}) --
text of the message

\item {} 
\textbf{newline} (\emph{bool}) --
whether or not to add a newline. Optional. Make it \code{False} to not add a newline.

\end{itemize}

\end{description}\end{quote}

\end{fulllineitems}

\index{reset() (Timestamp method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.Timestamp.reset}\pysiglinewithargsret{\bfcode{reset}}{}{}
Set the time to the current time

\end{fulllineitems}


\end{fulllineitems}

\index{Shell (class in graf)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.Shell}\pysigline{\strong{class }\bfcode{Shell}}
Bases: \code{object}

Execute tasks, either in a single run, or with an interactive prompt.

This class knows about the environment, such as command line arguments
and configuration files.
It collects those information pieces and passes them in suitable form
to the factual task processor.

Upon creation, create a {\hyperref[graf/graf:graf.task.GrafTask]{\code{GrafTask}}} object based on settings.
\index{command\_loop() (Shell method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.Shell.command_loop}\pysiglinewithargsret{\bfcode{command\_loop}}{}{}
Command prompt for repeated running of tasks.

\end{fulllineitems}

\index{do\_command() (Shell method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.Shell.do_command}\pysiglinewithargsret{\bfcode{do\_command}}{\emph{prompt}, \emph{choices}, \emph{helpstr}}{}
Prompts the user to enter a command and dispatches it, if correct.

This method asks the user for a command consisting of a single letter.
It checks whether the letter is a legal option.
It add options for quitting (Esc) and displaying help (?).
If he user enters \code{?}, the helpstring is displayed.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{prompt} (\emph{str}) --
the prompt string to be displayed.
This string will be extenden with a description of the allowed keys to press.

\item {} 
\textbf{choices} (\emph{str}) --
a string consisting of legal  one letter commands, not separated.

\item {} 
\textbf{helpstr} (\emph{str}) --
help string to be displayed if the user presses \code{?}

\end{itemize}

\item[{Returns}] \leavevmode
\textbf{command} (\emph{str}) --
the command entered by the user, or \code{None} if escape has been pressed.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_ch() (Shell method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.Shell.get_ch}\pysiglinewithargsret{\bfcode{get\_ch}}{\emph{prompt='`}}{}
Asks for unbuffered single character input, with an optional prompt.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{prompt} (\emph{str}) --
Optional text to be displayed as prompt.

\item[{Returns}] \leavevmode
\textbf{ch} (\emph{char}) --
character pressed by the user.
If something gets wrong, returns the \emph{Esc} character.

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_num() (Shell method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.Shell.get_num}\pysiglinewithargsret{\bfcode{get\_num}}{\emph{prompt}, \emph{start}, \emph{end}}{}
Asks for a numeric value, and checks whether teh value is in a legal range.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\textbf{prompt} (\emph{str}) --
prompt to be displayed

\item {} 
\textbf{start} (\emph{str}) --
minimum legal value

\item {} 
\textbf{end} (\emph{str}) --
maximum legal value

\end{itemize}

\item[{Returns}] \leavevmode
\textbf{number} (\emph{int}) --
the number if the user entered something legal,
and \code{None} otherwise.

\end{description}\end{quote}

\end{fulllineitems}

\index{main\_command() (Shell method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.Shell.main_command}\pysiglinewithargsret{\bfcode{main\_command}}{\emph{command}}{}
Interprets a top level command.

Depending on the command passed, this methods prompts for additional information.
This happens for the commands that modify the source and task selection.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{command} (\emph{char}) --
the command character.

\item[{Returns}] \leavevmode
\textbf{message} (\emph{str}) --
response text after the command execution.

\end{description}\end{quote}

\end{fulllineitems}

\index{processor() (Shell method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.Shell.processor}\pysiglinewithargsret{\bfcode{processor}}{}{}
Does work. Decides to run one task or start the command prompt.

The decision is based on the presence of command line arguments.
If all arguments are present to specify a task, the \emph{run once} option will be chosen,
unless the user has explicitly stated \code{-{-}menu}.
Otherwise the command prompt is started. If that is the case, the
command line args that did come through, are used as initial values.

\end{fulllineitems}

\index{prompt() (Shell method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.Shell.prompt}\pysiglinewithargsret{\bfcode{prompt}}{}{}
Writes an self-explanatory prompt text to the terminal.

\end{fulllineitems}

\index{weave() (Shell method)}

\begin{fulllineitems}
\phantomsection\label{graf/graf:graf.Shell.weave}\pysiglinewithargsret{\bfcode{weave}}{\emph{data}}{}
Utility value that prepares data for presenting several columns of options
on a terminal screen.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\textbf{data} (\emph{lists of lists}) --
corresponds to a number of lists of options.

\item[{Returns}] \leavevmode
\textbf{woven} (\emph{list of lists}) --
correponds to a table where columns are the lists of options
and the options occupy rows. The outermost list are the rows.
index(dict of dict): given column number and then row number as keys yields the
name of the item at that slot
iindex(dict of dict): given column number and then the name of an item as keys yields the
row number of that item

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}



\chapter{Indices and tables}
\label{index:indices-and-tables}\begin{itemize}
\item {} 
\emph{genindex}

\item {} 
\emph{modindex}

\item {} 
\emph{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{theindex}
\def\bigletter#1{{\Large\sffamily#1}\nopagebreak\vspace{1mm}}
\bigletter{e}
\item {\texttt{esther}}, \pageref{tasks/esther:module-esther}
\indexspace
\bigletter{g}
\item {\texttt{gender}}, \pageref{tasks/gender:module-gender}
\item {\texttt{graf}}, \pageref{graf/graf:module-graf}
\item {\texttt{graf.compiler}}, \pageref{graf/graf:module-graf.compiler}
\item {\texttt{graf.graf}}, \pageref{graf/graf:module-graf.graf}
\item {\texttt{graf.model}}, \pageref{graf/graf:module-graf.model}
\item {\texttt{graf.parse}}, \pageref{graf/graf:module-graf.parse}
\item {\texttt{graf.shell}}, \pageref{graf/graf:module-graf.shell}
\item {\texttt{graf.task}}, \pageref{graf/graf:module-graf.task}
\item {\texttt{graf.timestamp}}, \pageref{graf/graf:module-graf.timestamp}
\indexspace
\bigletter{i}
\item {\texttt{involved}}, \pageref{tasks/involved:module-involved}
\item {\texttt{isaiah}}, \pageref{tasks/isaiah:module-isaiah}
\indexspace
\bigletter{l}
\item {\texttt{lingo}}, \pageref{tasks/lingo:module-lingo}
\indexspace
\bigletter{o}
\item {\texttt{objects}}, \pageref{tasks/objects:module-objects}
\indexspace
\bigletter{p}
\item {\texttt{plain}}, \pageref{tasks/plain:module-plain}
\item {\texttt{proper}}, \pageref{tasks/proper:module-proper}
\end{theindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}
